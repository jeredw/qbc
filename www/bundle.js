new EventSource('/esbuild').addEventListener('change', () => location.reload());
(() => {
  // node_modules/.deno/antlr4ng@3.0.10/node_modules/antlr4ng/dist/index.mjs
  var __defProp = Object.defineProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var IntStream;
  ((IntStream2) => {
    IntStream2.EOF = -1;
    IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
  })(IntStream || (IntStream = {}));
  var Token;
  ((Token2) => {
    Token2.INVALID_TYPE = 0;
    Token2.EPSILON = -2;
    Token2.MIN_USER_TOKEN_TYPE = 1;
    Token2.EOF = IntStream.EOF;
    Token2.DEFAULT_CHANNEL = 0;
    Token2.HIDDEN_CHANNEL = 1;
    Token2.MIN_USER_CHANNEL_VALUE = 2;
  })(Token || (Token = {}));
  var isToken = /* @__PURE__ */ __name((candidate) => {
    const token = candidate;
    return token.tokenSource !== void 0 && token.channel !== void 0;
  }, "isToken");
  var Interval = class _Interval {
    static {
      __name(this, "Interval");
    }
    static INVALID_INTERVAL = new _Interval(-1, -2);
    static INTERVAL_POOL_MAX_VALUE = 1e3;
    static cache = [];
    start;
    stop;
    cachedHashCode;
    constructor(start, stop) {
      if (start <= stop) {
        this.start = start;
        this.stop = stop;
      } else {
        this.start = stop;
        this.stop = start;
      }
      this.cachedHashCode = Math.imul(651 + start, 31) + stop;
    }
    /**
     * Creates a new interval from the given values.
     *
     * Interval objects are used readonly so share all with the
     * same single value a==b up to some max size. Use an array as a perfect hash.
     * Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
     * Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
     * have a..a (set with 1 element).
     *
     * @param a The start of the interval.
     * @param b The end of the interval (inclusive).
     *
     * @returns A cached or new interval.
     */
    static of(a, b) {
      if (a !== b || a < 0 || a > _Interval.INTERVAL_POOL_MAX_VALUE) {
        return new _Interval(a, b);
      }
      if (!_Interval.cache[a]) {
        _Interval.cache[a] = new _Interval(a, a);
      }
      return _Interval.cache[a];
    }
    equals(o) {
      return this.start === o.start && this.stop === o.stop;
    }
    hashCode() {
      return this.cachedHashCode;
    }
    /** Does this start completely before other? Disjoint */
    startsBeforeDisjoint(other) {
      return this.start < other.start && this.stop < other.start;
    }
    /** Does this start at or before other? Nondisjoint */
    startsBeforeNonDisjoint(other) {
      return this.start <= other.start && this.stop >= other.start;
    }
    /** Does this.start start after other.stop? May or may not be disjoint */
    startsAfter(other) {
      return this.start > other.start;
    }
    /** Does this start completely after other? Disjoint */
    startsAfterDisjoint(other) {
      return this.start > other.stop;
    }
    /** Does this start after other? NonDisjoint */
    startsAfterNonDisjoint(other) {
      return this.start > other.start && this.start <= other.stop;
    }
    /** Are both ranges disjoint? I.e., no overlap? */
    disjoint(other) {
      return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
    }
    /** Are two intervals adjacent such as 0..41 and 42..42? */
    adjacent(other) {
      return this.start === other.stop + 1 || this.stop === other.start - 1;
    }
    properlyContains(other) {
      return other.start >= this.start && other.stop <= this.stop;
    }
    /** Return the interval computed from combining this and other */
    union(other) {
      return _Interval.of(Math.min(this.start, other.start), Math.max(this.stop, other.stop));
    }
    /** Return the interval in common between this and o */
    intersection(other) {
      return _Interval.of(Math.max(this.start, other.start), Math.min(this.stop, other.stop));
    }
    /**
     * Return the interval with elements from this not in other;
     *  other must not be totally enclosed (properly contained)
     *  within this, which would result in two disjoint intervals
     *  instead of the single one returned by this method.
     */
    differenceNotProperlyContained(other) {
      let diff = null;
      if (other.startsBeforeNonDisjoint(this)) {
        diff = _Interval.of(Math.max(this.start, other.stop + 1), this.stop);
      } else if (other.startsAfterNonDisjoint(this)) {
        diff = _Interval.of(this.start, other.start - 1);
      }
      return diff;
    }
    toString() {
      if (this.start === this.stop) {
        return this.start.toString();
      } else {
        return this.start.toString() + ".." + this.stop.toString();
      }
    }
    get length() {
      if (this.stop < this.start) {
        return 0;
      }
      return this.stop - this.start + 1;
    }
  };
  var Vocabulary = class _Vocabulary {
    static {
      __name(this, "Vocabulary");
    }
    static EMPTY_NAMES = [];
    /**
     * Gets an empty {@link Vocabulary} instance.
     *
     *
     * No literal or symbol names are assigned to token types, so
     * {@link #getDisplayName(int)} returns the numeric value for all tokens
     * except {@link Token#EOF}.
     */
    static EMPTY_VOCABULARY = new _Vocabulary(_Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES);
    maxTokenType;
    literalNames;
    symbolicNames;
    displayNames;
    /**
     * Constructs a new instance of {@link Vocabulary} from the specified
     * literal, symbolic, and display token names.
     *
     * @param literalNames The literal names assigned to tokens, or `null`
     * if no literal names are assigned.
     * @param symbolicNames The symbolic names assigned to tokens, or
     * `null` if no symbolic names are assigned.
     * @param displayNames The display names assigned to tokens, or `null`
     * to use the values in `literalNames` and `symbolicNames` as
     * the source of display names, as described in
     * {@link #getDisplayName(int)}.
     */
    constructor(literalNames, symbolicNames, displayNames) {
      this.literalNames = literalNames ?? _Vocabulary.EMPTY_NAMES;
      this.symbolicNames = symbolicNames ?? _Vocabulary.EMPTY_NAMES;
      this.displayNames = displayNames ?? _Vocabulary.EMPTY_NAMES;
      this.maxTokenType = Math.max(this.displayNames.length, Math.max(
        this.literalNames.length,
        this.symbolicNames.length
      )) - 1;
    }
    /**
     * Returns a {@link Vocabulary} instance from the specified set of token
     * names. This method acts as a compatibility layer for the single
     * `tokenNames` array generated by previous releases of ANTLR.
     *
     * The resulting vocabulary instance returns `null` for
     * {@link getLiteralName getLiteralName(int)} and {@link getSymbolicName getSymbolicName(int)}, and the
     * value from `tokenNames` for the display names.
     *
     * @param tokenNames The token names, or `null` if no token names are
     * available.
     * @returns A {@link Vocabulary} instance which uses `tokenNames` for
     * the display names of tokens.
     */
    static fromTokenNames(tokenNames) {
      if (tokenNames == null || tokenNames.length === 0) {
        return _Vocabulary.EMPTY_VOCABULARY;
      }
      const literalNames = [...tokenNames];
      const symbolicNames = [...tokenNames];
      for (let i = 0; i < tokenNames.length; i++) {
        const tokenName = tokenNames[i];
        if (tokenName == null) {
          continue;
        }
        if (tokenName?.length > 0) {
          const firstChar = tokenName.charAt(0);
          if (firstChar === "'") {
            symbolicNames[i] = null;
            continue;
          } else if (firstChar.toUpperCase() === firstChar) {
            literalNames[i] = null;
            continue;
          }
        }
        literalNames[i] = null;
        symbolicNames[i] = null;
      }
      return new _Vocabulary(literalNames, symbolicNames, tokenNames);
    }
    getMaxTokenType() {
      return this.maxTokenType;
    }
    getLiteralName(tokenType) {
      if (tokenType >= 0 && tokenType < this.literalNames.length) {
        return this.literalNames[tokenType];
      }
      return null;
    }
    getSymbolicName(tokenType) {
      if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
        return this.symbolicNames[tokenType];
      }
      if (tokenType === Token.EOF) {
        return "EOF";
      }
      return null;
    }
    getDisplayName(tokenType) {
      if (tokenType >= 0 && tokenType < this.displayNames.length) {
        const displayName = this.displayNames[tokenType];
        if (displayName != null) {
          return displayName;
        }
      }
      const literalName = this.getLiteralName(tokenType);
      if (literalName != null) {
        return literalName;
      }
      const symbolicName = this.getSymbolicName(tokenType);
      if (symbolicName != null) {
        return symbolicName;
      }
      return `${tokenType}`;
    }
    getLiteralNames() {
      return this.literalNames;
    }
    getSymbolicNames() {
      return this.symbolicNames;
    }
    getDisplayNames() {
      return this.displayNames;
    }
  };
  var c1 = 3432918353;
  var c2 = 461845907;
  var r1 = 15;
  var r2 = 13;
  var m = 5;
  var n = 3864292196;
  var MurmurHash = class _MurmurHash {
    static {
      __name(this, "MurmurHash");
    }
    static defaultSeed = 701;
    constructor() {
    }
    /**
     * Initialize the hash using the specified {@code seed}.
     *
     * @param seed the seed
     *
     * @returns the intermediate hash value
     */
    static initialize(seed = _MurmurHash.defaultSeed) {
      return seed;
    }
    static updateFromComparable(hash, value) {
      return this.update(hash, value?.hashCode() ?? 0);
    }
    /**
     * Update the intermediate hash value for the next input {@code value}.
     *
     * @param hash The intermediate hash value.
     * @param value the value to add to the current hash.
     *
     * @returns the updated intermediate hash value
     */
    static update(hash, value) {
      value = Math.imul(value, c1);
      value = value << r1 | value >>> 32 - r1;
      value = Math.imul(value, c2);
      hash = hash ^ value;
      hash = hash << r2 | hash >>> 32 - r2;
      hash = Math.imul(hash, m) + n;
      return hash;
    }
    /**
     * Apply the final computation steps to the intermediate value {@code hash}
     * to form the final result of the MurmurHash 3 hash function.
     *
     * @param hash The intermediate hash value.
     * @param entryCount The number of values added to the hash.
     *
     * @returns the final hash result
     */
    static finish(hash, entryCount) {
      hash ^= entryCount * 4;
      hash ^= hash >>> 16;
      hash = Math.imul(hash, 2246822507);
      hash ^= hash >>> 13;
      hash = Math.imul(hash, 3266489909);
      hash ^= hash >>> 16;
      return hash;
    }
    /**
     * An all-in-one convenience method to compute a hash for a single value.
     *
     * @param value The value to hash.
     * @param seed The seed for the hash value.
     *
     * @returns The computed hash.
     */
    static hashCode(value, seed) {
      return _MurmurHash.finish(_MurmurHash.update(seed ?? _MurmurHash.defaultSeed, value), 1);
    }
  };
  var IntervalSet = class _IntervalSet {
    static {
      __name(this, "IntervalSet");
    }
    /** The list of sorted, disjoint intervals. */
    intervals = [];
    cachedHashCode;
    constructor(set) {
      if (set) {
        this.addSet(set);
      }
    }
    /** Create a set with all ints within range [a..b] (inclusive) */
    static of(a, b) {
      const s = new _IntervalSet();
      s.addRange(a, b);
      return s;
    }
    /** Combine all sets in the array and return the union of them */
    static or(sets) {
      const result = new _IntervalSet();
      for (const set of sets) {
        result.addSet(set);
      }
      return result;
    }
    [Symbol.iterator]() {
      return this.intervals[Symbol.iterator]();
    }
    get(index) {
      return this.intervals[index];
    }
    /**
     * Returns the minimum value contained in the set if not isNil().
     *
     * @returns the minimum value contained in the set.
     */
    get minElement() {
      if (this.intervals.length === 0) {
        return Token.INVALID_TYPE;
      }
      return this.intervals[0].start;
    }
    /**
     * Returns the maximum value contained in the set if not isNil().
     *
     * @returns the maximum value contained in the set.
     */
    get maxElement() {
      if (this.intervals.length === 0) {
        return Token.INVALID_TYPE;
      }
      return this.intervals[this.intervals.length - 1].stop;
    }
    clear() {
      this.cachedHashCode = void 0;
      this.intervals = [];
    }
    /**
     * Add a single element to the set.  An isolated element is stored
     *  as a range el..el.
     */
    addOne(v) {
      this.addInterval(new Interval(v, v));
    }
    /**
     * Add interval; i.e., add all integers from a to b to set.
     *  If b < a, do nothing.
     *  Keep list in sorted order (by left range value).
     *  If overlap, combine ranges. For example,
     *  If this is {1..5, 10..20}, adding 6..7 yields
     *  {1..5, 6..7, 10..20}. Adding 4..8 yields {1..8, 10..20}.
     */
    addRange(l, h) {
      this.addInterval(new Interval(l, h));
    }
    addInterval(addition) {
      this.cachedHashCode = void 0;
      if (this.intervals.length === 0) {
        this.intervals.push(addition);
      } else {
        for (let pos = 0; pos < this.intervals.length; pos++) {
          const existing = this.intervals[pos];
          if (addition.equals(existing)) {
            return;
          }
          if (addition.adjacent(existing) || !addition.disjoint(existing)) {
            const bigger = addition.union(existing);
            this.intervals[pos] = bigger;
            for (let sub = pos + 1; sub < this.intervals.length; ) {
              const next = this.intervals[sub];
              if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                break;
              }
              this.intervals.splice(sub, 1);
              this.intervals[pos] = bigger.union(next);
            }
            return;
          }
          if (addition.startsBeforeDisjoint(existing)) {
            this.intervals.splice(pos, 0, addition);
            return;
          }
        }
        this.intervals.push(addition);
      }
    }
    addSet(other) {
      other.intervals.forEach((toAdd) => {
        return this.addInterval(toAdd);
      }, this);
      return this;
    }
    complementWithVocabulary(vocabulary) {
      const result = new _IntervalSet();
      if (!vocabulary) {
        return result;
      }
      if (vocabulary.length === 0) {
        return result;
      }
      result.addSet(vocabulary);
      return result.subtract(this);
    }
    complement(minElement, maxElement) {
      const result = new _IntervalSet();
      result.addInterval(new Interval(minElement, maxElement));
      return result.subtract(this);
    }
    /** combine all sets in the array returned the or'd value */
    or(sets) {
      const result = new _IntervalSet();
      result.addSet(this);
      sets.forEach((set) => {
        return result.addSet(set);
      });
      return result;
    }
    and(other) {
      if (other.length === 0) {
        return new _IntervalSet();
      }
      const myIntervals = this.intervals;
      const theirIntervals = other.intervals;
      let intersection;
      const mySize = myIntervals.length;
      const theirSize = theirIntervals.length;
      let i = 0;
      let j = 0;
      while (i < mySize && j < theirSize) {
        const mine = myIntervals[i];
        const theirs = theirIntervals[j];
        if (mine.startsBeforeDisjoint(theirs)) {
          i++;
        } else if (theirs.startsBeforeDisjoint(mine)) {
          j++;
        } else if (mine.properlyContains(theirs)) {
          if (!intersection) {
            intersection = new _IntervalSet();
          }
          intersection.addInterval(mine.intersection(theirs));
          j++;
        } else if (theirs.properlyContains(mine)) {
          if (!intersection) {
            intersection = new _IntervalSet();
          }
          intersection.addInterval(mine.intersection(theirs));
          i++;
        } else if (!mine.disjoint(theirs)) {
          if (!intersection) {
            intersection = new _IntervalSet();
          }
          intersection.addInterval(mine.intersection(theirs));
          if (mine.startsAfterNonDisjoint(theirs)) {
            j++;
          } else if (theirs.startsAfterNonDisjoint(mine)) {
            i++;
          }
        }
      }
      if (!intersection) {
        return new _IntervalSet();
      }
      return intersection;
    }
    /**
     * Compute the set difference between two interval sets. The specific
     * operation is `left - right`. If either of the input sets is
     * `null`, it is treated as though it was an empty set.
     */
    subtract(other) {
      if (this.length === 0) {
        return new _IntervalSet();
      }
      const result = new _IntervalSet(this);
      if (other.length === 0) {
        return result;
      }
      let resultI = 0;
      let rightI = 0;
      while (resultI < result.intervals.length && rightI < other.intervals.length) {
        const resultInterval = result.intervals[resultI];
        const rightInterval = other.intervals[rightI];
        if (rightInterval.stop < resultInterval.start) {
          rightI++;
          continue;
        }
        if (rightInterval.start > resultInterval.stop) {
          resultI++;
          continue;
        }
        let beforeCurrent;
        let afterCurrent;
        if (rightInterval.start > resultInterval.start) {
          beforeCurrent = new Interval(resultInterval.start, rightInterval.start - 1);
        }
        if (rightInterval.stop < resultInterval.stop) {
          afterCurrent = new Interval(rightInterval.stop + 1, resultInterval.stop);
        }
        if (beforeCurrent) {
          if (afterCurrent) {
            result.intervals[resultI] = beforeCurrent;
            result.intervals.splice(resultI + 1, 0, afterCurrent);
            resultI++;
            rightI++;
          } else {
            result.intervals[resultI] = beforeCurrent;
            resultI++;
          }
        } else {
          if (afterCurrent) {
            result.intervals[resultI] = afterCurrent;
            rightI++;
          } else {
            result.intervals.splice(resultI, 1);
          }
        }
      }
      return result;
    }
    contains(el) {
      const n2 = this.intervals.length;
      let l = 0;
      let r = n2 - 1;
      while (l <= r) {
        const m2 = Math.floor((l + r) / 2);
        const interval = this.intervals[m2];
        if (interval.stop < el) {
          l = m2 + 1;
        } else if (interval.start > el) {
          r = m2 - 1;
        } else {
          return true;
        }
      }
      return false;
    }
    removeRange(toRemove) {
      this.cachedHashCode = void 0;
      if (toRemove.start === toRemove.stop) {
        this.removeOne(toRemove.start);
      } else if (this.intervals !== null) {
        let pos = 0;
        for (const existing of this.intervals) {
          if (toRemove.stop <= existing.start) {
            return;
          } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
            this.intervals[pos] = new Interval(existing.start, toRemove.start);
            const x = new Interval(toRemove.stop, existing.stop);
            this.intervals.splice(pos, 0, x);
            return;
          } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
            this.intervals.splice(pos, 1);
            pos = pos - 1;
          } else if (toRemove.start < existing.stop) {
            this.intervals[pos] = new Interval(existing.start, toRemove.start);
          } else if (toRemove.stop < existing.stop) {
            this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
          }
          pos += 1;
        }
      }
    }
    removeOne(value) {
      this.cachedHashCode = void 0;
      for (let i = 0; i < this.intervals.length; i++) {
        const existing = this.intervals[i];
        if (value < existing.start) {
          return;
        } else if (value === existing.start && value === existing.stop) {
          this.intervals.splice(i, 1);
          return;
        } else if (value === existing.start) {
          this.intervals[i] = new Interval(existing.start + 1, existing.stop);
          return;
        } else if (value === existing.stop) {
          this.intervals[i] = new Interval(existing.start, existing.stop);
          return;
        } else if (value < existing.stop) {
          const replace = new Interval(existing.start, value);
          this.intervals[i] = new Interval(value + 1, existing.stop);
          this.intervals.splice(i, 0, replace);
          return;
        }
      }
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        for (const interval of this.intervals) {
          hash = MurmurHash.update(hash, interval.start);
          hash = MurmurHash.update(hash, interval.stop);
        }
        this.cachedHashCode = MurmurHash.finish(hash, this.intervals.length * 2);
      }
      return this.cachedHashCode;
    }
    /**
     * Are two IntervalSets equal? Because all intervals are sorted and disjoint, equals is a simple linear walk over
     * both lists to make sure they are the same. Interval.equals() is used by the List.equals() method to check
     * the ranges.
     */
    equals(other) {
      if (this === other) {
        return true;
      }
      if (this.intervals.length !== other.intervals.length) {
        return false;
      }
      for (let i = 0; i < this.intervals.length; i++) {
        if (!this.intervals[i].equals(other.intervals[i])) {
          return false;
        }
      }
      return true;
    }
    toString(elementsAreChar) {
      if (this.intervals.length === 0) {
        return "{}";
      }
      let result = "";
      if (this.length > 1) {
        result += "{";
      }
      for (let i = 0; i < this.intervals.length; ++i) {
        const interval = this.intervals[i];
        const start = interval.start;
        const stop = interval.stop;
        if (start === stop) {
          if (start === Token.EOF) {
            result += "<EOF>";
          } else if (elementsAreChar) {
            result += "'" + String.fromCodePoint(start) + "'";
          } else {
            result += start;
          }
        } else {
          if (elementsAreChar) {
            result += "'" + String.fromCodePoint(start) + "'..'" + String.fromCodePoint(stop) + "'";
          } else {
            result += start + ".." + stop;
          }
        }
        if (i < this.intervals.length - 1) {
          result += ", ";
        }
      }
      if (this.length > 1) {
        result += "}";
      }
      return result;
    }
    toStringWithVocabulary(vocabulary) {
      if (this.intervals.length === 0) {
        return "{}";
      }
      let result = "";
      if (this.length > 1) {
        result += "{";
      }
      for (let i = 0; i < this.intervals.length; ++i) {
        const interval = this.intervals[i];
        const start = interval.start;
        const stop = interval.stop;
        if (start === stop) {
          if (start === Token.EOF) {
            result += "<EOF>";
          } else {
            result += this.elementName(vocabulary, start);
          }
        } else {
          for (let i2 = start; i2 <= stop; ++i2) {
            if (i2 > start) {
              result += ", ";
            }
            result += this.elementName(vocabulary, i2);
          }
        }
        if (i < this.intervals.length - 1) {
          result += ", ";
        }
      }
      if (this.length > 1) {
        result += "}";
      }
      return result;
    }
    toStringWithRuleNames(ruleNames) {
      if (this.intervals.length === 0) {
        return "{}";
      }
      let result = "";
      if (this.length > 1) {
        result += "{";
      }
      const vocabulary = Vocabulary.fromTokenNames(ruleNames);
      for (let i = 0; i < this.intervals.length; ++i) {
        const interval = this.intervals[i];
        const start = interval.start;
        const stop = interval.stop;
        if (start === stop) {
          if (start === Token.EOF) {
            result += "<EOF>";
          } else {
            result += this.elementName(vocabulary, start);
          }
        } else {
          for (let i2 = start; i2 <= stop; ++i2) {
            if (i2 > start) {
              result += ", ";
            }
            result += this.elementName(vocabulary, i2);
          }
        }
        if (i < this.intervals.length - 1) {
          result += ", ";
        }
      }
      if (this.length > 1) {
        result += "}";
      }
      return result;
    }
    toArray() {
      const data = [];
      for (const interval of this.intervals) {
        for (let j = interval.start; j <= interval.stop; j++) {
          data.push(j);
        }
      }
      return data;
    }
    /** @returns the number of elements in this set. */
    get length() {
      let result = 0;
      for (const interval of this.intervals) {
        result += interval.length;
      }
      return result;
    }
    elementName(vocabulary, token) {
      if (token === Token.EOF) {
        return "<EOF>";
      }
      if (token === Token.EPSILON) {
        return "<EPSILON>";
      }
      return vocabulary.getDisplayName(token);
    }
  };
  var Transition = class {
    static {
      __name(this, "Transition");
    }
    static INVALID = 0;
    static EPSILON = 1;
    static RANGE = 2;
    static RULE = 3;
    static PREDICATE = 4;
    // e.g., {isType(input.LT(1))}
    static ATOM = 5;
    static ACTION = 6;
    static SET = 7;
    // ~(A|B) or ~atom, wildcard, which convert to next
    static NOT_SET = 8;
    static WILDCARD = 9;
    static PRECEDENCE = 10;
    /** The target of this transition. */
    target;
    constructor(target) {
      this.target = target;
    }
    /**
     * Determines if the transition is an "epsilon" transition.
     *
     * The default implementation returns `false`.
     *
     * @returns `true` if traversing this transition in the ATN does not
     * consume an input symbol; otherwise, `false` if traversing this
     * transition consumes (matches) an input symbol.
     */
    get isEpsilon() {
      return false;
    }
    get label() {
      return null;
    }
  };
  var SetTransition = class extends Transition {
    static {
      __name(this, "SetTransition");
    }
    set;
    constructor(target, set) {
      super(target);
      if (set) {
        this.set = set;
      } else {
        this.set = IntervalSet.of(Token.INVALID_TYPE, Token.INVALID_TYPE);
      }
    }
    get transitionType() {
      return Transition.SET;
    }
    get label() {
      return this.set;
    }
    matches(symbol, _minVocabSymbol, _maxVocabSymbol) {
      return this.set.contains(symbol);
    }
    toString() {
      return this.set.toString();
    }
  };
  var NotSetTransition = class extends SetTransition {
    static {
      __name(this, "NotSetTransition");
    }
    get transitionType() {
      return Transition.NOT_SET;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
    }
    toString() {
      return "~" + super.toString();
    }
  };
  var PredictionContext = class _PredictionContext {
    static {
      __name(this, "PredictionContext");
    }
    /**
     * Represents `$` in an array in full context mode, when `$`
     * doesn't mean wildcard: `$ + x = [$,x]`. Here,
     * `$` = {@link EMPTY_RETURN_STATE}.
     */
    static EMPTY_RETURN_STATE = 2147483647;
    // TODO: Temporarily here. Should be moved to EmptyPredictionContext. It's initialized in that context class.
    static EMPTY;
    static traceATNSimulator = false;
    cachedHashCode;
    constructor(cachedHashCode) {
      this.cachedHashCode = cachedHashCode;
    }
    static calculateEmptyHashCode() {
      let hash = MurmurHash.initialize(31);
      hash = MurmurHash.finish(hash, 0);
      return hash;
    }
    static calculateHashCodeSingle(parent, returnState) {
      let hash = MurmurHash.initialize(31);
      hash = MurmurHash.updateFromComparable(hash, parent);
      hash = MurmurHash.update(hash, returnState);
      hash = MurmurHash.finish(hash, 2);
      return hash;
    }
    static calculateHashCodeList(parents, returnStates) {
      let hash = MurmurHash.initialize(31);
      for (const parent of parents) {
        hash = MurmurHash.updateFromComparable(hash, parent);
      }
      for (const returnState of returnStates) {
        hash = MurmurHash.update(hash, returnState);
      }
      hash = MurmurHash.finish(hash, 2 * parents.length);
      return hash;
    }
    isEmpty() {
      return false;
    }
    hasEmptyPath() {
      return this.getReturnState(this.length - 1) === _PredictionContext.EMPTY_RETURN_STATE;
    }
    hashCode() {
      return this.cachedHashCode;
    }
    toString(_recog) {
      return "";
    }
  };
  var valueToString = /* @__PURE__ */ __name((v) => {
    return v === null ? "null" : v;
  }, "valueToString");
  var arrayToString = /* @__PURE__ */ __name((value) => {
    return Array.isArray(value) ? "[" + value.map(valueToString).join(", ") + "]" : "null";
  }, "arrayToString");
  var equalArrays = /* @__PURE__ */ __name((a, b) => {
    if (a === b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      const left = a[i];
      const right = b[i];
      if (left === right) {
        continue;
      }
      if (!left || !left.equals(right)) {
        return false;
      }
    }
    return true;
  }, "equalArrays");
  var equalNumberArrays = /* @__PURE__ */ __name((a, b) => {
    if (a === b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }, "equalNumberArrays");
  var escapeWhitespace = /* @__PURE__ */ __name((s, escapeSpaces = false) => {
    s = s.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
    if (escapeSpaces) {
      s = s.replace(/ /g, "\xB7");
    }
    return s;
  }, "escapeWhitespace");
  var ArrayPredictionContext = class _ArrayPredictionContext extends PredictionContext {
    static {
      __name(this, "ArrayPredictionContext");
    }
    parents = [];
    returnStates = [];
    constructor(parents, returnStates) {
      super(PredictionContext.calculateHashCodeList(parents, returnStates));
      this.parents = parents;
      this.returnStates = returnStates;
      return this;
    }
    isEmpty() {
      return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
    }
    get length() {
      return this.returnStates.length;
    }
    getParent(index) {
      return this.parents[index];
    }
    getReturnState(index) {
      return this.returnStates[index];
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _ArrayPredictionContext) || this.hashCode() !== other.hashCode()) {
        return false;
      }
      return equalNumberArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
    }
    toString() {
      if (this.isEmpty()) {
        return "[]";
      }
      const entries = [];
      for (let i = 0; i < this.returnStates.length; i++) {
        if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
          entries.push("$");
          continue;
        }
        entries.push(this.returnStates[i].toString());
        if (this.parents[i]) {
          entries.push(this.parents[i].toString());
        } else {
          entries.push("null");
        }
      }
      return `[${entries.join(", ")}]`;
    }
  };
  var SingletonPredictionContext = class _SingletonPredictionContext extends PredictionContext {
    static {
      __name(this, "SingletonPredictionContext");
    }
    parent;
    returnState;
    constructor(parent, returnState) {
      super(
        parent ? PredictionContext.calculateHashCodeSingle(parent, returnState) : PredictionContext.calculateEmptyHashCode()
      );
      this.parent = parent ?? null;
      this.returnState = returnState;
    }
    static create(parent, returnState) {
      if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
        return PredictionContext.EMPTY;
      } else {
        return new _SingletonPredictionContext(parent, returnState);
      }
    }
    getParent(_index) {
      return this.parent;
    }
    getReturnState(_index) {
      return this.returnState;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _SingletonPredictionContext)) {
        return false;
      }
      if (this.hashCode() !== other.hashCode()) {
        return false;
      }
      if (this.returnState !== other.returnState) {
        return false;
      }
      if (this.parent == null) {
        return other.parent == null;
      }
      return this.parent.equals(other.parent);
    }
    toString() {
      const up = this.parent === null ? "" : this.parent.toString();
      if (up.length === 0) {
        if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
          return "$";
        }
        return "" + this.returnState;
      } else {
        return "" + this.returnState + " " + up;
      }
    }
    get length() {
      return 1;
    }
  };
  var EmptyPredictionContext = class _EmptyPredictionContext extends SingletonPredictionContext {
    static {
      __name(this, "EmptyPredictionContext");
    }
    /**
     * Represents `$` in local context prediction, which means wildcard.
     * `*+x = *`.
     */
    static instance = new _EmptyPredictionContext();
    constructor() {
      super(void 0, PredictionContext.EMPTY_RETURN_STATE);
    }
    isEmpty() {
      return true;
    }
    getParent() {
      return null;
    }
    getReturnState() {
      return this.returnState;
    }
    equals(other) {
      return this === other;
    }
    toString() {
      return "$";
    }
    static {
      PredictionContext.EMPTY = new _EmptyPredictionContext();
    }
  };
  var TerminalNode = class {
    static {
      __name(this, "TerminalNode");
    }
    parent = null;
    symbol;
    constructor(symbol) {
      this.symbol = symbol;
    }
    getChild(_i) {
      return null;
    }
    getSymbol() {
      return this.symbol;
    }
    getPayload() {
      return this.symbol;
    }
    getSourceInterval() {
      if (this.symbol === null) {
        return Interval.INVALID_INTERVAL;
      }
      const tokenIndex = this.symbol.tokenIndex;
      return new Interval(tokenIndex, tokenIndex);
    }
    getChildCount() {
      return 0;
    }
    accept(visitor) {
      return visitor.visitTerminal(this);
    }
    getText() {
      return this.symbol?.text ?? "";
    }
    toString() {
      if (this.symbol?.type === Token.EOF) {
        return "<EOF>";
      } else {
        return this.symbol?.text ?? "";
      }
    }
    toStringTree() {
      return this.toString();
    }
  };
  var ErrorNode = class extends TerminalNode {
    static {
      __name(this, "ErrorNode");
    }
    accept(visitor) {
      return visitor.visitErrorNode(this);
    }
  };
  var CommonToken = class _CommonToken {
    static {
      __name(this, "CommonToken");
    }
    /**
     * An empty tuple which is used as the default value of
     * {@link source} for tokens that do not have a source.
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    static EMPTY_SOURCE = [null, null];
    /**
     * These properties share a field to reduce the memory footprint of
     * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from
     * the same source and input stream share a reference to the same
     * {@link Pair} containing these values.
     */
    source;
    tokenIndex;
    start;
    stop;
    /**
     * This is the backing field for {@link #getType} and {@link #setType}.
     */
    type;
    /**
     * The (one-based) line number on which the 1st character of this token was.
     */
    line;
    /**
     * The zero-based index of the first character position in its line.
     */
    column;
    /**
     * The token's channel.
     */
    channel;
    /**
     * This is the backing field for {@link getText} when the token text is
     * explicitly set in the constructor or via {@link setText}.
     */
    #text;
    constructor(details) {
      this.type = details.type;
      this.source = details.source;
      this.tokenIndex = details.tokenIndex ?? -1;
      this.line = details.line ?? 0;
      this.column = details.column ?? -1;
      this.channel = details.channel ?? Token.DEFAULT_CHANNEL;
      this.start = details.start ?? 0;
      this.stop = details.stop ?? 0;
      this.#text = details.text;
      if (details.line === void 0 && details.source[0] !== null) {
        this.line = details.source[0].line;
      }
      if (details.column === void 0 && details.source[0] !== null) {
        this.column = details.source[0].column;
      }
    }
    /**
     * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
     *
     * If `token` is also a {@link CommonToken} instance, the newly
     * constructed token will share a reference to the {@link #text} field and
     * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will
     * be assigned the result of calling {@link getText}, and {@link source}
     * will be constructed from the result of {@link Token.getTokenSource} and
     * {@link Token#getInputStream}.
     *
     * @param token The token to copy.
     */
    static fromToken(token) {
      const source = [token.tokenSource, token.inputStream];
      return new _CommonToken({
        type: token.type,
        line: token.line,
        tokenIndex: token.tokenIndex,
        column: token.column,
        channel: token.channel,
        start: token.start,
        stop: token.stop,
        text: token.text,
        source
      });
    }
    /**
     * Constructs a new {@link CommonToken} with the specified token type and text.
     *
     * @param type The token type.
     * @param text The text of the token.
     */
    static fromType(type, text) {
      return new _CommonToken({ type, text, source: _CommonToken.EMPTY_SOURCE });
    }
    static fromSource(source, type, channel, start, stop) {
      return new _CommonToken({ type, channel, start, stop, source });
    }
    get tokenSource() {
      return this.source[0];
    }
    get inputStream() {
      return this.source[1];
    }
    set inputStream(input) {
      this.source[1] = input;
    }
    /**
     * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
     *
     * If `oldToken` is also a {@link CommonToken} instance, the newly
     * constructed token will share a reference to the {@link text} field and
     * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will
     * be assigned the result of calling {@link getText}, and {@link source}
     * will be constructed from the result of {@link Token.getTokenSource} and
     * {@link Token.getInputStream}.
     */
    clone() {
      const t = new _CommonToken({
        source: this.source,
        type: this.type,
        channel: this.channel,
        start: this.start,
        stop: this.stop,
        tokenIndex: this.tokenIndex,
        line: this.line,
        column: this.column,
        text: this.#text
      });
      return t;
    }
    toString(recognizer) {
      let channelStr = "";
      if (this.channel > 0) {
        channelStr = ",channel=" + this.channel;
      }
      let text = this.text;
      if (text) {
        text = text.replace(/\n/g, "\\n");
        text = text.replace(/\r/g, "\\r");
        text = text.replace(/\t/g, "\\t");
      } else {
        text = "<no text>";
      }
      let typeString = String(this.type);
      if (recognizer) {
        typeString = recognizer.vocabulary.getDisplayName(this.type) ?? "<unknown>";
      }
      return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + text + "',<" + typeString + ">" + channelStr + "," + this.line + ":" + this.column + "]";
    }
    get text() {
      if (this.#text !== void 0) {
        return this.#text;
      }
      const input = this.inputStream;
      if (!input) {
        return void 0;
      }
      const n2 = input.size;
      if (this.start < n2 && this.stop < n2) {
        return input.getTextFromRange(this.start, this.stop);
      }
      return "<EOF>";
    }
    set text(text) {
      this.#text = text;
    }
    // WritableToken implementation
    setText(text) {
      this.#text = text;
    }
    setType(ttype) {
      this.type = ttype;
    }
    setLine(line) {
      this.line = line;
    }
    setCharPositionInLine(pos) {
      this.column = pos;
    }
    setChannel(channel) {
      this.channel = channel;
    }
    setTokenIndex(index) {
      this.tokenIndex = index;
    }
  };
  var Trees = class _Trees {
    static {
      __name(this, "Trees");
    }
    /**
     * Print out a whole tree in LISP form. {@link getNodeText} is used on the
     * node payloads to get the text for the nodes.  Detect
     * parse trees and extract data appropriately.
     */
    static toStringTree(tree, ruleNames, recog) {
      ruleNames = ruleNames ?? null;
      if (recog) {
        ruleNames = recog.ruleNames;
      }
      let s = _Trees.getNodeText(tree, ruleNames);
      s = escapeWhitespace(s, false);
      const c = tree.getChildCount();
      if (c === 0) {
        return s;
      }
      let res = "(" + s + " ";
      if (c > 0) {
        s = _Trees.toStringTree(tree.getChild(0), ruleNames);
        res = res.concat(s);
      }
      for (let i = 1; i < c; i++) {
        s = _Trees.toStringTree(tree.getChild(i), ruleNames);
        res = res.concat(" " + s);
      }
      res = res.concat(")");
      return res;
    }
    static getNodeText(t, ruleNames, recog) {
      ruleNames = ruleNames ?? null;
      if (recog) {
        ruleNames = recog.ruleNames;
      }
      if (ruleNames !== null) {
        if (t instanceof ParserRuleContext) {
          const context = t.ruleContext;
          const altNumber = context.getAltNumber();
          if (altNumber !== 0) {
            return ruleNames[t.ruleIndex] + ":" + altNumber;
          }
          return ruleNames[t.ruleIndex];
        } else if (t instanceof ErrorNode) {
          return t.toString();
        } else if (t instanceof TerminalNode) {
          return t.symbol.text;
        }
      }
      const payload = t.getPayload();
      if (isToken(payload)) {
        return payload.text;
      }
      return String(t.getPayload());
    }
    /**
     * Return ordered list of all children of this node
     */
    static getChildren(t) {
      const list = [];
      for (let i = 0; i < t.getChildCount(); i++) {
        list.push(t.getChild(i));
      }
      return list;
    }
    /**
     * Return a list of all ancestors of this node.  The first node of
     * list is the root and the last is the parent of this node.
     */
    static getAncestors(t) {
      if (t.parent === null) {
        return [];
      }
      let ancestors = [];
      let p = t.parent;
      while (p !== null) {
        ancestors = [p].concat(ancestors);
        p = p.parent;
      }
      return ancestors;
    }
    /**
     * Return true if t is u's parent or a node on path to root from u.
     */
    static isAncestorOf(t, u) {
      if (t === null || u === null || t.parent === null) {
        return false;
      }
      let p = u.parent;
      while (p !== null) {
        if (t === p) {
          return true;
        }
        p = p.parent;
      }
      return false;
    }
    static findAllTokenNodes(t, ttype) {
      return _Trees.findAllNodes(t, ttype, true);
    }
    static findAllRuleNodes(t, ruleIndex) {
      return _Trees.findAllNodes(t, ruleIndex, false);
    }
    static findAllNodes(t, index, findTokens) {
      const nodes = [];
      _Trees.doFindAllNodes(t, index, findTokens, nodes);
      return nodes;
    }
    static descendants(t) {
      let nodes = [t];
      for (let i = 0; i < t.getChildCount(); i++) {
        nodes = nodes.concat(_Trees.descendants(t.getChild(i)));
      }
      return nodes;
    }
    /**
     * Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
     * inclusively using post order traversal. Recursive depth-first-search.
     */
    static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
      const n2 = t.getChildCount();
      for (let i = 0; i < n2; i++) {
        const child = t.getChild(i);
        const r = this.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
        if (r !== null) {
          return r;
        }
      }
      if (t instanceof ParserRuleContext) {
        if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
        (t.stop === null || stopTokenIndex <= t.stop.tokenIndex)) {
          return t;
        }
      }
      return null;
    }
    /**
     * Replace any subtree siblings of root that are completely to left
     * or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
     * node. The source interval for t is not altered to suit smaller range!
     *
     * WARNING: destructive to t.
     */
    static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
      if (t === null) {
        return;
      }
      for (let i = 0; i < t.getChildCount(); i++) {
        const child = t.getChild(i);
        const range = child.getSourceInterval();
        if (t instanceof ParserRuleContext && (range.stop < startIndex || range.start > stopIndex)) {
          if (this.isAncestorOf(child, root)) {
            const abbrev = CommonToken.fromType(Token.INVALID_TYPE, "...");
            t.children[i] = new TerminalNode(abbrev);
          }
        }
      }
    }
    static doFindAllNodes(t, index, findTokens, nodes) {
      if (findTokens && t instanceof TerminalNode) {
        if (t.symbol?.type === index) {
          nodes.push(t);
        }
      } else if (!findTokens && t instanceof ParserRuleContext) {
        if (t.ruleIndex === index) {
          nodes.push(t);
        }
      }
      for (let i = 0; i < t.getChildCount(); i++) {
        _Trees.doFindAllNodes(t.getChild(i), index, findTokens, nodes);
      }
    }
  };
  var ParserRuleContext = class _ParserRuleContext {
    static {
      __name(this, "ParserRuleContext");
    }
    static empty = new _ParserRuleContext(null);
    start = null;
    stop = null;
    children = [];
    /**
     * What state invoked the rule associated with this context?
     *  The "return address" is the followState of invokingState
     *  If parent is null, this should be -1 this context object represents
     *  the start rule.
     */
    invokingState;
    parent;
    /**
     * A rule context is a record of a single rule invocation. It knows
     * which context invoked it, if any. If there is no parent context, then
     * naturally the invoking state is not valid.  The parent link
     * provides a chain upwards from the current rule invocation to the root
     * of the invocation tree, forming a stack. We actually carry no
     * information about the rule associated with this context (except
     * when parsing). We keep only the state number of the invoking state from
     * the ATN submachine that invoked this. Contrast this with the s
     * pointer inside ParserRuleContext that tracks the current state
     * being "executed" for the current rule.
     *
     * The parent contexts are useful for computing lookahead sets and
     * getting error information.
     *
     * These objects are used during parsing and prediction.
     * For the special case of parsers, we use the subclass
     * ParserRuleContext.
     */
    constructor(parent, invokingStateNumber = -1) {
      this.parent = parent;
      this.invokingState = invokingStateNumber;
    }
    /** Copy a context */
    copyFrom(ctx) {
      this.parent = ctx.parent;
      this.invokingState = ctx.invokingState;
      this.children.slice(0, this.children.length);
      this.start = ctx.start;
      this.stop = ctx.stop;
      if (ctx.children) {
        ctx.children.forEach((child) => {
          if (child instanceof ErrorNode) {
            this.children.push(child);
            child.parent = this;
          }
        });
      }
    }
    // Double dispatch methods for listeners
    enterRule(_listener) {
    }
    exitRule(_listener) {
    }
    addChild(child) {
      this.children.push(child);
      return child;
    }
    /**
     * Used by enterOuterAlt to toss out a RuleContext previously added as
     * we entered a rule. If we have label, we will need to remove
     * generic ruleContext object.
     */
    removeLastChild() {
      this.children.pop();
    }
    addTokenNode(token) {
      const node = new TerminalNode(token);
      this.children.push(node);
      node.parent = this;
      return node;
    }
    addErrorNode(errorNode) {
      errorNode.parent = this;
      this.children.push(errorNode);
      return errorNode;
    }
    getChild(i, type) {
      if (i < 0 || i >= this.children.length) {
        return null;
      }
      if (!type) {
        return this.children[i];
      }
      for (const child of this.children) {
        if (child instanceof type) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }
      return null;
    }
    getToken(ttype, i) {
      if (i < 0 || i >= this.children.length) {
        return null;
      }
      for (const child of this.children) {
        if ("symbol" in child) {
          if (child.symbol?.type === ttype) {
            if (i === 0) {
              return child;
            } else {
              i -= 1;
            }
          }
        }
      }
      return null;
    }
    getTokens(ttype) {
      const tokens = [];
      for (const child of this.children) {
        if ("symbol" in child) {
          if (child.symbol?.type === ttype) {
            tokens.push(child);
          }
        }
      }
      return tokens;
    }
    // XXX: base the child type selection on the rule index, not the class.
    getRuleContext(index, ctxType) {
      return this.getChild(index, ctxType);
    }
    // XXX: base the child type selection on the rule index, not the class.
    getRuleContexts(ctxType) {
      const contexts = [];
      for (const child of this.children) {
        if (child instanceof ctxType) {
          contexts.push(child);
        }
      }
      return contexts;
    }
    getChildCount() {
      return this.children.length;
    }
    getSourceInterval() {
      if (this.start === null || this.stop === null) {
        return Interval.INVALID_INTERVAL;
      } else {
        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
      }
    }
    depth() {
      let n2 = 0;
      let p = this;
      while (p !== null) {
        p = p.parent;
        n2 += 1;
      }
      return n2;
    }
    /**
     * A context is empty if there is no invoking state; meaning nobody call
     * current context.
     */
    isEmpty() {
      return this.invokingState === -1;
    }
    get ruleContext() {
      return this;
    }
    get ruleIndex() {
      return -1;
    }
    getPayload() {
      return this;
    }
    getText() {
      if (this.children.length === 0) {
        return "";
      }
      return this.children.map((child) => {
        return child.getText();
      }).join("");
    }
    /**
     * For rule associated with this parse tree internal node, return
     * the outer alternative number used to match the input. Default
     * implementation does not compute nor store this alt num. Create
     * a subclass of ParserRuleContext with backing field and set
     * option contextSuperClass.
     * to set it.
     */
    getAltNumber() {
      return ATN.INVALID_ALT_NUMBER;
    }
    /**
     * Set the outer alternative number for this context node. Default
     * implementation does nothing to avoid backing field overhead for
     * trees that don't need it.  Create
     * a subclass of ParserRuleContext with backing field and set
     * option contextSuperClass.
     */
    setAltNumber(_altNumber) {
    }
    accept(visitor) {
      return visitor.visitChildren(this);
    }
    toStringTree(...args) {
      if (args.length < 2) {
        return Trees.toStringTree(this, null, args[0]);
      }
      return Trees.toStringTree(this, args[0], args[1]);
    }
    toString(ruleNames, stop) {
      ruleNames = ruleNames ?? null;
      stop = stop ?? null;
      let p = this;
      let s = "[";
      while (p !== null && p !== stop) {
        if (ruleNames === null) {
          if (!p.isEmpty()) {
            s += p.invokingState;
          }
        } else {
          const ri = p.ruleIndex;
          const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
          s += ruleName;
        }
        if (p.parent !== null && (ruleNames !== null || !p.parent.isEmpty())) {
          s += " ";
        }
        p = p.parent;
      }
      s += "]";
      return s;
    }
  };
  var ObjectEqualityComparator = class _ObjectEqualityComparator {
    static {
      __name(this, "ObjectEqualityComparator");
    }
    static instance = new _ObjectEqualityComparator();
    hashCode(obj) {
      if (obj == null) {
        return 0;
      }
      return obj.hashCode();
    }
    equals(a, b) {
      if (a == null) {
        return b == null;
      }
      return a.equals(b);
    }
  };
  var DefaultEqualityComparator = class _DefaultEqualityComparator {
    static {
      __name(this, "DefaultEqualityComparator");
    }
    static instance = new _DefaultEqualityComparator();
    hashCode(obj) {
      if (obj == null) {
        return 0;
      }
      return ObjectEqualityComparator.instance.hashCode(obj);
    }
    equals(a, b) {
      if (a == null) {
        return b == null;
      }
      if (typeof a === "string" || typeof a === "number") {
        return a === b;
      }
      return ObjectEqualityComparator.instance.equals(a, b);
    }
  };
  var HashSet = class _HashSet {
    static {
      __name(this, "HashSet");
    }
    static defaultLoadFactor = 0.75;
    static initialCapacity = 16;
    // must be power of 2
    comparator;
    buckets;
    threshold;
    /** How many elements in set */
    itemCount = 0;
    constructor(comparatorOrSet, initialCapacity = _HashSet.initialCapacity) {
      if (comparatorOrSet instanceof _HashSet) {
        this.comparator = comparatorOrSet.comparator;
        this.buckets = comparatorOrSet.buckets.slice(0);
        for (let i = 0; i < this.buckets.length; i++) {
          const bucket = this.buckets[i];
          if (bucket) {
            this.buckets[i] = bucket.slice(0);
          }
        }
        this.itemCount = comparatorOrSet.itemCount;
        this.threshold = comparatorOrSet.threshold;
      } else {
        this.comparator = comparatorOrSet ?? DefaultEqualityComparator.instance;
        this.buckets = this.createBuckets(initialCapacity);
        this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);
      }
    }
    /**
     * Add `o` to set if not there; return existing value if already
     * there. This method performs the same operation as {@link #add} aside from
     * the return value.
     *
     * @param o the object to add to the set.
     *
     * @returns An existing element that equals to `o` if already in set, otherwise `o`.
     */
    getOrAdd(o) {
      if (this.itemCount > this.threshold) {
        this.expand();
      }
      const b = this.getBucket(o);
      let bucket = this.buckets[b];
      if (!bucket) {
        bucket = [o];
        this.buckets[b] = bucket;
        ++this.itemCount;
        return o;
      }
      for (const existing of bucket) {
        if (this.comparator.equals(existing, o)) {
          return existing;
        }
      }
      bucket.push(o);
      ++this.itemCount;
      return o;
    }
    get(o) {
      if (o == null) {
        return o;
      }
      const b = this.getBucket(o);
      const bucket = this.buckets[b];
      if (!bucket) {
        return void 0;
      }
      for (const e of bucket) {
        if (this.comparator.equals(e, o)) {
          return e;
        }
      }
      return void 0;
    }
    /**
     * Removes the specified element from this set if it is present.
     *
     * @param o object to be removed from this set, if present.
     *
     * @returns `true` if the set contained the specified element.
     */
    remove(o) {
      if (o == null) {
        return false;
      }
      const b = this.getBucket(o);
      const bucket = this.buckets[b];
      if (!bucket) {
        return false;
      }
      for (let i = 0; i < bucket.length; i++) {
        const existing = bucket[i];
        if (this.comparator.equals(existing, o)) {
          bucket.splice(i, 1);
          --this.itemCount;
          return true;
        }
      }
      return false;
    }
    hashCode() {
      let hash = MurmurHash.initialize();
      for (const bucket of this.buckets) {
        if (bucket == null) {
          continue;
        }
        for (const o of bucket) {
          if (o == null) {
            break;
          }
          hash = MurmurHash.update(hash, this.comparator.hashCode(o));
        }
      }
      hash = MurmurHash.finish(hash, this.size);
      return hash;
    }
    equals(o) {
      if (o === this) {
        return true;
      }
      if (!(o instanceof _HashSet)) {
        return false;
      }
      if (o.size !== this.size) {
        return false;
      }
      return this.containsAll(o);
    }
    add(t) {
      const existing = this.getOrAdd(t);
      return existing === t;
    }
    contains(o) {
      return this.containsFast(o);
    }
    containsFast(obj) {
      if (obj == null) {
        return false;
      }
      return this.get(obj) !== void 0;
    }
    *[Symbol.iterator]() {
      yield* this.toArray();
    }
    toArray() {
      const a = new Array(this.size);
      let i = 0;
      for (const bucket of this.buckets) {
        if (bucket == null) {
          continue;
        }
        for (const o of bucket) {
          if (o == null) {
            break;
          }
          a[i++] = o;
        }
      }
      return a;
    }
    containsAll(collection) {
      if (collection instanceof _HashSet) {
        for (const bucket of collection.buckets) {
          if (bucket == null) {
            continue;
          }
          for (const o of bucket) {
            if (o == null) {
              break;
            }
            if (!this.containsFast(o)) {
              return false;
            }
          }
        }
      } else {
        for (const o of collection) {
          if (!this.containsFast(o)) {
            return false;
          }
        }
      }
      return true;
    }
    addAll(c) {
      let changed = false;
      for (const o of c) {
        const existing = this.getOrAdd(o);
        if (existing !== o) {
          changed = true;
        }
      }
      return changed;
    }
    clear() {
      this.buckets = this.createBuckets(_HashSet.initialCapacity);
      this.itemCount = 0;
      this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);
    }
    toString() {
      if (this.size === 0) {
        return "{}";
      }
      let buf = "{";
      let first = true;
      for (const bucket of this.buckets) {
        if (bucket == null) {
          continue;
        }
        for (const o of bucket) {
          if (o == null) {
            break;
          }
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          buf += o.toString();
        }
      }
      buf += "}";
      return buf;
    }
    toTableString() {
      let buf = "";
      for (const bucket of this.buckets) {
        if (bucket == null) {
          buf += "null\n";
          continue;
        }
        buf += "[";
        let first = true;
        for (const o of bucket) {
          if (first) {
            first = false;
          } else {
            buf += " ";
          }
          if (o == null) {
            buf += "_";
          } else {
            buf += o.toString();
          }
        }
        buf += "]\n";
      }
      return buf;
    }
    getBucket(o) {
      const hash = this.comparator.hashCode(o);
      const b = hash & this.buckets.length - 1;
      return b;
    }
    expand() {
      const old = this.buckets;
      const newCapacity = this.buckets.length * 2;
      const newTable = this.createBuckets(newCapacity);
      this.buckets = newTable;
      this.threshold = Math.floor(newCapacity * _HashSet.defaultLoadFactor);
      for (const bucket of old) {
        if (!bucket) {
          continue;
        }
        for (const o of bucket) {
          const b = this.getBucket(o);
          let newBucket = this.buckets[b];
          if (!newBucket) {
            newBucket = [];
            this.buckets[b] = newBucket;
          }
          newBucket.push(o);
        }
      }
    }
    get size() {
      return this.itemCount;
    }
    get isEmpty() {
      return this.itemCount === 0;
    }
    /**
     * Return an array of `T[]` with length `capacity`.
     *
     * @param capacity the length of the array to return
     * @returns the newly constructed array
     */
    createBuckets(capacity) {
      return new Array(capacity);
    }
  };
  var MapKeyEqualityComparator = class {
    static {
      __name(this, "MapKeyEqualityComparator");
    }
    keyComparator;
    constructor(keyComparator) {
      this.keyComparator = keyComparator;
    }
    hashCode(obj) {
      return this.keyComparator.hashCode(obj.key);
    }
    equals(a, b) {
      return this.keyComparator.equals(a.key, b.key);
    }
  };
  var HashMap = class _HashMap {
    static {
      __name(this, "HashMap");
    }
    backingStore;
    constructor(keyComparer) {
      if (keyComparer instanceof _HashMap) {
        this.backingStore = new HashSet(keyComparer.backingStore);
      } else {
        keyComparer = keyComparer ?? DefaultEqualityComparator.instance;
        this.backingStore = new HashSet(new MapKeyEqualityComparator(keyComparer));
      }
    }
    clear() {
      this.backingStore.clear();
    }
    containsKey(key) {
      return this.backingStore.contains({ key });
    }
    get(key) {
      const bucket = this.backingStore.get({ key });
      if (!bucket) {
        return void 0;
      }
      return bucket.value;
    }
    get isEmpty() {
      return this.backingStore.isEmpty;
    }
    /**
     * Sets the value for a key in the map. If the key is not present in the map, it is added.
     * If the key is present, the value is updated and the old value is returned.
     *
     * @param key The key to set.
     * @param value The value to set.
     *
     * @returns The old value for the key, if present.
     */
    set(key, value) {
      const element = this.backingStore.get({ key, value });
      let result;
      if (!element) {
        this.backingStore.add({ key, value });
      } else {
        result = element.value;
        element.value = value;
      }
      return result;
    }
    /**
     * Sets the value for a key in the map if the key is not already present. Otherwise the value is not changed and
     * the old value is returned.
     *
     * @param key The key to set.
     * @param value The value to set.
     *
     * @returns The current value for the key, if present.
     */
    setIfAbsent(key, value) {
      const element = this.backingStore.get({ key, value });
      let result;
      if (!element) {
        this.backingStore.add({ key, value });
      } else {
        result = element.value;
      }
      return result;
    }
    values() {
      return this.backingStore.toArray().map((bucket) => {
        return bucket.value;
      });
    }
    get size() {
      return this.backingStore.size;
    }
    hashCode() {
      return this.backingStore.hashCode();
    }
    equals(o) {
      return this.backingStore.equals(o.backingStore);
    }
  };
  var predictionContextFromRuleContext = /* @__PURE__ */ __name((atn, outerContext) => {
    if (!outerContext) {
      outerContext = ParserRuleContext.empty;
    }
    if (!outerContext.parent || outerContext === ParserRuleContext.empty) {
      return PredictionContext.EMPTY;
    }
    const parent = predictionContextFromRuleContext(atn, outerContext.parent);
    const state = atn.states[outerContext.invokingState];
    const transition = state.transitions[0];
    return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
  }, "predictionContextFromRuleContext");
  var getCachedPredictionContext = /* @__PURE__ */ __name((context, contextCache, visited) => {
    if (context.isEmpty()) {
      return context;
    }
    let existing = visited.get(context);
    if (existing) {
      return existing;
    }
    existing = contextCache.get(context);
    if (existing) {
      visited.set(context, existing);
      return existing;
    }
    let changed = false;
    let parents = [];
    for (let i = 0; i < parents.length; i++) {
      const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
      if (changed || parent !== context.getParent(i)) {
        if (!changed) {
          parents = [];
          for (let j = 0; j < context.length; j++) {
            parents[j] = context.getParent(j);
          }
          changed = true;
        }
        parents[i] = parent;
      }
    }
    if (!changed) {
      contextCache.add(context);
      visited.set(context, context);
      return context;
    }
    let updated;
    if (parents.length === 0) {
      updated = PredictionContext.EMPTY;
    } else if (parents.length === 1) {
      updated = SingletonPredictionContext.create(parents[0] ?? void 0, context.getReturnState(0));
    } else {
      updated = new ArrayPredictionContext(parents, context.returnStates);
    }
    contextCache.add(updated);
    visited.set(updated, updated);
    visited.set(context, updated);
    return updated;
  }, "getCachedPredictionContext");
  var merge = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
    if (a === b) {
      return a;
    }
    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
      return mergeSingletons(a, b, rootIsWildcard, mergeCache);
    }
    if (rootIsWildcard) {
      if (a instanceof EmptyPredictionContext) {
        return a;
      }
      if (b instanceof EmptyPredictionContext) {
        return b;
      }
    }
    if (a instanceof SingletonPredictionContext) {
      a = new ArrayPredictionContext([a.parent], [a.returnState]);
    }
    if (b instanceof SingletonPredictionContext) {
      b = new ArrayPredictionContext([b.parent], [b.returnState]);
    }
    return mergeArrays(a, b, rootIsWildcard, mergeCache);
  }, "merge");
  var mergeArrays = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
    if (mergeCache) {
      let previous = mergeCache.get(a, b);
      if (previous) {
        return previous;
      }
      previous = mergeCache.get(b, a);
      if (previous) {
        return previous;
      }
    }
    let i = 0;
    let j = 0;
    let k = 0;
    let mergedReturnStates = new Array(a.returnStates.length + b.returnStates.length).fill(0);
    let mergedParents = new Array(a.returnStates.length + b.returnStates.length).fill(null);
    while (i < a.returnStates.length && j < b.returnStates.length) {
      const aParent = a.parents[i];
      const bParent = b.parents[j];
      if (a.returnStates[i] === b.returnStates[j]) {
        const payload = a.returnStates[i];
        const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && aParent === null && bParent === null;
        const axAx = aParent !== null && bParent !== null && aParent === bParent;
        if (bothDollars || axAx) {
          mergedParents[k] = aParent;
          mergedReturnStates[k] = payload;
        } else {
          mergedParents[k] = merge(aParent, bParent, rootIsWildcard, mergeCache);
          mergedReturnStates[k] = payload;
        }
        i += 1;
        j += 1;
      } else if (a.returnStates[i] < b.returnStates[j]) {
        mergedParents[k] = aParent;
        mergedReturnStates[k] = a.returnStates[i];
        i += 1;
      } else {
        mergedParents[k] = bParent;
        mergedReturnStates[k] = b.returnStates[j];
        j += 1;
      }
      k += 1;
    }
    if (i < a.returnStates.length) {
      for (let p = i; p < a.returnStates.length; p++) {
        mergedParents[k] = a.parents[p];
        mergedReturnStates[k] = a.returnStates[p];
        k += 1;
      }
    } else {
      for (let p = j; p < b.returnStates.length; p++) {
        mergedParents[k] = b.parents[p];
        mergedReturnStates[k] = b.returnStates[p];
        k += 1;
      }
    }
    if (k < mergedParents.length) {
      if (k === 1) {
        const aNew = SingletonPredictionContext.create(mergedParents[0] ?? void 0, mergedReturnStates[0]);
        if (mergeCache !== null) {
          mergeCache.set(a, b, aNew);
        }
        return aNew;
      }
      mergedParents = mergedParents.slice(0, k);
      mergedReturnStates = mergedReturnStates.slice(0, k);
    }
    const merged = new ArrayPredictionContext(mergedParents, mergedReturnStates);
    if (merged.equals(a)) {
      if (mergeCache !== null) {
        mergeCache.set(a, b, a);
      }
      if (PredictionContext.traceATNSimulator) {
        console.log("mergeArrays a=" + a + ",b=" + b + " -> a");
      }
      return a;
    }
    if (merged.equals(b)) {
      if (mergeCache !== null) {
        mergeCache.set(a, b, b);
      }
      return b;
    }
    combineCommonParents(mergedParents);
    if (mergeCache !== null) {
      mergeCache.set(a, b, merged);
    }
    if (PredictionContext.traceATNSimulator) {
      console.log("mergeArrays a=" + a + ",b=" + b + " -> " + merged);
    }
    return merged;
  }, "mergeArrays");
  var combineCommonParents = /* @__PURE__ */ __name((parents) => {
    const uniqueParents = new HashMap(ObjectEqualityComparator.instance);
    for (const parent of parents) {
      if (parent) {
        if (!uniqueParents.containsKey(parent)) {
          uniqueParents.set(parent, parent);
        }
      }
    }
    for (let q = 0; q < parents.length; q++) {
      if (parents[q]) {
        parents[q] = uniqueParents.get(parents[q]) ?? null;
      }
    }
  }, "combineCommonParents");
  var mergeSingletons = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
    if (mergeCache !== null) {
      let previous = mergeCache.get(a, b);
      if (previous !== null) {
        return previous;
      }
      previous = mergeCache.get(b, a);
      if (previous !== null) {
        return previous;
      }
    }
    const rootMerge = mergeRoot(a, b, rootIsWildcard);
    if (rootMerge !== null) {
      if (mergeCache !== null) {
        mergeCache.set(a, b, rootMerge);
      }
      return rootMerge;
    }
    if (a.returnState === b.returnState) {
      const parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
      if (parent === a.parent) {
        return a;
      }
      if (parent === b.parent) {
        return b;
      }
      const spc = SingletonPredictionContext.create(parent, a.returnState);
      if (mergeCache !== null) {
        mergeCache.set(a, b, spc);
      }
      return spc;
    } else {
      let singleParent = null;
      if (a === b || a.parent !== null && a.parent === b.parent) {
        singleParent = a.parent;
      }
      if (singleParent !== null) {
        const payloads2 = [a.returnState, b.returnState];
        if (a.returnState > b.returnState) {
          payloads2[0] = b.returnState;
          payloads2[1] = a.returnState;
        }
        const parents2 = [singleParent, singleParent];
        const apc = new ArrayPredictionContext(parents2, payloads2);
        if (mergeCache !== null) {
          mergeCache.set(a, b, apc);
        }
        return apc;
      }
      const payloads = [a.returnState, b.returnState];
      let parents = [a.parent, b.parent];
      if (a.returnState > b.returnState) {
        payloads[0] = b.returnState;
        payloads[1] = a.returnState;
        parents = [b.parent, a.parent];
      }
      const aNew = new ArrayPredictionContext(parents, payloads);
      if (mergeCache !== null) {
        mergeCache.set(a, b, aNew);
      }
      return aNew;
    }
  }, "mergeSingletons");
  var mergeRoot = /* @__PURE__ */ __name((a, b, rootIsWildcard) => {
    if (rootIsWildcard) {
      if (a === PredictionContext.EMPTY || b === PredictionContext.EMPTY) {
        return PredictionContext.EMPTY;
      }
    } else {
      if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
        return PredictionContext.EMPTY;
      }
      if (a === PredictionContext.EMPTY) {
        const payloads = [
          b.returnState,
          PredictionContext.EMPTY_RETURN_STATE
        ];
        const parents = [b.parent, null];
        return new ArrayPredictionContext(parents, payloads);
      }
      if (b === PredictionContext.EMPTY) {
        const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];
        const parents = [a.parent, null];
        return new ArrayPredictionContext(parents, payloads);
      }
    }
    return null;
  }, "mergeRoot");
  var BitSet = class {
    static {
      __name(this, "BitSet");
    }
    data;
    /**
     * Creates a new bit set. All bits are initially `false`.
     *
     * @param data Optional initial data.
     */
    constructor(data) {
      if (data) {
        this.data = new Uint32Array(data.map((value) => {
          return value >>> 0;
        }));
      } else {
        this.data = new Uint32Array(1);
      }
    }
    /**
     * @returns an iterator over all set bits.
     */
    [Symbol.iterator]() {
      const length = this.data.length;
      let currentIndex = 0;
      let currentWord = this.data[currentIndex];
      const words = this.data;
      return {
        [Symbol.iterator]() {
          return this;
        },
        next: /* @__PURE__ */ __name(() => {
          while (currentIndex < length) {
            if (currentWord !== 0) {
              const t = currentWord & -currentWord;
              const value = (currentIndex << 5) + this.bitCount(t - 1);
              currentWord ^= t;
              return { done: false, value };
            } else {
              currentIndex++;
              if (currentIndex < length) {
                currentWord = words[currentIndex];
              }
            }
          }
          return { done: true, value: void 0 };
        }, "next")
      };
    }
    /**
     * Sets a single bit or all of the bits in this `BitSet` to `false`.
     *
     * @param index the index of the bit to be cleared, or undefined to clear all bits.
     */
    clear(index) {
      if (index === void 0) {
        this.data = new Uint32Array();
      } else {
        this.resize(index);
        this.data[index >>> 5] &= ~(1 << index);
      }
    }
    /**
     * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
     * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
     * set argument has the value `true`.
     *
     * @param set the bit set to be ORed with.
     */
    or(set) {
      const minCount = Math.min(this.data.length, set.data.length);
      for (let k = 0; k < minCount; ++k) {
        this.data[k] |= set.data[k];
      }
      if (this.data.length < set.data.length) {
        this.resize((set.data.length << 5) - 1);
        const c = set.data.length;
        for (let k = minCount; k < c; ++k) {
          this.data[k] = set.data[k];
        }
      }
    }
    /**
     * Returns the value of the bit with the specified index. The value is `true` if the bit with the index `bitIndex`
     * is currently set in this `BitSet`; otherwise, the result is `false`.
     *
     * @param index the bit index
     *
     * @returns the value of the bit with the specified index.
     */
    get(index) {
      if (index < 0) {
        throw new RangeError("index cannot be negative");
      }
      const slot = index >>> 5;
      if (slot >= this.data.length) {
        return false;
      }
      return (this.data[slot] & 1 << index % 32) !== 0;
    }
    /**
     * @returns the number of set bits.
     */
    get length() {
      let result = 0;
      const c = this.data.length;
      const w = this.data;
      for (let i = 0; i < c; i++) {
        result += this.bitCount(w[i]);
      }
      return result;
    }
    /**
     * @returns an array with indices of set bits.
     */
    values() {
      const result = new Array(this.length);
      let pos = 0;
      const length = this.data.length;
      for (let k = 0; k < length; ++k) {
        let w = this.data[k];
        while (w !== 0) {
          const t = w & -w;
          result[pos++] = (k << 5) + this.bitCount(t - 1);
          w ^= t;
        }
      }
      return result;
    }
    /**
     * @returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
     * If no such bit exists then undefined is returned.
     *
     * @param fromIndex the index to start checking from (inclusive)
     */
    nextSetBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("index cannot be negative");
      }
      for (const index of this) {
        if (index >= fromIndex) {
          return index;
        }
      }
      return void 0;
    }
    /**
     * Sets the bit at the specified index to `true`.
     *
     * @param index a bit index
     */
    set(index) {
      if (index < 0) {
        throw new RangeError("index cannot be negative");
      }
      this.resize(index);
      this.data[index >>> 5] |= 1 << index % 32;
    }
    /**
     * @returns a string representation of this bit set.
     */
    toString() {
      return "{" + this.values().join(", ") + "}";
    }
    resize(index) {
      const count = index + 32 >>> 5;
      if (count <= this.data.length) {
        return;
      }
      const data = new Uint32Array(count);
      data.set(this.data);
      data.fill(0, this.data.length);
      this.data = data;
    }
    bitCount(v) {
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      v = v + (v >> 4) & 252645135;
      v = v + (v >> 8);
      v = v + (v >> 16);
      return v & 63;
    }
  };
  var ATNState = class _ATNState {
    static {
      __name(this, "ATNState");
    }
    static INVALID_STATE_NUMBER = -1;
    static INVALID_TYPE = 0;
    static BASIC = 1;
    static RULE_START = 2;
    static BLOCK_START = 3;
    static PLUS_BLOCK_START = 4;
    static STAR_BLOCK_START = 5;
    static TOKEN_START = 6;
    static RULE_STOP = 7;
    static BLOCK_END = 8;
    static STAR_LOOP_BACK = 9;
    static STAR_LOOP_ENTRY = 10;
    static PLUS_LOOP_BACK = 11;
    static LOOP_END = 12;
    static stateType = _ATNState.INVALID_STATE_NUMBER;
    stateNumber = 0;
    ruleIndex = 0;
    // at runtime, we don't have Rule objects
    epsilonOnlyTransitions = false;
    /** Used to cache lookahead during parsing, not used during construction */
    nextTokenWithinRule;
    /** Track the transitions emanating from this ATN state. */
    transitions = [];
    hashCode() {
      return this.stateNumber;
    }
    equals(other) {
      return this.stateNumber === other.stateNumber;
    }
    toString() {
      return `${this.stateNumber}`;
    }
    addTransitionAtIndex(index, transition) {
      if (this.transitions.length === 0) {
        this.epsilonOnlyTransitions = transition.isEpsilon;
      } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {
        this.epsilonOnlyTransitions = false;
      }
      this.transitions.splice(index, 1, transition);
    }
    addTransition(transition) {
      if (this.transitions.length === 0) {
        this.epsilonOnlyTransitions = transition.isEpsilon;
      } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {
        this.epsilonOnlyTransitions = false;
      }
      this.transitions.push(transition);
    }
    setTransition(i, e) {
      this.transitions.splice(i, 1, e);
    }
    removeTransition(index) {
      const t = this.transitions.splice(index, 1);
      return t[0];
    }
  };
  var SemanticContext = class _SemanticContext {
    static {
      __name(this, "SemanticContext");
    }
    cachedHashCode;
    static andContext(a, b) {
      if (a === null || a === _SemanticContext.NONE) {
        return b;
      }
      if (b === null || b === _SemanticContext.NONE) {
        return a;
      }
      const result = new AND(a, b);
      if (result.operands.length === 1) {
        return result.operands[0];
      }
      return result;
    }
    static orContext(a, b) {
      if (a === null) {
        return b;
      }
      if (b === null) {
        return a;
      }
      if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) {
        return _SemanticContext.NONE;
      }
      const result = new OR(a, b);
      if (result.operands.length === 1) {
        return result.operands[0];
      } else {
        return result;
      }
    }
    static filterPrecedencePredicates(set) {
      const result = [];
      for (const context of set) {
        if (context instanceof _SemanticContext.PrecedencePredicate) {
          result.push(context);
        }
      }
      return result;
    }
    /**
     * Evaluate the precedence predicates for the context and reduce the result.
     *
     * @param _parser The parser instance.
     * @param _parserCallStack The current parser context object.
     * @returns The simplified semantic context after precedence predicates are
     * evaluated, which will be one of the following values.
     * - {@link NONE}: if the predicate simplifies to `true` after
     * precedence predicates are evaluated.
     * - `null`: if the predicate simplifies to `false` after
     * precedence predicates are evaluated.
     * - `this`: if the semantic context is not changed as a result of
     * precedence predicate evaluation.
     * - A non-`null` {@link SemanticContext}: the new simplified
     * semantic context after precedence predicates are evaluated.
     */
    evalPrecedence(_parser, _parserCallStack) {
      return this;
    }
  };
  var AND = class _AND extends SemanticContext {
    static {
      __name(this, "AND");
    }
    operands;
    /**
     * A semantic context which is true whenever none of the contained contexts
     * is false
     */
    constructor(a, b) {
      super();
      const operands = new HashSet();
      if (a instanceof _AND) {
        a.operands.forEach((o) => {
          operands.add(o);
        });
      } else {
        operands.add(a);
      }
      if (b instanceof _AND) {
        b.operands.forEach((o) => {
          operands.add(o);
        });
      } else {
        operands.add(b);
      }
      const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);
      if (precedencePredicates.length > 0) {
        let reduced = null;
        precedencePredicates.forEach((p) => {
          if (reduced === null || p.precedence < reduced.precedence) {
            reduced = p;
          }
        });
        if (reduced) {
          operands.add(reduced);
        }
      }
      this.operands = operands.toArray();
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _AND)) {
        return false;
      }
      return equalArrays(this.operands, other.operands);
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        for (const operand of this.operands) {
          hash = MurmurHash.updateFromComparable(hash, operand);
        }
        hash = MurmurHash.update(hash, 3813686060);
        this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);
      }
      return this.cachedHashCode;
    }
    /**
     * {@inheritDoc}
     *
     *
     * The evaluation of predicates by this context is short-circuiting, but
     * unordered.
     */
    evaluate(parser, parserCallStack) {
      for (const operand of this.operands) {
        if (!operand.evaluate(parser, parserCallStack)) {
          return false;
        }
      }
      return true;
    }
    evalPrecedence(parser, parserCallStack) {
      let differs = false;
      const operands = [];
      for (const context of this.operands) {
        const evaluated = context.evalPrecedence(parser, parserCallStack);
        differs ||= evaluated !== context;
        if (evaluated === null) {
          return null;
        } else if (evaluated !== SemanticContext.NONE) {
          operands.push(evaluated);
        }
      }
      if (!differs) {
        return this;
      }
      if (operands.length === 0) {
        return SemanticContext.NONE;
      }
      let result = null;
      operands.forEach((o) => {
        result = result === null ? o : SemanticContext.andContext(result, o);
      });
      return result;
    }
    toString() {
      const s = this.operands.map((o) => {
        return o.toString();
      });
      return (s.length > 3 ? s.slice(3) : s).join("&&");
    }
  };
  var OR = class _OR extends SemanticContext {
    static {
      __name(this, "OR");
    }
    operands;
    /**
     * A semantic context which is true whenever at least one of the contained
     * contexts is true
     */
    constructor(a, b) {
      super();
      const operands = new HashSet();
      if (a instanceof _OR) {
        a.operands.forEach((o) => {
          operands.add(o);
        });
      } else {
        operands.add(a);
      }
      if (b instanceof _OR) {
        b.operands.forEach((o) => {
          operands.add(o);
        });
      } else {
        operands.add(b);
      }
      const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);
      if (precedencePredicates.length > 0) {
        const s = precedencePredicates.sort((a2, b2) => {
          return a2.compareTo(b2);
        });
        const reduced = s[s.length - 1];
        operands.add(reduced);
      }
      this.operands = operands.toArray();
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof _OR)) {
        return false;
      } else {
        return equalArrays(this.operands, other.operands);
      }
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        for (const operand of this.operands) {
          hash = MurmurHash.updateFromComparable(hash, operand);
        }
        hash = MurmurHash.update(hash, 3383313031);
        this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);
      }
      return this.cachedHashCode;
    }
    /**
     * The evaluation of predicates by this context is short-circuiting, but unordered.
     */
    evaluate(parser, parserCallStack) {
      for (const operand of this.operands) {
        if (operand.evaluate(parser, parserCallStack)) {
          return true;
        }
      }
      return false;
    }
    evalPrecedence(parser, parserCallStack) {
      let differs = false;
      const operands = [];
      for (const context of this.operands) {
        const evaluated = context.evalPrecedence(parser, parserCallStack);
        differs ||= evaluated !== context;
        if (evaluated === SemanticContext.NONE) {
          return SemanticContext.NONE;
        } else if (evaluated !== null) {
          operands.push(evaluated);
        }
      }
      if (!differs) {
        return this;
      }
      if (operands.length === 0) {
        return null;
      }
      let result = null;
      operands.forEach((o) => {
        result = result === null ? o : SemanticContext.orContext(result, o);
      });
      return result;
    }
    toString() {
      const s = this.operands.map((o) => {
        return o.toString();
      });
      return (s.length > 3 ? s.slice(3) : s).join("||");
    }
  };
  ((SemanticContext2) => {
    class Predicate extends SemanticContext2 {
      static {
        __name(this, "Predicate");
      }
      ruleIndex;
      predIndex;
      isCtxDependent;
      // e.g., $i ref in pred
      constructor(ruleIndex, predIndex, isCtxDependent) {
        super();
        this.ruleIndex = ruleIndex ?? -1;
        this.predIndex = predIndex ?? -1;
        this.isCtxDependent = isCtxDependent ?? false;
      }
      evaluate(parser, outerContext) {
        const localctx = this.isCtxDependent ? outerContext : null;
        return parser.sempred(localctx, this.ruleIndex, this.predIndex);
      }
      hashCode() {
        if (this.cachedHashCode === void 0) {
          let hashCode = MurmurHash.initialize();
          hashCode = MurmurHash.update(hashCode, this.ruleIndex);
          hashCode = MurmurHash.update(hashCode, this.predIndex);
          hashCode = MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
          hashCode = MurmurHash.finish(hashCode, 3);
          this.cachedHashCode = hashCode;
        }
        return this.cachedHashCode;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
      }
      toString() {
        return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
      }
    }
    SemanticContext2.Predicate = Predicate;
    class PrecedencePredicate extends SemanticContext2 {
      static {
        __name(this, "PrecedencePredicate");
      }
      precedence;
      constructor(precedence) {
        super();
        this.precedence = precedence ?? 0;
      }
      evaluate(parser, outerContext) {
        return parser.precpred(outerContext, this.precedence);
      }
      evalPrecedence(parser, outerContext) {
        if (parser.precpred(outerContext ?? null, this.precedence)) {
          return SemanticContext2.NONE;
        }
        return null;
      }
      compareTo(other) {
        return this.precedence - other.precedence;
      }
      hashCode() {
        return 31 + this.precedence;
      }
      equals(other) {
        if (this === other) {
          return true;
        }
        return this.precedence === other.precedence;
      }
      toString() {
        return "{" + this.precedence + ">=prec}?";
      }
    }
    SemanticContext2.PrecedencePredicate = PrecedencePredicate;
    SemanticContext2.NONE = new Predicate();
  })(SemanticContext || (SemanticContext = {}));
  var ATNConfig = class _ATNConfig {
    static {
      __name(this, "ATNConfig");
    }
    /** The ATN state associated with this configuration */
    state;
    /** What alt (or lexer rule) is predicted by this configuration */
    alt;
    /**
     * We cannot execute predicates dependent upon local context unless
     * we know for sure we are in the correct context. Because there is
     * no way to do this efficiently, we simply cannot evaluate
     * dependent predicates unless we are in the rule that initially
     * invokes the ATN simulator.
     *
     * closure() tracks the depth of how far we dip into the outer context:
     * depth > 0.
     */
    reachesIntoOuterContext = false;
    // Not used in hash code.
    precedenceFilterSuppressed = false;
    // Not used in hash code.
    get semanticContext() {
      return this.#semanticContext;
    }
    cachedHashCode;
    // Shared with LexerATNConfig.
    /**
     * The syntactic context is a graph-structured stack node whose
     * path(s) to the root is the rule invocation(s)
     * chain used to arrive at the state.  The semantic context is
     * the tree of semantic predicates encountered before reaching
     * an ATN state
     */
    #context = null;
    #semanticContext;
    /** Never create config classes directly. Use the factory methods below. */
    constructor(c, state, context, semanticContext) {
      this.state = state;
      this.alt = c.alt;
      this.context = context;
      this.#semanticContext = semanticContext ?? SemanticContext.NONE;
      this.reachesIntoOuterContext = c.reachesIntoOuterContext;
      if (c.precedenceFilterSuppressed !== void 0) {
        this.precedenceFilterSuppressed = c.precedenceFilterSuppressed;
      }
    }
    static duplicate(old, semanticContext) {
      return new _ATNConfig(old, old.state, old.context, semanticContext ?? old.semanticContext);
    }
    static createWithContext(state, alt, context, semanticContext) {
      return new _ATNConfig({ alt }, state, context, semanticContext);
    }
    static createWithConfig(state, config, context) {
      return new _ATNConfig(config, state, context ?? config.context, config.semanticContext);
    }
    static createWithSemanticContext(state, c, semanticContext) {
      return new _ATNConfig(c, state ?? c.state, c.context, semanticContext);
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hashCode = MurmurHash.initialize(7);
        hashCode = MurmurHash.update(hashCode, this.state.stateNumber);
        hashCode = MurmurHash.update(hashCode, this.alt);
        hashCode = MurmurHash.updateFromComparable(hashCode, this.#context);
        hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);
        hashCode = MurmurHash.finish(hashCode, 4);
        this.cachedHashCode = hashCode;
      }
      return this.cachedHashCode;
    }
    /**
     * The stack of invoking states leading to the rule/states associated
     * with this config.  We track only those contexts pushed during
     * execution of the ATN simulator.
     */
    get context() {
      return this.#context;
    }
    set context(context) {
      this.#context = context;
      this.cachedHashCode = void 0;
    }
    /**
     * An ATN configuration is equal to another if both have
     * the same state, they predict the same alternative, and
     * syntactic/semantic contexts are the same.
     */
    equals(other) {
      if (this === other) {
        return true;
      }
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
    }
    toString(_recog, showAlt = true) {
      let alt = "";
      if (showAlt) {
        alt = "," + this.alt;
      }
      return "(" + this.state + alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext ? ",up=" + this.reachesIntoOuterContext : "") + ")";
    }
  };
  var LL1Analyzer = class _LL1Analyzer {
    static {
      __name(this, "LL1Analyzer");
    }
    /**
     * Special value added to the lookahead sets to indicate that we hit
     * a predicate during analysis if `seeThruPreds==false`.
     */
    static hitPredicate = Token.INVALID_TYPE;
    atn;
    /**
     * Calculates the SLL(1) expected lookahead set for each outgoing transition
     * of an {@link ATNState}. The returned array has one element for each
     * outgoing transition in `s`. If the closure from transition
     * _i_ leads to a semantic predicate before matching a symbol, the
     * element at index *i* of the result will be `null`.
     *
     * @param s the ATN state
     * @returns the expected symbols for each outgoing transition of `s`.
     */
    getDecisionLookahead(s) {
      if (!s) {
        return void 0;
      }
      const count = s.transitions.length;
      const look = new Array(count);
      for (let alt = 0; alt < count; alt++) {
        const set = new IntervalSet();
        const lookBusy = new HashSet();
        this.doLook(
          s.transitions[alt].target,
          void 0,
          PredictionContext.EMPTY,
          set,
          lookBusy,
          new BitSet(),
          false,
          false
        );
        if (set.length > 0 && !set.contains(_LL1Analyzer.hitPredicate)) {
          look[alt] = set;
        }
      }
      return look;
    }
    /**
     * Compute set of tokens that can follow `s` in the ATN in the
     * specified `ctx`.
     *
     * If `ctx` is `null` and the end of the rule containing
     * `s` is reached, {@link Token//EPSILON} is added to the result set.
     * If `ctx` is not `null` and the end of the outermost rule is
     * reached, {@link Token//EOF} is added to the result set.
     *
     * @param atn the ATN
     * @param s the ATN state
     * @param stopState the ATN state to stop at. This can be a
     * {@link BlockEndState} to detect epsilon paths through a closure.
     * @param ctx the complete parser context, or `null` if the context
     * should be ignored
     *
     * @returns The set of tokens that can follow `s` in the ATN in the
     * specified `ctx`.
     */
    look(atn, s, stopState, ctx) {
      this.atn = atn;
      const r = new IntervalSet();
      const lookContext = ctx ? predictionContextFromRuleContext(atn, ctx) : null;
      this.doLook(s, stopState, lookContext, r, new HashSet(), new BitSet(), true, true);
      return r;
    }
    /**
     * Compute set of tokens that can follow `s` in the ATN in the
     * specified `ctx`.
     *
     * If `ctx` is `null` and `stopState` or the end of the
     * rule containing `s` is reached, {@link Token//EPSILON} is added to
     * the result set. If `ctx` is not `null` and `addEOF` is
     * `true` and `stopState` or the end of the outermost rule is
     * reached, {@link Token//EOF} is added to the result set.
     *
     * @param s the ATN state.
     * @param stopState the ATN state to stop at. This can be a
     * {@link BlockEndState} to detect epsilon paths through a closure.
     * @param ctx The outer context, or `null` if the outer context should
     * not be used.
     * @param look The result lookahead set.
     * @param lookBusy A set used for preventing epsilon closures in the ATN
     * from causing a stack overflow. Outside code should pass
     * `new CustomizedSet<ATNConfig>` for this argument.
     * @param calledRuleStack A set used for preventing left recursion in the
     * ATN from causing a stack overflow. Outside code should pass
     * `new BitSet()` for this argument.
     * @param seeThruPreds `true` to true semantic predicates as
     * implicitly `true` and "see through them", otherwise `false`
     * to treat semantic predicates as opaque and add {@link hitPredicate} to the
     * result if one is encountered.
     * @param addEOF Add {@link Token//EOF} to the result if the end of the
     * outermost context is reached. This parameter has no effect if `ctx`
     * is `null`.
     */
    doLook(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
      const c = ATNConfig.createWithContext(s, 0, ctx);
      if (lookBusy.get(c)) {
        return;
      }
      lookBusy.add(c);
      if (s === stopState) {
        if (!ctx) {
          look.addOne(Token.EPSILON);
          return;
        } else if (ctx.isEmpty() && addEOF) {
          look.addOne(Token.EOF);
          return;
        }
      }
      if (s.constructor.stateType === ATNState.RULE_STOP) {
        if (!ctx) {
          look.addOne(Token.EPSILON);
          return;
        } else if (ctx.isEmpty() && addEOF) {
          look.addOne(Token.EOF);
          return;
        }
        if (ctx !== PredictionContext.EMPTY) {
          const removed = calledRuleStack.get(s.ruleIndex);
          try {
            calledRuleStack.clear(s.ruleIndex);
            for (let i = 0; i < ctx.length; i++) {
              const returnState = this.atn.states[ctx.getReturnState(i)];
              this.doLook(
                returnState,
                stopState,
                ctx.getParent(i),
                look,
                lookBusy,
                calledRuleStack,
                seeThruPreds,
                addEOF
              );
            }
          } finally {
            if (removed) {
              calledRuleStack.set(s.ruleIndex);
            }
          }
          return;
        }
      }
      for (const t of s.transitions) {
        switch (t.transitionType) {
          case Transition.RULE: {
            if (calledRuleStack.get(t.target.ruleIndex)) {
              continue;
            }
            const newContext = SingletonPredictionContext.create(
              ctx ?? void 0,
              t.followState.stateNumber
            );
            try {
              calledRuleStack.set(t.target.ruleIndex);
              this.doLook(
                t.target,
                stopState,
                newContext,
                look,
                lookBusy,
                calledRuleStack,
                seeThruPreds,
                addEOF
              );
            } finally {
              calledRuleStack.clear(t.target.ruleIndex);
            }
            break;
          }
          case Transition.PREDICATE:
          case Transition.PRECEDENCE: {
            if (seeThruPreds) {
              this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
              look.addOne(_LL1Analyzer.hitPredicate);
            }
            break;
          }
          case Transition.WILDCARD: {
            look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
            break;
          }
          default: {
            if (t.isEpsilon) {
              this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
              let set = t.label;
              if (set) {
                if (t instanceof NotSetTransition) {
                  set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                }
                look.addSet(set);
              }
            }
            break;
          }
        }
      }
    }
  };
  var ATN = class _ATN {
    static {
      __name(this, "ATN");
    }
    static INVALID_ALT_NUMBER = 0;
    /** Represents the type of recognizer an ATN applies to */
    static LEXER = 0;
    static PARSER = 1;
    /**
     * Used for runtime deserialization of ATNs from strings
     * The type of the ATN.
     */
    grammarType;
    /** The maximum value for any symbol recognized by a transition in the ATN. */
    maxTokenType;
    states = [];
    /**
     * Each subrule/rule is a decision point and we must track them so we
     * can go back later and build DFA predictors for them.  This includes
     * all the rules, subrules, optional blocks, ()+, ()* etc...
     */
    decisionToState = [];
    /** Maps from rule index to starting state number. */
    ruleToStartState = [];
    // Initialized by the ATN deserializer.
    /** Maps from rule index to stop state number. */
    ruleToStopState = [];
    // Initialized by the ATN deserializer.
    modeNameToStartState = /* @__PURE__ */ new Map();
    /**
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is `null`
     */
    ruleToTokenType = [];
    // Initialized by the ATN deserializer.
    /**
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN
     */
    lexerActions = [];
    modeToStartState = [];
    static #analyzer = new LL1Analyzer();
    constructor(grammarType, maxTokenType) {
      this.grammarType = grammarType;
      this.maxTokenType = maxTokenType;
    }
    /**
     * Compute the set of valid tokens that can occur starting in state `s`.
     * If `ctx` is null, the set of tokens will not include what can follow
     * the rule surrounding `s`. In other words, the set will be
     * restricted to tokens reachable staying within `s`'s rule.
     */
    nextTokens(atnState, ctx) {
      if (!ctx && atnState.nextTokenWithinRule) {
        return atnState.nextTokenWithinRule;
      }
      const next = _ATN.#analyzer.look(this, atnState, void 0, ctx);
      if (!ctx) {
        atnState.nextTokenWithinRule = next;
      }
      return next;
    }
    addState(state) {
      if (state) {
        state.stateNumber = this.states.length;
      }
      this.states.push(state);
    }
    removeState(state) {
      this.states[state.stateNumber] = null;
    }
    defineDecisionState(s) {
      this.decisionToState.push(s);
      s.decision = this.decisionToState.length - 1;
      return s.decision;
    }
    getDecisionState(decision) {
      if (this.decisionToState.length === 0) {
        return null;
      } else {
        return this.decisionToState[decision];
      }
    }
    getNumberOfDecisions() {
      return this.decisionToState.length;
    }
    /**
     * Computes the set of input symbols which could follow ATN state number
     * `stateNumber` in the specified full `context`. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token//EOF} is added to the returned set.
     *
     * If `context` is `null`, it is treated as
     * {@link ParserRuleContext//EMPTY}.
     *
     * @param stateNumber the ATN state number
     * @param context the full parse context
     *
     * @returns {IntervalSet} The set of potentially valid input symbols which could follow the
     * specified state in the specified context.
     *
     * @throws IllegalArgumentException if the ATN does not contain a state with
     * number `stateNumber`
     */
    getExpectedTokens(stateNumber, context) {
      if (stateNumber < 0 || stateNumber >= this.states.length) {
        throw new Error("Invalid state number.");
      }
      const s = this.states[stateNumber];
      let following = this.nextTokens(s);
      if (!following.contains(Token.EPSILON)) {
        return following;
      }
      let ctx = context;
      const expected = new IntervalSet();
      expected.addSet(following);
      expected.removeOne(Token.EPSILON);
      while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
        const invokingState = this.states[ctx.invokingState];
        const rt = invokingState.transitions[0];
        following = this.nextTokens(rt.followState);
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        ctx = ctx.parent;
      }
      if (following.contains(Token.EPSILON)) {
        expected.addOne(Token.EOF);
      }
      return expected;
    }
  };
  var KeyTypeEqualityComparer = class _KeyTypeEqualityComparer {
    static {
      __name(this, "KeyTypeEqualityComparer");
    }
    static instance = new _KeyTypeEqualityComparer();
    hashCode(config) {
      let hashCode = 7;
      hashCode = 31 * hashCode + config.state.stateNumber;
      hashCode = 31 * hashCode + config.alt;
      hashCode = 31 * hashCode + config.semanticContext.hashCode();
      return hashCode;
    }
    equals(a, b) {
      if (a === b) {
        return true;
      }
      return a.state.stateNumber === b.state.stateNumber && a.alt === b.alt && a.semanticContext.equals(b.semanticContext);
    }
  };
  var ATNConfigSet = class {
    static {
      __name(this, "ATNConfigSet");
    }
    /**
     * The reason that we need this is because we don't want the hash map to use
     * the standard hash code and equals. We need all configurations with the
     * same
     * `(s,i,_,semctx)` to be equal. Unfortunately, this key effectively
     * doubles
     * the number of objects associated with ATNConfigs. The other solution is
     * to
     * use a hash table that lets us specify the equals/hashCode operation.
     * All configs but hashed by (s, i, _, pi) not including context. Wiped out
     * when we go readonly as this set becomes a DFA state
     */
    configLookup = new HashSet(KeyTypeEqualityComparer.instance);
    // Track the elements as they are added to the set; supports get(i).
    configs = [];
    uniqueAlt = 0;
    /**
     * Used in parser and lexer. In lexer, it indicates we hit a pred
     * while computing a closure operation. Don't make a DFA state from this
     */
    hasSemanticContext = false;
    dipsIntoOuterContext = false;
    /**
     * Indicates that this configuration set is part of a full context
     * LL prediction. It will be used to determine how to merge $. With SLL
     * it's a wildcard whereas it is not for LL context merge
     */
    fullCtx = false;
    /**
     * Indicates that the set of configurations is read-only. Do not
     * allow any code to manipulate the set; DFA states will point at
     * the sets and they must not change. This does not protect the other
     * fields; in particular, conflictingAlts is set after
     * we've made this readonly
     */
    readOnly = false;
    conflictingAlts = null;
    /**
     * Tracks the first config that has a rule stop state. Avoids frequent linear search for that, when adding
     * a DFA state in the lexer ATN simulator.
     */
    firstStopState;
    #cachedHashCode = -1;
    constructor(fullCtxOrOldSet) {
      if (fullCtxOrOldSet !== void 0) {
        if (typeof fullCtxOrOldSet === "boolean") {
          this.fullCtx = fullCtxOrOldSet ?? true;
        } else {
          const old = fullCtxOrOldSet;
          this.addAll(old.configs);
          this.uniqueAlt = old.uniqueAlt;
          this.conflictingAlts = old.conflictingAlts;
          this.hasSemanticContext = old.hasSemanticContext;
          this.dipsIntoOuterContext = old.dipsIntoOuterContext;
        }
      }
    }
    [Symbol.iterator]() {
      return this.configs[Symbol.iterator]();
    }
    /**
     * Adding a new config means merging contexts with existing configs for
     * `(s, i, pi, _)`, where `s` is the {@link ATNConfig.state}, `i` is the {@link ATNConfig.alt}, and
     * `pi` is the {@link ATNConfig.semanticContext}. We use `(s,i,pi)` as key.
     *
     * This method updates {@link dipsIntoOuterContext} and
     * {@link hasSemanticContext} when necessary.
     */
    add(config, mergeCache = null) {
      if (this.readOnly) {
        throw new Error("This set is readonly");
      }
      if (!this.firstStopState && config.state.constructor.stateType === ATNState.RULE_STOP) {
        this.firstStopState = config;
      }
      this.hasSemanticContext ||= config.semanticContext !== SemanticContext.NONE;
      this.dipsIntoOuterContext ||= config.reachesIntoOuterContext;
      const existing = this.configLookup.getOrAdd(config);
      if (existing === config) {
        this.#cachedHashCode = -1;
        this.configs.push(config);
        return;
      }
      const rootIsWildcard = !this.fullCtx;
      const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
      existing.reachesIntoOuterContext ||= config.reachesIntoOuterContext;
      existing.precedenceFilterSuppressed ||= config.precedenceFilterSuppressed;
      existing.context = merged;
    }
    /** Return a List holding list of configs */
    get elements() {
      return this.configs;
    }
    /**
     * Gets the complete set of represented alternatives for the configuration set.
     *
     * @returns the set of represented alternatives in this configuration set
     */
    getAlts() {
      const alts = new BitSet();
      for (const config of this.configs) {
        alts.set(config.alt);
      }
      return alts;
    }
    getPredicates() {
      const preds = [];
      for (const config of this.configs) {
        if (config.semanticContext !== SemanticContext.NONE) {
          preds.push(config.semanticContext);
        }
      }
      return preds;
    }
    getStates() {
      const states = new HashSet();
      for (const config of this.configs) {
        states.add(config.state);
      }
      return states;
    }
    optimizeConfigs(interpreter) {
      if (this.readOnly) {
        throw new Error("This set is readonly");
      }
      if (this.configLookup.size === 0) {
        return;
      }
      for (const config of this.configs) {
        config.context = interpreter.getCachedContext(config.context);
      }
    }
    addAll(coll) {
      for (const config of coll) {
        this.add(config);
      }
      return false;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext && equalArrays(this.configs, other.configs)) {
        return true;
      }
      return false;
    }
    hashCode() {
      if (this.#cachedHashCode === -1) {
        this.#cachedHashCode = this.computeHashCode();
      }
      return this.#cachedHashCode;
    }
    get length() {
      return this.configs.length;
    }
    isEmpty() {
      return this.configs.length === 0;
    }
    contains(item) {
      if (this.configLookup === null) {
        throw new Error("This method is not implemented for readonly sets.");
      }
      return this.configLookup.contains(item);
    }
    containsFast(item) {
      if (this.configLookup === null) {
        throw new Error("This method is not implemented for readonly sets.");
      }
      return this.configLookup.contains(item);
    }
    clear() {
      if (this.readOnly) {
        throw new Error("This set is readonly");
      }
      this.configs = [];
      this.#cachedHashCode = -1;
      this.configLookup = new HashSet(KeyTypeEqualityComparer.instance);
    }
    setReadonly(readOnly) {
      this.readOnly = readOnly;
      if (readOnly) {
        this.configLookup = null;
      }
    }
    toString() {
      return arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
    }
    computeHashCode() {
      let hash = MurmurHash.initialize();
      this.configs.forEach((config) => {
        hash = MurmurHash.update(hash, config.hashCode());
      });
      hash = MurmurHash.finish(hash, this.configs.length);
      return hash;
    }
  };
  var BasicState = class extends ATNState {
    static {
      __name(this, "BasicState");
    }
    static stateType = ATNState.BASIC;
  };
  var DecisionState = class extends ATNState {
    static {
      __name(this, "DecisionState");
    }
    decision = -1;
    nonGreedy = false;
  };
  var BlockStartState = class extends DecisionState {
    static {
      __name(this, "BlockStartState");
    }
    endState;
  };
  var BlockEndState = class extends ATNState {
    static {
      __name(this, "BlockEndState");
    }
    static stateType = ATNState.BLOCK_END;
    startState;
  };
  var LoopEndState = class extends ATNState {
    static {
      __name(this, "LoopEndState");
    }
    static stateType = ATNState.LOOP_END;
    loopBackState;
  };
  var RuleStartState = class extends ATNState {
    static {
      __name(this, "RuleStartState");
    }
    static stateType = ATNState.RULE_START;
    stopState;
    isLeftRecursiveRule = false;
  };
  var RuleStopState = class extends ATNState {
    static {
      __name(this, "RuleStopState");
    }
    static stateType = ATNState.RULE_STOP;
  };
  var TokensStartState = class extends DecisionState {
    static {
      __name(this, "TokensStartState");
    }
    static stateType = ATNState.TOKEN_START;
  };
  var PlusLoopbackState = class extends DecisionState {
    static {
      __name(this, "PlusLoopbackState");
    }
    static stateType = ATNState.PLUS_LOOP_BACK;
  };
  var StarLoopbackState = class extends ATNState {
    static {
      __name(this, "StarLoopbackState");
    }
    static stateType = ATNState.STAR_LOOP_BACK;
  };
  var StarLoopEntryState = class extends DecisionState {
    static {
      __name(this, "StarLoopEntryState");
    }
    static stateType = ATNState.STAR_LOOP_ENTRY;
    // This is always set during ATN deserialization
    loopBackState;
    /**
     * Indicates whether this state can benefit from a precedence DFA during SLL
     * decision making.
     *
     * This is a computed property that is calculated during ATN deserialization
     * and stored for use in {@link ParserATNSimulator} and
     * {@link ParserInterpreter}.
     *
     * @see `DFA.isPrecedenceDfa`
     */
    precedenceRuleDecision = false;
  };
  var PlusBlockStartState = class extends BlockStartState {
    static {
      __name(this, "PlusBlockStartState");
    }
    static stateType = ATNState.PLUS_BLOCK_START;
    loopBackState;
  };
  var StarBlockStartState = class extends BlockStartState {
    static {
      __name(this, "StarBlockStartState");
    }
    static stateType = ATNState.STAR_BLOCK_START;
  };
  var BasicBlockStartState = class extends BlockStartState {
    static {
      __name(this, "BasicBlockStartState");
    }
    static stateType = ATNState.BLOCK_START;
  };
  var AtomTransition = class extends Transition {
    static {
      __name(this, "AtomTransition");
    }
    /** The token type or character value; or, signifies special label. */
    labelValue;
    #label;
    constructor(target, label) {
      super(target);
      this.labelValue = label;
      this.#label = IntervalSet.of(label, label);
    }
    get label() {
      return this.#label;
    }
    get transitionType() {
      return Transition.ATOM;
    }
    matches(symbol) {
      return this.labelValue === symbol;
    }
    toString() {
      return this.labelValue.toString();
    }
  };
  var RuleTransition = class extends Transition {
    static {
      __name(this, "RuleTransition");
    }
    ruleIndex;
    precedence;
    followState;
    constructor(ruleStart, ruleIndex, precedence, followState) {
      super(ruleStart);
      this.ruleIndex = ruleIndex;
      this.precedence = precedence;
      this.followState = followState;
    }
    get isEpsilon() {
      return true;
    }
    get transitionType() {
      return Transition.RULE;
    }
    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
      return false;
    }
  };
  var RangeTransition = class extends Transition {
    static {
      __name(this, "RangeTransition");
    }
    start;
    stop;
    #label = new IntervalSet();
    constructor(target, start, stop) {
      super(target);
      this.start = start;
      this.stop = stop;
      this.#label.addRange(start, stop);
    }
    get label() {
      return this.#label;
    }
    get transitionType() {
      return Transition.RANGE;
    }
    matches(symbol, _minVocabSymbol, _maxVocabSymbol) {
      return symbol >= this.start && symbol <= this.stop;
    }
    toString() {
      return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
    }
  };
  var ActionTransition = class extends Transition {
    static {
      __name(this, "ActionTransition");
    }
    ruleIndex;
    actionIndex;
    isCtxDependent;
    constructor(target, ruleIndex, actionIndex, isCtxDependent) {
      super(target);
      this.ruleIndex = ruleIndex;
      this.actionIndex = actionIndex ?? -1;
      this.isCtxDependent = isCtxDependent ?? false;
    }
    get isEpsilon() {
      return true;
    }
    get transitionType() {
      return Transition.ACTION;
    }
    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
      return false;
    }
    toString() {
      return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
  };
  var EpsilonTransition = class extends Transition {
    static {
      __name(this, "EpsilonTransition");
    }
    #outermostPrecedenceReturn;
    constructor(target, outermostPrecedenceReturn = -1) {
      super(target);
      this.#outermostPrecedenceReturn = outermostPrecedenceReturn;
    }
    /**
     * @returns the rule index of a precedence rule for which this transition is
     * returning from, where the precedence value is 0; otherwise, -1.
     *
     * @see ATNConfig.isPrecedenceFilterSuppressed()
     * @see ParserATNSimulator.applyPrecedenceFilter(ATNConfigSet)
     * @since 4.4.1
     */
    get outermostPrecedenceReturn() {
      return this.#outermostPrecedenceReturn;
    }
    get isEpsilon() {
      return true;
    }
    get transitionType() {
      return Transition.EPSILON;
    }
    matches() {
      return false;
    }
    toString() {
      return "epsilon";
    }
  };
  var WildcardTransition = class extends Transition {
    static {
      __name(this, "WildcardTransition");
    }
    get transitionType() {
      return Transition.WILDCARD;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
    }
    toString() {
      return ".";
    }
  };
  var AbstractPredicateTransition = class extends Transition {
    static {
      __name(this, "AbstractPredicateTransition");
    }
    constructor(target) {
      super(target);
    }
  };
  var PredicateTransition = class extends AbstractPredicateTransition {
    static {
      __name(this, "PredicateTransition");
    }
    ruleIndex;
    predIndex;
    isCtxDependent;
    // e.g., $i ref in pred
    constructor(target, ruleIndex, predIndex, isCtxDependent) {
      super(target);
      this.ruleIndex = ruleIndex;
      this.predIndex = predIndex;
      this.isCtxDependent = isCtxDependent;
    }
    get isEpsilon() {
      return true;
    }
    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
      return false;
    }
    get transitionType() {
      return Transition.PREDICATE;
    }
    getPredicate() {
      return new SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    toString() {
      return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
  };
  var PrecedencePredicateTransition = class extends AbstractPredicateTransition {
    static {
      __name(this, "PrecedencePredicateTransition");
    }
    precedence;
    constructor(target, precedence) {
      super(target);
      this.precedence = precedence;
    }
    get isEpsilon() {
      return true;
    }
    matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
      return false;
    }
    getPredicate() {
      return new SemanticContext.PrecedencePredicate(this.precedence);
    }
    get transitionType() {
      return Transition.PRECEDENCE;
    }
    toString() {
      return this.precedence + " >= _p";
    }
  };
  var LexerActionType = {
    /** The type of a {@link LexerChannelAction} action. */
    CHANNEL: 0,
    /** The type of a {@link LexerCustomAction} action */
    CUSTOM: 1,
    /** The type of a {@link LexerModeAction} action. */
    MODE: 2,
    /** The type of a {@link LexerMoreAction} action. */
    MORE: 3,
    /** The type of a {@link LexerPopModeAction} action. */
    POP_MODE: 4,
    /** The type of a {@link LexerPushModeAction} action. */
    PUSH_MODE: 5,
    /** The type of a {@link LexerSkipAction} action. */
    SKIP: 6,
    /** The type of a {@link LexerTypeAction} action. */
    TYPE: 7
  };
  var LexerSkipAction = class _LexerSkipAction {
    static {
      __name(this, "LexerSkipAction");
    }
    /** Provides a singleton instance of this parameter-less lexer action. */
    static instance = new _LexerSkipAction();
    actionType;
    isPositionDependent = false;
    constructor() {
      this.actionType = LexerActionType.SKIP;
    }
    equals(obj) {
      return obj === this;
    }
    hashCode() {
      return LexerActionType.SKIP;
    }
    execute(lexer) {
      lexer.skip();
    }
    toString() {
      return "skip";
    }
  };
  var LexerChannelAction = class _LexerChannelAction {
    static {
      __name(this, "LexerChannelAction");
    }
    channel;
    actionType;
    isPositionDependent = false;
    cachedHashCode;
    constructor(channel) {
      this.actionType = LexerActionType.CHANNEL;
      this.channel = channel;
    }
    /**
     * This action is implemented by calling {@link Lexer.setChannel} with the
     * value provided by {@link getChannel}.
     */
    execute(lexer) {
      lexer.channel = this.channel;
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        hash = MurmurHash.update(hash, this.actionType);
        hash = MurmurHash.update(hash, this.channel);
        this.cachedHashCode = MurmurHash.finish(hash, 2);
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _LexerChannelAction)) {
        return false;
      }
      return this.channel === other.channel;
    }
    toString() {
      return "channel(" + this.channel + ")";
    }
  };
  var LexerCustomAction = class _LexerCustomAction {
    static {
      __name(this, "LexerCustomAction");
    }
    ruleIndex;
    actionIndex;
    actionType;
    isPositionDependent = true;
    cachedHashCode;
    /**
     * Constructs a custom lexer action with the specified rule and action indexes.
     *
     * @param ruleIndex The rule index to use for calls to {@link Recognizer.action}.
     * @param actionIndex The action index to use for calls to {@link Recognizer.action}.
     */
    constructor(ruleIndex, actionIndex) {
      this.actionType = LexerActionType.CUSTOM;
      this.ruleIndex = ruleIndex;
      this.actionIndex = actionIndex;
    }
    /**
     * Custom actions are implemented by calling {@link Lexer.action} with the
     * appropriate rule and action indexes.
     */
    execute(lexer) {
      lexer.action(null, this.ruleIndex, this.actionIndex);
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        hash = MurmurHash.update(hash, this.actionType);
        hash = MurmurHash.update(hash, this.ruleIndex);
        hash = MurmurHash.update(hash, this.actionIndex);
        this.cachedHashCode = MurmurHash.finish(hash, 3);
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _LexerCustomAction)) {
        return false;
      }
      return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
  };
  var LexerMoreAction = class _LexerMoreAction {
    static {
      __name(this, "LexerMoreAction");
    }
    static instance = new _LexerMoreAction();
    actionType;
    isPositionDependent = false;
    constructor() {
      this.actionType = LexerActionType.MORE;
    }
    equals(obj) {
      return obj === this;
    }
    hashCode() {
      return LexerActionType.MORE;
    }
    /**
     * This action is implemented by calling {@link Lexer.popMode}.
     */
    execute(lexer) {
      lexer.more();
    }
    toString() {
      return "more";
    }
  };
  var LexerTypeAction = class _LexerTypeAction {
    static {
      __name(this, "LexerTypeAction");
    }
    type;
    actionType;
    isPositionDependent = false;
    cachedHashCode;
    constructor(type) {
      this.actionType = LexerActionType.TYPE;
      this.type = type;
    }
    execute(lexer) {
      lexer.type = this.type;
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        hash = MurmurHash.update(hash, this.actionType);
        hash = MurmurHash.update(hash, this.type);
        this.cachedHashCode = MurmurHash.finish(hash, 2);
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _LexerTypeAction)) {
        return false;
      }
      return this.type === other.type;
    }
    toString() {
      return "type(" + this.type + ")";
    }
  };
  var LexerPushModeAction = class _LexerPushModeAction {
    static {
      __name(this, "LexerPushModeAction");
    }
    mode;
    actionType;
    isPositionDependent = false;
    cachedHashCode;
    constructor(mode) {
      this.actionType = LexerActionType.PUSH_MODE;
      this.mode = mode;
    }
    /**
     * This action is implemented by calling {@link Lexer.pushMode} with the
     * value provided by {@link getMode}.
     */
    execute(lexer) {
      lexer.pushMode(this.mode);
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        hash = MurmurHash.update(hash, this.actionType);
        hash = MurmurHash.update(hash, this.mode);
        this.cachedHashCode = MurmurHash.finish(hash, 2);
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _LexerPushModeAction)) {
        return false;
      }
      return this.mode === other.mode;
    }
    toString() {
      return "pushMode(" + this.mode + ")";
    }
  };
  var LexerPopModeAction = class _LexerPopModeAction {
    static {
      __name(this, "LexerPopModeAction");
    }
    static instance = new _LexerPopModeAction();
    actionType;
    isPositionDependent = false;
    constructor() {
      this.actionType = LexerActionType.POP_MODE;
    }
    equals(obj) {
      return obj === this;
    }
    hashCode() {
      return LexerActionType.POP_MODE;
    }
    /**
     * This action is implemented by calling {@link Lexer//popMode}.
     */
    execute(lexer) {
      lexer.popMode();
    }
    toString() {
      return "popMode";
    }
  };
  var LexerModeAction = class _LexerModeAction {
    static {
      __name(this, "LexerModeAction");
    }
    mode;
    actionType;
    isPositionDependent = false;
    cachedHashCode;
    constructor(mode) {
      this.actionType = LexerActionType.MODE;
      this.mode = mode;
    }
    /**
     * This action is implemented by calling {@link Lexer.mode} with the
     * value provided by {@link getMode}.
     */
    execute(lexer) {
      lexer.mode = this.mode;
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        hash = MurmurHash.update(hash, this.actionType);
        hash = MurmurHash.update(hash, this.mode);
        this.cachedHashCode = MurmurHash.finish(hash, 2);
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _LexerModeAction)) {
        return false;
      }
      return this.mode === other.mode;
    }
    toString() {
      return "mode(" + this.mode + ")";
    }
  };
  var ATNDeserializer = class _ATNDeserializer {
    static {
      __name(this, "ATNDeserializer");
    }
    static SERIALIZED_VERSION = 4;
    static stateTypeMapper = /* @__PURE__ */ new Map([
      [ATNState.INVALID_TYPE, void 0],
      [ATNState.BASIC, BasicState],
      [ATNState.RULE_START, RuleStartState],
      [ATNState.BLOCK_START, BasicBlockStartState],
      [ATNState.PLUS_BLOCK_START, PlusBlockStartState],
      [ATNState.STAR_BLOCK_START, StarBlockStartState],
      [ATNState.TOKEN_START, TokensStartState],
      [ATNState.RULE_STOP, RuleStopState],
      [ATNState.BLOCK_END, BlockEndState],
      [ATNState.STAR_LOOP_BACK, StarLoopbackState],
      [ATNState.STAR_LOOP_ENTRY, StarLoopEntryState],
      [ATNState.PLUS_LOOP_BACK, PlusLoopbackState],
      [ATNState.LOOP_END, LoopEndState]
    ]);
    static lexerActionFactoryMapper = /* @__PURE__ */ new Map([
      [LexerActionType.CHANNEL, (data1) => {
        return new LexerChannelAction(data1);
      }],
      [LexerActionType.CUSTOM, (data1, data2) => {
        return new LexerCustomAction(data1, data2);
      }],
      [LexerActionType.MODE, (data1) => {
        return new LexerModeAction(data1);
      }],
      [LexerActionType.MORE, () => {
        return LexerMoreAction.instance;
      }],
      [LexerActionType.POP_MODE, () => {
        return LexerPopModeAction.instance;
      }],
      [LexerActionType.PUSH_MODE, (data1) => {
        return new LexerPushModeAction(data1);
      }],
      [LexerActionType.SKIP, () => {
        return LexerSkipAction.instance;
      }],
      [LexerActionType.TYPE, (data1) => {
        return new LexerTypeAction(data1);
      }]
    ]);
    data = [];
    pos = 0;
    deserializationOptions;
    actionFactories;
    constructor(options) {
      if (!options) {
        options = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: false };
      }
      this.deserializationOptions = options;
    }
    deserialize(data) {
      this.data = data;
      this.checkVersion();
      const atn = this.readATN();
      this.readStates(atn);
      this.readRules(atn);
      this.readModes(atn);
      const sets = [];
      this.readSets(atn, sets);
      this.readEdges(atn, sets);
      this.readDecisions(atn);
      this.readLexerActions(atn);
      this.markPrecedenceDecisions(atn);
      this.verifyATN(atn);
      if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATN.PARSER) {
        this.generateRuleBypassTransitions(atn);
        this.verifyATN(atn);
      }
      return atn;
    }
    checkVersion() {
      const version = this.data[this.pos++];
      if (version !== _ATNDeserializer.SERIALIZED_VERSION) {
        throw new Error("Could not deserialize ATN with version " + version + " (expected " + _ATNDeserializer.SERIALIZED_VERSION + ").");
      }
    }
    readATN() {
      const grammarType = this.data[this.pos++];
      const maxTokenType = this.data[this.pos++];
      return new ATN(grammarType, maxTokenType);
    }
    readStates(atn) {
      let j;
      let stateNumber;
      const loopBackStateNumbers = [];
      const endStateNumbers = [];
      const stateCount = this.data[this.pos++];
      for (let i = 0; i < stateCount; i++) {
        const stateType = this.data[this.pos++];
        if (stateType === ATNState.INVALID_TYPE) {
          atn.addState(null);
          continue;
        }
        const ruleIndex = this.data[this.pos++];
        const s = this.stateFactory(stateType, ruleIndex);
        if (stateType === ATNState.LOOP_END) {
          const loopBackStateNumber = this.data[this.pos++];
          loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if (s instanceof BlockStartState) {
          const endStateNumber = this.data[this.pos++];
          endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
      }
      for (j = 0; j < loopBackStateNumbers.length; j++) {
        const pair = loopBackStateNumbers[j];
        pair[0].loopBackState = atn.states[pair[1]] ?? void 0;
      }
      for (j = 0; j < endStateNumbers.length; j++) {
        const pair = endStateNumbers[j];
        pair[0].endState = atn.states[pair[1]];
      }
      const numNonGreedyStates = this.data[this.pos++];
      for (j = 0; j < numNonGreedyStates; j++) {
        stateNumber = this.data[this.pos++];
        atn.states[stateNumber].nonGreedy = true;
      }
      const numPrecedenceStates = this.data[this.pos++];
      for (j = 0; j < numPrecedenceStates; j++) {
        stateNumber = this.data[this.pos++];
        atn.states[stateNumber].isLeftRecursiveRule = true;
      }
    }
    readRules(atn) {
      let i;
      const ruleCount = this.data[this.pos++];
      if (atn.grammarType === ATN.LEXER) {
        atn.ruleToTokenType = new Array(ruleCount);
        atn.ruleToTokenType.fill(0);
      }
      atn.ruleToStartState = new Array(ruleCount);
      atn.ruleToStartState.fill(null);
      for (i = 0; i < ruleCount; i++) {
        const s = this.data[this.pos++];
        atn.ruleToStartState[i] = atn.states[s];
        if (atn.grammarType === ATN.LEXER) {
          const tokenType = this.data[this.pos++];
          atn.ruleToTokenType[i] = tokenType;
        }
      }
      atn.ruleToStopState = new Array(ruleCount);
      atn.ruleToStopState.fill(null);
      for (i = 0; i < atn.states.length; i++) {
        const state = atn.states[i];
        if (!(state instanceof RuleStopState)) {
          continue;
        }
        atn.ruleToStopState[state.ruleIndex] = state;
        atn.ruleToStartState[state.ruleIndex].stopState = state;
      }
    }
    readModes(atn) {
      const modeCount = this.data[this.pos++];
      for (let i = 0; i < modeCount; i++) {
        const s = this.data[this.pos++];
        atn.modeToStartState.push(atn.states[s]);
      }
    }
    readSets(atn, sets) {
      const m2 = this.data[this.pos++];
      for (let i = 0; i < m2; i++) {
        const intervalSet = new IntervalSet();
        sets.push(intervalSet);
        const n2 = this.data[this.pos++];
        const containsEof = this.data[this.pos++];
        if (containsEof !== 0) {
          intervalSet.addOne(-1);
        }
        for (let j = 0; j < n2; j++) {
          const i1 = this.data[this.pos++];
          const i2 = this.data[this.pos++];
          intervalSet.addRange(i1, i2);
        }
      }
    }
    readEdges(atn, sets) {
      let i;
      let j;
      let state;
      let trans;
      let target;
      const edgeCount = this.data[this.pos++];
      for (i = 0; i < edgeCount; i++) {
        const src = this.data[this.pos++];
        const trg = this.data[this.pos++];
        const ttype = this.data[this.pos++];
        const arg1 = this.data[this.pos++];
        const arg2 = this.data[this.pos++];
        const arg3 = this.data[this.pos++];
        trans = this.edgeFactory(atn, ttype, trg, arg1, arg2, arg3, sets);
        const srcState = atn.states[src];
        srcState.addTransition(trans);
      }
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        for (j = 0; j < state.transitions.length; j++) {
          const t = state.transitions[j];
          if (!(t instanceof RuleTransition)) {
            continue;
          }
          let outermostPrecedenceReturn = -1;
          if (atn.ruleToStartState[t.target.ruleIndex].isLeftRecursiveRule) {
            if (t.precedence === 0) {
              outermostPrecedenceReturn = t.target.ruleIndex;
            }
          }
          trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
          atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
        }
      }
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        if (state instanceof BlockStartState) {
          if (!state.endState) {
            throw new Error("IllegalState");
          }
          if (state.endState.startState) {
            throw new Error("IllegalState");
          }
          state.endState.startState = state;
        }
        if (state instanceof PlusLoopbackState) {
          for (j = 0; j < state.transitions.length; j++) {
            target = state.transitions[j].target;
            if (target instanceof PlusBlockStartState) {
              target.loopBackState = state;
            }
          }
        } else if (state instanceof StarLoopbackState) {
          for (j = 0; j < state.transitions.length; j++) {
            target = state.transitions[j].target;
            if (target instanceof StarLoopEntryState) {
              target.loopBackState = state;
            }
          }
        }
      }
    }
    readDecisions(atn) {
      const decisionCount = this.data[this.pos++];
      for (let i = 0; i < decisionCount; i++) {
        const s = this.data[this.pos++];
        const decState = atn.states[s];
        atn.decisionToState.push(decState);
        decState.decision = i;
      }
    }
    readLexerActions(atn) {
      if (atn.grammarType === ATN.LEXER) {
        const count = this.data[this.pos++];
        atn.lexerActions = [];
        for (let i = 0; i < count; i++) {
          const actionType = this.data[this.pos++];
          const data1 = this.data[this.pos++];
          const data2 = this.data[this.pos++];
          atn.lexerActions.push(this.lexerActionFactory(actionType, data1, data2));
        }
      }
    }
    generateRuleBypassTransitions(atn) {
      let i;
      const count = atn.ruleToStartState.length;
      for (i = 0; i < count; i++) {
        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
      }
      for (i = 0; i < count; i++) {
        this.generateRuleBypassTransition(atn, i);
      }
    }
    generateRuleBypassTransition(atn, idx) {
      let i;
      let state;
      const bypassStart = new BasicBlockStartState();
      bypassStart.ruleIndex = idx;
      atn.addState(bypassStart);
      const bypassStop = new BlockEndState();
      bypassStop.ruleIndex = idx;
      atn.addState(bypassStop);
      bypassStart.endState = bypassStop;
      atn.defineDecisionState(bypassStart);
      bypassStop.startState = bypassStart;
      let excludeTransition = null;
      let endState = null;
      if (atn.ruleToStartState[idx].isLeftRecursiveRule) {
        endState = null;
        for (i = 0; i < atn.states.length; i++) {
          state = atn.states[i];
          if (this.stateIsEndStateFor(state, idx)) {
            endState = state;
            excludeTransition = state.loopBackState.transitions[0];
            break;
          }
        }
        if (excludeTransition === null) {
          throw new Error("Couldn't identify final state of the precedence rule prefix section.");
        }
      } else {
        endState = atn.ruleToStopState[idx];
      }
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        for (const transition of state.transitions) {
          if (transition === excludeTransition) {
            continue;
          }
          if (transition.target === endState) {
            transition.target = bypassStop;
          }
        }
      }
      const ruleToStartState = atn.ruleToStartState[idx];
      const count = ruleToStartState.transitions.length;
      while (count > 0) {
        bypassStart.addTransition(ruleToStartState.transitions[count - 1]);
        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
      }
      atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
      if (endState) {
        bypassStop.addTransition(new EpsilonTransition(endState));
      }
      const matchState = new BasicState();
      atn.addState(matchState);
      matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
      bypassStart.addTransition(new EpsilonTransition(matchState));
    }
    stateIsEndStateFor(state, idx) {
      if (state.ruleIndex !== idx) {
        return null;
      }
      if (!(state instanceof StarLoopEntryState)) {
        return null;
      }
      const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
      if (!(maybeLoopEndState instanceof LoopEndState)) {
        return null;
      }
      if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
        return state;
      } else {
        return null;
      }
    }
    /**
     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
     * the {@link StarLoopEntryState} field to the correct value.
     *
     * @param atn The ATN.
     */
    markPrecedenceDecisions(atn) {
      for (const state of atn.states) {
        if (!(state instanceof StarLoopEntryState)) {
          continue;
        }
        if (atn.ruleToStartState[state.ruleIndex].isLeftRecursiveRule) {
          const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
          if (maybeLoopEndState instanceof LoopEndState) {
            if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
              state.precedenceRuleDecision = true;
            }
          }
        }
      }
    }
    verifyATN(atn) {
      if (!this.deserializationOptions.verifyATN) {
        return;
      }
      for (const state of atn.states) {
        if (state === null) {
          continue;
        }
        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
        if (state instanceof PlusBlockStartState) {
          this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof StarLoopEntryState) {
          this.checkCondition(state.loopBackState !== null);
          this.checkCondition(state.transitions.length === 2);
          if (state.transitions[0].target instanceof StarBlockStartState) {
            this.checkCondition(state.transitions[1].target instanceof LoopEndState);
            this.checkCondition(!state.nonGreedy);
          } else if (state.transitions[0].target instanceof LoopEndState) {
            this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
            this.checkCondition(state.nonGreedy);
          } else {
            throw new Error("IllegalState");
          }
        } else if (state instanceof StarLoopbackState) {
          this.checkCondition(state.transitions.length === 1);
          this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
        } else if (state instanceof LoopEndState) {
          this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof RuleStartState) {
          this.checkCondition(state.stopState !== null);
        } else if (state instanceof BlockStartState) {
          this.checkCondition(state.endState !== null);
        } else if (state instanceof BlockEndState) {
          this.checkCondition(state.startState !== null);
        } else if (state instanceof DecisionState) {
          this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
        } else {
          this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
        }
      }
    }
    checkCondition(condition, message) {
      if (!condition) {
        if (message === void 0 || message === null) {
          message = "IllegalState";
        }
        throw message;
      }
    }
    edgeFactory(atn, type, trg, arg1, arg2, arg3, sets) {
      const target = atn.states[trg];
      switch (type) {
        case Transition.EPSILON:
          return new EpsilonTransition(target);
        case Transition.RANGE:
          return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
        case Transition.RULE:
          return new RuleTransition(atn.states[arg1], arg2, arg3, target);
        case Transition.PREDICATE:
          return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
        case Transition.PRECEDENCE:
          return new PrecedencePredicateTransition(target, arg1);
        case Transition.ATOM:
          return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
        case Transition.ACTION:
          return new ActionTransition(target, arg1, arg2, arg3 !== 0);
        case Transition.SET:
          return new SetTransition(target, sets[arg1]);
        case Transition.NOT_SET:
          return new NotSetTransition(target, sets[arg1]);
        case Transition.WILDCARD:
          return new WildcardTransition(target);
        default:
          throw new Error("The specified transition type: " + type + " is not valid.");
      }
    }
    stateFactory(type, ruleIndex) {
      const ctor = _ATNDeserializer.stateTypeMapper.get(type);
      if (!ctor) {
        throw new Error("The specified state type " + type + " is not valid.");
      }
      const s = new ctor();
      s.ruleIndex = ruleIndex;
      return s;
    }
    lexerActionFactory(type, data1, data2) {
      const factory = _ATNDeserializer.lexerActionFactoryMapper.get(type);
      if (!factory) {
        throw new Error("The specified lexer action type " + type + " is not valid.");
      }
      return factory(data1, data2);
    }
  };
  var OrderedHashMap = class _OrderedHashMap extends HashMap {
    static {
      __name(this, "OrderedHashMap");
    }
    #keys = [];
    clear() {
      super.clear();
      this.#keys = [];
    }
    get(key) {
      return super.get(key);
    }
    set(key, value) {
      const result = super.set(key, value);
      if (result === void 0) {
        this.#keys.push(key);
      }
      return result;
    }
    setIfAbsent(key, value) {
      const result = super.setIfAbsent(key, value);
      if (result === void 0) {
        this.#keys.push(key);
      }
      return result;
    }
    /**
     * @returns an iterable of the values in the map, in the order they were inserted.
     */
    values() {
      return {
        [Symbol.iterator]: () => {
          let index = 0;
          return {
            next: /* @__PURE__ */ __name(() => {
              if (index < this.#keys.length) {
                return {
                  done: false,
                  value: super.get(this.#keys[index++])
                };
              }
              return {
                done: true,
                value: void 0
              };
            }, "next")
          };
        }
      };
    }
    /**
     * @returns an iterable of the keys in the map, in the order they were inserted.
     */
    keys() {
      return this.#keys[Symbol.iterator]();
    }
    equals(o) {
      if (!(o instanceof _OrderedHashMap)) {
        return false;
      }
      return super.equals(o);
    }
  };
  var ATNSerializer = class _ATNSerializer {
    static {
      __name(this, "ATNSerializer");
    }
    atn;
    data = [];
    // Note that we use a LinkedHashMap as a set to maintain insertion order while deduplicating entries with the
    // same key.
    sets = new OrderedHashMap(ObjectEqualityComparator.instance);
    nonGreedyStates = [];
    precedenceStates = [];
    constructor(atn) {
      this.atn = atn;
    }
    static getSerialized(atn) {
      return new _ATNSerializer(atn).serialize();
    }
    static serializeSets(data, sets) {
      data.push(sets.length);
      for (const set of sets) {
        const containsEof = set.contains(Token.EOF);
        const intervals = [...set];
        if (containsEof && intervals[0].stop === Token.EOF) {
          data.push(intervals.length - 1);
        } else {
          data.push(intervals.length);
        }
        data.push(containsEof ? 1 : 0);
        for (const interval of intervals) {
          if (interval.start === Token.EOF) {
            if (interval.stop === Token.EOF) {
              continue;
            } else {
              data.push(0);
            }
          } else {
            data.push(interval.start);
          }
          data.push(interval.stop);
        }
      }
    }
    /**
     * Serialize state descriptors, edge descriptors, and decision -> state map
     *  into list of ints.  Likely out of date, but keeping as it could be helpful:
     *
     *      SERIALIZED_VERSION
     *      UUID (2 longs)
     * 		grammar-type, (ANTLRParser.LEXER, ...)
     *  	max token type,
     *  	num states,
     *  	state-0-type ruleIndex, state-1-type ruleIndex, ... state-i-type ruleIndex optional-arg ...
     *  	num rules,
     *  	rule-1-start-state rule-1-args, rule-2-start-state  rule-2-args, ...
     *  	(args are token type,actionIndex in lexer else 0,0)
     *      num modes,
     *      mode-0-start-state, mode-1-start-state, ... (parser has 0 modes)
     *      num unicode-bmp-sets
     *      bmp-set-0-interval-count intervals, bmp-set-1-interval-count intervals, ...
     *      num unicode-smp-sets
     *      smp-set-0-interval-count intervals, smp-set-1-interval-count intervals, ...
     *	num total edges,
     *      src, trg, edge-type, edge arg1, optional edge arg2 (present always), ...
     *      num decisions,
     *      decision-0-start-state, decision-1-start-state, ...
     *
     *  Convenient to pack into unsigned shorts to make as Java string.
     */
    serialize() {
      this.addPreamble();
      const edgeCount = this.addEdges();
      this.addNonGreedyStates();
      this.addPrecedenceStates();
      this.addRuleStatesAndLexerTokenTypes();
      this.addModeStartStates();
      const setIndices = this.addSets();
      this.addEdges(edgeCount, setIndices);
      this.addDecisionStartStates();
      this.addLexerActions();
      return this.data;
    }
    addPreamble() {
      this.data.push(ATNDeserializer.SERIALIZED_VERSION);
      this.data.push(this.atn.grammarType);
      this.data.push(this.atn.maxTokenType);
    }
    addLexerActions() {
      if (this.atn.grammarType === ATN.LEXER) {
        this.data.push(this.atn.lexerActions.length);
        for (const action of this.atn.lexerActions) {
          this.data.push(action.actionType);
          switch (action.actionType) {
            case LexerActionType.CHANNEL: {
              const channel = action.channel;
              this.data.push(channel);
              this.data.push(0);
              break;
            }
            case LexerActionType.CUSTOM: {
              const ruleIndex = action.ruleIndex;
              const actionIndex = action.actionIndex;
              this.data.push(ruleIndex);
              this.data.push(actionIndex);
              break;
            }
            case LexerActionType.MODE: {
              const mode = action.mode;
              this.data.push(mode);
              this.data.push(0);
              break;
            }
            case LexerActionType.MORE: {
              this.data.push(0);
              this.data.push(0);
              break;
            }
            case LexerActionType.POP_MODE: {
              this.data.push(0);
              this.data.push(0);
              break;
            }
            case LexerActionType.PUSH_MODE: {
              const mode = action.mode;
              this.data.push(mode);
              this.data.push(0);
              break;
            }
            case LexerActionType.SKIP: {
              this.data.push(0);
              this.data.push(0);
              break;
            }
            case LexerActionType.TYPE: {
              const type = action.type;
              this.data.push(type);
              this.data.push(0);
              break;
            }
            default: {
              throw new Error(`The specified lexer action type ${action.actionType} is not valid.`);
            }
          }
        }
      }
    }
    addDecisionStartStates() {
      this.data.push(this.atn.decisionToState.length);
      for (const decStartState of this.atn.decisionToState) {
        this.data.push(decStartState.stateNumber);
      }
    }
    addEdges(...args) {
      switch (args.length) {
        case 0: {
          let edgeCount = 0;
          this.data.push(this.atn.states.length);
          let i = 0;
          for (const s of this.atn.states) {
            if (s === null) {
              this.data.push(ATNState.INVALID_TYPE);
              continue;
            }
            const stateType = s.constructor.stateType;
            if (s instanceof DecisionState && s.nonGreedy) {
              this.nonGreedyStates.push(s.stateNumber);
            }
            if (i === 910) {
              console.log("i", i);
            }
            if (s instanceof RuleStartState && s.isLeftRecursiveRule) {
              this.precedenceStates.push(s.stateNumber);
            }
            this.data.push(stateType);
            this.data.push(s.ruleIndex);
            if (s.constructor.stateType === ATNState.LOOP_END) {
              this.data.push(s.loopBackState.stateNumber);
            } else {
              if (s instanceof BlockStartState) {
                this.data.push(s.endState.stateNumber);
              }
            }
            if (s.constructor.stateType !== ATNState.RULE_STOP) {
              edgeCount += s.transitions.length;
            }
            for (const t of s.transitions) {
              const edgeType = t.transitionType;
              if (edgeType === Transition.SET || edgeType === Transition.NOT_SET) {
                const st = t;
                this.sets.set(st.set, true);
              }
            }
            ++i;
          }
          return edgeCount;
        }
        case 2: {
          const [edgeCount, setIndices] = args;
          this.data.push(edgeCount);
          for (const s of this.atn.states) {
            if (s === null) {
              continue;
            }
            if (s.constructor.stateType === ATNState.RULE_STOP) {
              continue;
            }
            for (const t of s.transitions) {
              if (this.atn.states[t.target.stateNumber] === null) {
                throw new Error("Cannot serialize a transition to a removed state.");
              }
              const src = s.stateNumber;
              let trg = t.target.stateNumber;
              const edgeType = t.transitionType;
              let arg1 = 0;
              let arg2 = 0;
              let arg3 = 0;
              switch (edgeType) {
                case Transition.RULE: {
                  trg = t.followState.stateNumber;
                  arg1 = t.target.stateNumber;
                  arg2 = t.ruleIndex;
                  arg3 = t.precedence;
                  break;
                }
                case Transition.PRECEDENCE: {
                  const ppt = t;
                  arg1 = ppt.precedence;
                  break;
                }
                case Transition.PREDICATE: {
                  const pt = t;
                  arg1 = pt.ruleIndex;
                  arg2 = pt.predIndex;
                  arg3 = pt.isCtxDependent ? 1 : 0;
                  break;
                }
                case Transition.RANGE: {
                  arg1 = t.start;
                  arg2 = t.stop;
                  if (arg1 === Token.EOF) {
                    arg1 = 0;
                    arg3 = 1;
                  }
                  break;
                }
                case Transition.ATOM: {
                  arg1 = t.labelValue;
                  if (arg1 === Token.EOF) {
                    arg1 = 0;
                    arg3 = 1;
                  }
                  break;
                }
                case Transition.ACTION: {
                  const at = t;
                  arg1 = at.ruleIndex;
                  arg2 = at.actionIndex;
                  arg3 = at.isCtxDependent ? 1 : 0;
                  break;
                }
                case Transition.SET: {
                  arg1 = setIndices.get(t.set);
                  break;
                }
                case Transition.NOT_SET: {
                  arg1 = setIndices.get(t.set);
                  break;
                }
                case Transition.WILDCARD: {
                  break;
                }
                default:
              }
              this.data.push(src);
              this.data.push(trg);
              this.data.push(edgeType);
              this.data.push(arg1);
              this.data.push(arg2);
              this.data.push(arg3);
            }
          }
          break;
        }
        default: {
          throw new Error("Invalid number of arguments");
        }
      }
    }
    addSets() {
      _ATNSerializer.serializeSets(this.data, [...this.sets.keys()]);
      const setIndices = new HashMap();
      let setIndex = 0;
      for (const s of this.sets.keys()) {
        setIndices.set(s, setIndex++);
      }
      return setIndices;
    }
    addModeStartStates() {
      const modeCount = this.atn.modeToStartState.length;
      this.data.push(modeCount);
      if (modeCount > 0) {
        for (const modeStartState of this.atn.modeToStartState) {
          this.data.push(modeStartState.stateNumber);
        }
      }
    }
    addRuleStatesAndLexerTokenTypes() {
      const ruleCount = this.atn.ruleToStartState.length;
      this.data.push(ruleCount);
      for (let r = 0; r < ruleCount; r++) {
        const ruleStartState = this.atn.ruleToStartState[r];
        this.data.push(ruleStartState.stateNumber);
        if (this.atn.grammarType === ATN.LEXER) {
          this.data.push(this.atn.ruleToTokenType[r]);
        }
      }
    }
    addPrecedenceStates() {
      this.data.push(this.precedenceStates.length);
      for (const state of this.precedenceStates) {
        this.data.push(state);
      }
    }
    addNonGreedyStates() {
      this.data.push(this.nonGreedyStates.length);
      for (const state of this.nonGreedyStates) {
        this.data.push(state);
      }
    }
  };
  var DFAState = class _DFAState {
    static {
      __name(this, "DFAState");
    }
    stateNumber = -1;
    configs;
    /**
     * `edges[symbol]` points to target of symbol. Shift up by 1 so (-1) {@link Token.EOF} maps to `edges[0]`.
     */
    edges = [];
    isAcceptState = false;
    /**
     * If accept state, what ttype do we match or alt do we predict? This is set to {@link ATN.INVALID_ALT_NUMBER}
     * when {@link predicates} `!= null` or {@link requiresFullContext}.
     */
    prediction = -1;
    lexerActionExecutor = null;
    /**
     * Indicates that this state was created during SLL prediction that discovered a conflict between the configurations
     * in the state. Future {@link ParserATNSimulator.execATN} invocations immediately jumped doing
     * full context prediction if this field is true.
     */
    requiresFullContext = false;
    /**
     * During SLL parsing, this is a list of predicates associated with the ATN configurations of the DFA state.
     * When we have predicates, {@link requiresFullContext} is `false` since full context prediction evaluates
     * predicates on-the-fly. If this is not null, then {@link prediction} is `ATN.INVALID_ALT_NUMBER`.
     *
     * We only use these for non-{@link #requiresFullContext} but conflicting states. That
     * means we know from the context (it's $ or we don't dip into outer
     * context) that it's an ambiguity not a conflict.
     *
     * This list is computed by {@link ParserATNSimulator#predicateDFAState}.
     */
    predicates = null;
    constructor(configs) {
      if (configs) {
        this.configs = configs;
      }
    }
    static fromState(stateNumber) {
      const result = new _DFAState();
      result.stateNumber = stateNumber;
      return result;
    }
    static fromConfigs(configs) {
      return new _DFAState(configs);
    }
    static hashCode(state) {
      return state.configs.hashCode();
    }
    /**
     * Two {@link DFAState} instances are equal if their ATN configuration sets
     * are the same. This method is used to see if a state already exists.
     *
     * Because the number of alternatives and number of ATN configurations are
     * finite, there is a finite number of DFA states that can be processed.
     * This is necessary to show that the algorithm terminates.
     *
     * Cannot test the DFA state numbers here because in
     * {@link ParserATNSimulator#addDFAState} we need to know if any other state
     * exists that has this exact set of ATN configurations. The
     * {@link #stateNumber} is irrelevant.
     *
     * @param a The first {@link DFAState}.
     * @param b The second {@link DFAState}.
     *
     * @returns `true` if the two states are equal, otherwise `false`.
     */
    static equals(a, b) {
      return a.configs.equals(b.configs);
    }
    /**
     * @returns the set of all alts mentioned by all ATN configurations in this DFA state.
     */
    getAltSet() {
      const alts = /* @__PURE__ */ new Set();
      for (const config of this.configs) {
        alts.add(config.alt);
      }
      if (alts.size === 0) {
        return null;
      }
      return alts;
    }
    toString() {
      let buf = "";
      buf += this.stateNumber;
      buf += ":";
      buf += this.configs ? this.configs.toString() : "";
      if (this.isAcceptState) {
        buf += "=>";
        if (this.predicates) {
          buf += arrayToString(this.predicates);
        } else {
          buf += this.prediction;
        }
      }
      return buf.toString();
    }
  };
  var ATNSimulator = class {
    static {
      __name(this, "ATNSimulator");
    }
    /** Must distinguish between missing edge and edge we know leads nowhere */
    static ERROR = DFAState.fromState(2147483647);
    atn;
    /**
     * The context cache maps all PredictionContext objects that are ==
     * to a single cached copy. This cache is shared across all contexts
     * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
     * to use only cached nodes/graphs in addDFAState(). We don't want to
     * fill this during closure() since there are lots of contexts that
     * pop up but are not used ever again. It also greatly slows down closure().
     *
     * This cache makes a huge difference in memory and a little bit in speed.
     * For the Java grammar on java.*, it dropped the memory requirements
     * at the end from 25M to 16M. We don't store any of the full context
     * graphs in the DFA because they are limited to local context only,
     * but apparently there's a lot of repetition there as well. We optimize
     * the config contexts before storing the config set in the DFA states
     * by literally rebuilding them with cached subgraphs only.
     *
     * I tried a cache for use during closure operations, that was
     * whacked after each adaptivePredict(). It cost a little bit
     * more time I think and doesn't save on the overall footprint
     * so it's not worth the complexity.
     */
    sharedContextCache;
    constructor(atn, sharedContextCache) {
      this.atn = atn;
      this.sharedContextCache = sharedContextCache;
      return this;
    }
    getCachedContext(context) {
      if (!this.sharedContextCache) {
        return context;
      }
      const visited = new HashMap(ObjectEqualityComparator.instance);
      return getCachedPredictionContext(context, this.sharedContextCache, visited);
    }
  };
  var CodePointTransitions = class _CodePointTransitions {
    static {
      __name(this, "CodePointTransitions");
    }
    /** @returns new {@link AtomTransition}     */
    static createWithCodePoint(target, codePoint) {
      return _CodePointTransitions.createWithCodePointRange(target, codePoint, codePoint);
    }
    /** @returns new {@link AtomTransition} if range represents one atom else {@link SetTransition}. */
    static createWithCodePointRange(target, codePointFrom, codePointTo) {
      return codePointFrom === codePointTo ? new AtomTransition(target, codePointFrom) : new RangeTransition(target, codePointFrom, codePointTo);
    }
  };
  var DecisionInfo = class {
    static {
      __name(this, "DecisionInfo");
    }
    /**
     * The decision number, which is an index into {@link ATN.decisionToState}.
     */
    decision = 0;
    /**
     * The total number of times {@link ParserATNSimulator.adaptivePredict} was
     * invoked for this decision.
     */
    invocations = 0;
    /**
     * The total time spent in {@link ParserATNSimulator.adaptivePredict} for
     * this decision, in nanoseconds.
     *
     * The value of this field contains the sum of differential results obtained
     * by {@link process.hrtime()}, and is not adjusted to compensate for JIT
     * and/or garbage collection overhead. For best accuracy, use a modern Node.js
     * version that provides precise results from {@link process.hrtime()}, and
     * perform profiling in a separate process which is warmed up by parsing the
     * input prior to profiling.
     */
    timeInPrediction = 0;
    /**
     * The sum of the lookahead required for SLL prediction for this decision.
     * Note that SLL prediction is used before LL prediction for performance
     * reasons even when {@link PredictionMode.LL} or
     * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION} is used.
     */
    sllTotalLook = 0;
    /**
     * Gets the minimum lookahead required for any single SLL prediction to
     * complete for this decision, by reaching a unique prediction, reaching an
     * SLL conflict state, or encountering a syntax error.
     */
    sllMinLook = 0;
    /**
     * Gets the maximum lookahead required for any single SLL prediction to
     * complete for this decision, by reaching a unique prediction, reaching an
     * SLL conflict state, or encountering a syntax error.
     */
    sllMaxLook = 0;
    /**
     * Gets the {@link LookaheadEventInfo} associated with the event where the
     * {@link sllMaxLook} value was set.
     */
    sllMaxLookEvent;
    /**
     * The sum of the lookahead required for LL prediction for this decision.
     * Note that LL prediction is only used when SLL prediction reaches a
     * conflict state.
     */
    llTotalLook = 0;
    /**
     * Gets the minimum lookahead required for any single LL prediction to
     * complete for this decision. An LL prediction completes when the algorithm
     * reaches a unique prediction, a conflict state (for
     * {@link PredictionMode.LL}, an ambiguity state (for
     * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.
     */
    llMinLook = 0;
    /**
     * Gets the maximum lookahead required for any single LL prediction to
     * complete for this decision. An LL prediction completes when the algorithm
     * reaches a unique prediction, a conflict state (for
     * {@link PredictionMode.LL}, an ambiguity state (for
     * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.
     */
    llMaxLook = 0;
    /**
     * Gets the {@link LookaheadEventInfo} associated with the event where the
     * {@link llMaxLook} value was set.
     */
    llMaxLookEvent;
    /**
     * A collection of {@link ContextSensitivityInfo} instances describing the
     * context sensitivities encountered during LL prediction for this decision.
     */
    contextSensitivities;
    /**
     * A collection of {@link DecisionEventInfo} instances describing the parse errors
     * identified during calls to {@link ParserATNSimulator.adaptivePredict} for
     * this decision.
     */
    errors;
    /**
     * A collection of {@link AmbiguityInfo} instances describing the
     * ambiguities encountered during LL prediction for this decision.
     */
    ambiguities;
    /**
     * A collection of {@link PredicateEvalInfo} instances describing the
     * results of evaluating individual predicates during prediction for this
     * decision.
     */
    predicateEvals;
    /**
     * The total number of ATN transitions required during SLL prediction for
     * this decision. An ATN transition is determined by the number of times the
     * DFA does not contain an edge that is required for prediction, resulting
     * in on-the-fly computation of that edge.
    /**
     * If DFA caching of SLL transitions is employed by the implementation, ATN
     * computation may cache the computed edge for efficient lookup during
     * future parsing of this decision. Otherwise, the SLL parsing algorithm
     * will use ATN transitions exclusively.
     *
     * @see sllDFATransitions
     * @see ParserATNSimulator.computeTargetState
     * @see LexerATNSimulator.computeTargetState
     */
    sllATNTransitions = 0;
    /**
     * The total number of DFA transitions required during SLL prediction for
     * this decision.
     *
     * If the ATN simulator implementation does not use DFA caching for SLL
     * transitions, this value will be 0.
     *
     * @see ParserATNSimulator.getExistingTargetState
     * @see LexerATNSimulator.getExistingTargetState
     */
    sllDFATransitions = 0;
    /**
     * Gets the total number of times SLL prediction completed in a conflict
     * state, resulting in fallback to LL prediction.
     *
     * Note that this value is not related to whether or not
     * {@link PredictionMode.SLL} may be used successfully with a particular
     * grammar. If the ambiguity resolution algorithm applied to the SLL
     * conflicts for this decision produce the same result as LL prediction for
     * this decision, {@link PredictionMode.SLL} would produce the same overall
     * parsing result as {@link PredictionMode.LL}.
     */
    llFallback = 0;
    /**
     * The total number of ATN transitions required during LL prediction for
     * this decision. An ATN transition is determined by the number of times the
     * DFA does not contain an edge that is required for prediction, resulting
     * in on-the-fly computation of that edge.
     *
     * If DFA caching of LL transitions is employed by the implementation, ATN
     * computation may cache the computed edge for efficient lookup during
     * future parsing of this decision. Otherwise, the LL parsing algorithm will
     * use ATN transitions exclusively.
     *
     * @see llDFATransitions
     * @see ParserATNSimulator.computeTargetState
     * @see LexerATNSimulator.computeTargetState
     */
    llATNTransitions = 0;
    /**
     * The total number of DFA transitions required during LL prediction for
     * this decision.
     *
     * If the ATN simulator implementation does not use DFA caching for LL
     * transitions, this value will be 0.
     *
     * @see ParserATNSimulator.getExistingTargetState
     * @see LexerATNSimulator.getExistingTargetState
     */
    llDFATransitions = 0;
    /**
     * Constructs a new instance of the {@link DecisionInfo} class to contain
     * statistics for a particular decision.
     *
     * @param decision The decision number
     */
    constructor(decision) {
      this.decision = decision;
      this.contextSensitivities = [];
      this.errors = [];
      this.ambiguities = [];
      this.predicateEvals = [];
    }
    toString1() {
      return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", sllLookahead=" + this.sllTotalLook + ", sllATNTransitions=" + this.sllATNTransitions + ", sllDFATransitions=" + this.sllDFATransitions + ", llFallback=" + this.llFallback + ", llLookahead=" + this.llTotalLook + ", llATNTransitions=" + this.llATNTransitions + "}";
    }
  };
  var LexerATNConfig = class _LexerATNConfig extends ATNConfig {
    static {
      __name(this, "LexerATNConfig");
    }
    /**
     * This is the backing field for {@link #getLexerActionExecutor}.
     */
    lexerActionExecutor;
    passedThroughNonGreedyDecision;
    constructor(config, state, context, lexerActionExecutor) {
      super(config, state, context ?? config.context, context ? SemanticContext.NONE : config.semanticContext);
      this.lexerActionExecutor = context ? lexerActionExecutor : config.lexerActionExecutor ?? null;
      this.passedThroughNonGreedyDecision = _LexerATNConfig.checkNonGreedyDecision(config, this.state);
      return this;
    }
    static createWithExecutor(config, state, lexerActionExecutor) {
      return new _LexerATNConfig(config, state, config.context, lexerActionExecutor);
    }
    static createWithConfig(state, config, context) {
      return new _LexerATNConfig(config, state, context ?? null, config.lexerActionExecutor);
    }
    static createWithContext(state, alt, context) {
      return new _LexerATNConfig({ alt }, state, context, null);
    }
    static checkNonGreedyDecision(source, target) {
      return source.passedThroughNonGreedyDecision || "nonGreedy" in target && target.nonGreedy;
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hashCode = MurmurHash.initialize(7);
        hashCode = MurmurHash.update(hashCode, this.state.stateNumber);
        hashCode = MurmurHash.update(hashCode, this.alt);
        hashCode = MurmurHash.updateFromComparable(hashCode, this.context);
        hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);
        hashCode = MurmurHash.update(hashCode, this.passedThroughNonGreedyDecision ? 1 : 0);
        hashCode = MurmurHash.updateFromComparable(hashCode, this.lexerActionExecutor);
        hashCode = MurmurHash.finish(hashCode, 6);
        this.cachedHashCode = hashCode;
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      return this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor && other.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
    }
  };
  var BaseErrorListener = class {
    static {
      __name(this, "BaseErrorListener");
    }
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    }
  };
  var ConsoleErrorListener = class _ConsoleErrorListener extends BaseErrorListener {
    static {
      __name(this, "ConsoleErrorListener");
    }
    /**
     * Provides a default instance of {@link ConsoleErrorListener}.
     */
    static instance = new _ConsoleErrorListener();
    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, _e) {
      console.error("line " + line + ":" + charPositionInLine + " " + msg);
    }
  };
  var ProxyErrorListener = class extends BaseErrorListener {
    constructor(delegates) {
      super();
      this.delegates = delegates;
      return this;
    }
    static {
      __name(this, "ProxyErrorListener");
    }
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
      this.delegates.forEach((d) => {
        d.syntaxError(recognizer, offendingSymbol, line, column, msg, e);
      });
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      this.delegates.forEach((d) => {
        d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
      });
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
      this.delegates.forEach((d) => {
        d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs);
      });
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
      this.delegates.forEach((d) => {
        d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs);
      });
    }
  };
  var Recognizer = class _Recognizer {
    static {
      __name(this, "Recognizer");
    }
    static EOF = -1;
    static tokenTypeMapCache = /* @__PURE__ */ new Map();
    static ruleIndexMapCache = /* @__PURE__ */ new Map();
    interpreter;
    listeners = [ConsoleErrorListener.instance];
    stateNumber = -1;
    checkVersion(toolVersion) {
      const runtimeVersion = "4.13.1";
      if (runtimeVersion !== toolVersion) {
        console.error("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
      }
    }
    addErrorListener(listener) {
      this.listeners.push(listener);
    }
    removeErrorListeners() {
      this.listeners = [];
    }
    removeErrorListener(listener) {
      for (let i = 0; i < this.listeners.length; i++) {
        if (this.listeners[i] === listener) {
          this.listeners.splice(i, 1);
          return;
        }
      }
    }
    getErrorListeners() {
      return this.listeners;
    }
    getTokenTypeMap() {
      const vocabulary = this.vocabulary;
      let result = _Recognizer.tokenTypeMapCache.get(vocabulary);
      if (!result) {
        result = /* @__PURE__ */ new Map();
        for (let i = 0; i <= this.atn.maxTokenType; i++) {
          const literalName = vocabulary.getLiteralName(i);
          if (literalName) {
            result.set(literalName, i);
          }
          const symbolicName = vocabulary.getSymbolicName(i);
          if (symbolicName) {
            result.set(symbolicName, i);
          }
        }
        result.set("EOF", Token.EOF);
        _Recognizer.tokenTypeMapCache.set(vocabulary, result);
      }
      return result;
    }
    /**
     * Get a map from rule names to rule indexes.
     * Used for XPath and tree pattern compilation.
     */
    getRuleIndexMap() {
      const ruleNames = this.ruleNames;
      let result = _Recognizer.ruleIndexMapCache.get(ruleNames);
      if (!result) {
        result = /* @__PURE__ */ new Map();
        ruleNames.forEach((ruleName, idx) => {
          return result.set(ruleName, idx);
        });
        _Recognizer.ruleIndexMapCache.set(ruleNames, result);
      }
      return result;
    }
    getTokenType(tokenName) {
      const ttype = this.getTokenTypeMap().get(tokenName);
      if (ttype) {
        return ttype;
      }
      return Token.INVALID_TYPE;
    }
    /** What is the error header, normally line/character position information? */
    getErrorHeader(e) {
      const line = e.offendingToken?.line;
      const column = e.offendingToken?.column;
      return "line " + line + ":" + column;
    }
    get errorListenerDispatch() {
      return new ProxyErrorListener(this.listeners);
    }
    /**
     * subclass needs to override these if there are semantic predicates or actions
     * that the ATN interp needs to execute
     */
    sempred(_localctx, _ruleIndex, _actionIndex) {
      return true;
    }
    // TODO: make localCtx an optional parameter, not optional null.
    precpred(_localctx, _precedence) {
      return true;
    }
    action(_localctx, _ruleIndex, _actionIndex) {
    }
    get atn() {
      return this.interpreter.atn;
    }
    get state() {
      return this.stateNumber;
    }
    set state(state) {
      this.stateNumber = state;
    }
    getSerializedATN() {
      throw new Error("there is no serialized ATN");
    }
    getParseInfo() {
      return void 0;
    }
  };
  var CommonTokenFactory = class _CommonTokenFactory {
    static {
      __name(this, "CommonTokenFactory");
    }
    /**
     * The default {@link CommonTokenFactory} instance.
     *
     *
     * This token factory does not explicitly copy token text when constructing
     * tokens.
     */
    static DEFAULT = new _CommonTokenFactory();
    /**
     * Indicates whether {@link CommonToken.setText} should be called after
     * constructing tokens to explicitly set the text. This is useful for cases
     * where the input stream might not be able to provide arbitrary substrings
     * of text from the input after the lexer creates a token (e.g. the
     * implementation of {@link CharStream.getText} in
     * {@link UnbufferedCharStream} throws an
     * {@link UnsupportedOperationException}). Explicitly setting the token text
     * allows {@link Token.getText} to be called at any time regardless of the
     * input stream implementation.
     *
     *
     * The default value is `false` to avoid the performance and memory
     * overhead of copying text for every token unless explicitly requested.
     */
    copyText = false;
    constructor(copyText) {
      this.copyText = copyText ?? false;
    }
    create(source, type, text, channel, start, stop, line, column) {
      const t = CommonToken.fromSource(source, type, channel, start, stop);
      t.line = line;
      t.column = column;
      if (text) {
        t.text = text;
      } else if (this.copyText && source[1] !== null) {
        t.text = source[1].getTextFromRange(start, stop);
      }
      return t;
    }
  };
  var RecognitionException = class _RecognitionException extends Error {
    static {
      __name(this, "RecognitionException");
    }
    ctx;
    /**
     * The current {@link Token} when an error occurred. Since not all streams
     * support accessing symbols by index, we have to track the {@link Token}
     * instance itself
     */
    offendingToken = null;
    /**
     * Get the ATN state number the parser was in at the time the error
     * occurred. For {@link NoViableAltException} and
     * {@link LexerNoViableAltException} exceptions, this is the
     * {@link DecisionState} number. For others, it is the state whose outgoing
     * edge we couldn't match.
     */
    offendingState = -1;
    recognizer;
    input;
    constructor(params) {
      super(params.message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, _RecognitionException);
      }
      this.message = params.message;
      this.recognizer = params.recognizer;
      this.input = params.input;
      this.ctx = params.ctx;
      if (this.recognizer !== null) {
        this.offendingState = this.recognizer.state;
      }
    }
    /**
     * Gets the set of input symbols which could potentially follow the
     * previously matched symbol at the time this exception was thrown.
     *
     * If the set of expected tokens is not known and could not be computed,
     * this method returns `null`.
     *
     * @returns The set of token types that could potentially follow the current
     * state in the ATN, or `null` if the information is not available.
     */
    getExpectedTokens() {
      if (this.recognizer !== null && this.ctx !== null) {
        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
      } else {
        return null;
      }
    }
    // If the state number is not known, this method returns -1.
    toString() {
      return this.message;
    }
  };
  var LexerNoViableAltException = class extends RecognitionException {
    static {
      __name(this, "LexerNoViableAltException");
    }
    startIndex;
    deadEndConfigs;
    constructor(lexer, input, startIndex, deadEndConfigs) {
      super({ message: "", recognizer: lexer, input, ctx: null });
      this.startIndex = startIndex;
      this.deadEndConfigs = deadEndConfigs;
    }
    toString() {
      let symbol = "";
      if (this.input && this.startIndex >= 0 && this.startIndex < this.input.size) {
        symbol = this.input.getTextFromRange(this.startIndex, this.startIndex);
      }
      return `LexerNoViableAltException(${symbol})`;
    }
  };
  var Lexer = class _Lexer extends Recognizer {
    static {
      __name(this, "Lexer");
    }
    static DEFAULT_MODE = 0;
    static MORE = -2;
    static SKIP = -3;
    static DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
    static HIDDEN = Token.HIDDEN_CHANNEL;
    options = {
      minDFAEdge: 0,
      maxDFAEdge: 256,
      minCodePoint: 0,
      maxCodePoint: 1114111
    };
    /**
     * What character index in the stream did the current token start at?
     *  Needed, for example, to get the text for current token.  Set at
     *  the start of nextToken.
     */
    tokenStartCharIndex = -1;
    /** The channel number for the current token */
    channel = 0;
    /** The token type for the current token */
    type = 0;
    mode = _Lexer.DEFAULT_MODE;
    /** The start column of the current token (the one that was last read by `nextToken`). */
    currentTokenColumn = 0;
    /**
     * The line on which the first character of the current token (the one that was last read by `nextToken`) resides.
     */
    currentTokenStartLine = 0;
    input;
    /**
     * The goal of all lexer rules/methods is to create a token object.
     *  This is an instance variable as multiple rules may collaborate to
     *  create a single token.  nextToken will return this object after
     *  matching lexer rule(s).  If you subclass to allow multiple token
     *  emissions, then set this to the last token to be matched or
     *  something non-null so that the auto token emit mechanism will not
     *  emit another token.
     */
    token = null;
    /**
     * Once we see EOF on char stream, next token will be EOF.
     * If you have DONE : EOF ; then you see DONE EOF.
     */
    hitEOF = false;
    factory;
    #modeStack = [];
    /**
     * The text to be used for the next token. If this is not null, then the text
     * for the next token is fixed and is not subject to change in the normal
     * workflow of the lexer.
     */
    #text;
    constructor(input, options) {
      super();
      this.options = { ...this.options, ...options };
      this.input = input;
      this.factory = CommonTokenFactory.DEFAULT;
    }
    reset(seekBack = true) {
      if (seekBack) {
        this.input.seek(0);
      }
      this.token = null;
      this.type = Token.INVALID_TYPE;
      this.channel = Token.DEFAULT_CHANNEL;
      this.tokenStartCharIndex = -1;
      this.currentTokenColumn = -1;
      this.currentTokenStartLine = -1;
      this.#text = void 0;
      this.hitEOF = false;
      this.mode = _Lexer.DEFAULT_MODE;
      this.#modeStack = [];
      this.interpreter.reset();
    }
    /** @returns a token from this source; i.e., match a token on the char stream. */
    nextToken() {
      if (this.input === null) {
        throw new Error("nextToken requires a non-null input stream.");
      }
      const tokenStartMarker = this.input.mark();
      try {
        while (true) {
          if (this.hitEOF) {
            this.emitEOF();
            return this.token;
          }
          this.token = null;
          this.channel = Token.DEFAULT_CHANNEL;
          this.tokenStartCharIndex = this.input.index;
          this.currentTokenColumn = this.interpreter.column;
          this.currentTokenStartLine = this.interpreter.line;
          this.#text = void 0;
          let continueOuter = false;
          while (true) {
            this.type = Token.INVALID_TYPE;
            let ttype = _Lexer.SKIP;
            try {
              ttype = this.interpreter.match(this.input, this.mode);
            } catch (e) {
              if (e instanceof LexerNoViableAltException) {
                this.notifyListeners(e);
                this.recover(e);
              } else {
                throw e;
              }
            }
            if (this.input.LA(1) === Token.EOF) {
              this.hitEOF = true;
            }
            if (this.type === Token.INVALID_TYPE) {
              this.type = ttype;
            }
            if (this.type === _Lexer.SKIP) {
              continueOuter = true;
              break;
            }
            if (this.type !== _Lexer.MORE) {
              break;
            }
          }
          if (continueOuter) {
            continue;
          }
          if (this.token === null) {
            this.emit();
          }
          return this.token;
        }
      } finally {
        this.input.release(tokenStartMarker);
      }
    }
    /**
     * Instruct the lexer to skip creating a token for current lexer rule
     * and look for another token. nextToken() knows to keep looking when
     * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
     * if token==null at end of any token rule, it creates one for you
     * and emits it.
     */
    skip() {
      this.type = _Lexer.SKIP;
    }
    more() {
      this.type = _Lexer.MORE;
    }
    pushMode(m2) {
      if (LexerATNSimulator.debug) {
        console.log("pushMode " + m2);
      }
      this.#modeStack.push(this.mode);
      this.mode = m2;
    }
    popMode() {
      if (this.#modeStack.length === 0) {
        throw new Error("Empty Stack");
      }
      if (LexerATNSimulator.debug) {
        console.log("popMode back to " + this.#modeStack.slice(0, -1));
      }
      this.mode = this.#modeStack.pop();
      return this.mode;
    }
    get modeStack() {
      return this.#modeStack;
    }
    /**
     * By default does not support multiple emits per nextToken invocation
     * for efficiency reasons. Subclass and override this method, nextToken,
     * and getToken (to push tokens into a list and pull from that list
     * rather than a single variable as this implementation does).
     */
    emitToken(token) {
      this.token = token;
    }
    /**
     * The standard method called to automatically emit a token at the
     * outermost lexical rule. The token object should point into the
     * char buffer start..stop. If there is a text override in 'text',
     * use that to set the token's text. Override this method to emit
     * custom Token objects or provide a new factory.
     */
    emit() {
      const t = this.factory.create(
        [this, this.input],
        this.type,
        this.#text,
        this.channel,
        this.tokenStartCharIndex,
        this.getCharIndex() - 1,
        this.currentTokenStartLine,
        this.currentTokenColumn
      );
      this.emitToken(t);
      return t;
    }
    emitEOF() {
      const eof = this.factory.create(
        [this, this.input],
        Token.EOF,
        void 0,
        Token.DEFAULT_CHANNEL,
        this.input.index,
        this.input.index - 1,
        this.line,
        this.column
      );
      this.emitToken(eof);
      return eof;
    }
    /** What is the index of the current character of lookahead? */
    getCharIndex() {
      return this.input.index;
    }
    /**
     * Return a list of all Token objects in input char stream.
     * Forces load of all tokens. Does not include EOF token.
     */
    getAllTokens() {
      const tokens = [];
      let t = this.nextToken();
      while (t.type !== Token.EOF) {
        tokens.push(t);
        t = this.nextToken();
      }
      return tokens;
    }
    notifyListeners(e) {
      const start = this.tokenStartCharIndex;
      const stop = this.input.index;
      const text = this.input.getTextFromRange(start, stop);
      const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
      this.errorListenerDispatch.syntaxError(this, null, this.currentTokenStartLine, this.currentTokenColumn, msg, e);
    }
    getErrorDisplay(s) {
      return s;
    }
    getErrorDisplayForChar(c) {
      if (c.charCodeAt(0) === Token.EOF) {
        return "<EOF>";
      }
      if (c === "\n") {
        return "\\n";
      }
      if (c === "	") {
        return "\\t";
      }
      if (c === "\r") {
        return "\\r";
      }
      return c;
    }
    getCharErrorDisplay(c) {
      return "'" + this.getErrorDisplayForChar(c) + "'";
    }
    /**
     * Lexers can normally match any char in it's vocabulary after matching
     * a token, so do the easy thing and just kill a character and hope
     * it all works out. You can instead use the rule invocation stack
     * to do sophisticated error recovery if you are in a fragment rule.
     */
    recover(re) {
      if (this.input.LA(1) !== Token.EOF) {
        if (re instanceof LexerNoViableAltException) {
          this.interpreter.consume(this.input);
        } else {
          this.input.consume();
        }
      }
    }
    get inputStream() {
      return this.input;
    }
    set inputStream(input) {
      this.reset(false);
      this.input = input;
    }
    set tokenFactory(factory) {
      this.factory = factory;
    }
    get tokenFactory() {
      return this.factory;
    }
    get sourceName() {
      return this.input.getSourceName();
    }
    get line() {
      return this.interpreter.line;
    }
    set line(line) {
      this.interpreter.line = line;
    }
    get column() {
      return this.interpreter.column;
    }
    set column(column) {
      this.interpreter.column = column;
    }
    get text() {
      if (this.#text) {
        return this.#text;
      } else {
        return this.interpreter.getText(this.input);
      }
    }
    set text(text) {
      this.#text = text;
    }
  };
  var OrderedHashSet = class _OrderedHashSet extends HashSet {
    static {
      __name(this, "OrderedHashSet");
    }
    elements = [];
    getOrAdd(o) {
      const oldSize = this.size;
      const result = super.getOrAdd(o);
      if (this.size > oldSize) {
        this.elements.push(o);
      }
      return result;
    }
    equals(o) {
      if (!(o instanceof _OrderedHashSet)) {
        return false;
      }
      return super.equals(o);
    }
    clear() {
      super.clear();
      this.elements = [];
    }
    *[Symbol.iterator]() {
      yield* this.elements;
    }
    toArray() {
      return this.elements.slice(0);
    }
  };
  var OrderedATNConfigSet = class extends ATNConfigSet {
    static {
      __name(this, "OrderedATNConfigSet");
    }
    constructor() {
      super();
      this.configLookup = new OrderedHashSet();
    }
  };
  var LexerIndexedCustomAction = class _LexerIndexedCustomAction {
    static {
      __name(this, "LexerIndexedCustomAction");
    }
    offset;
    action;
    actionType;
    isPositionDependent = true;
    cachedHashCode;
    constructor(offset, action) {
      this.actionType = action.actionType;
      this.offset = offset;
      this.action = action;
    }
    /**
     * This method calls {@link execute} on the result of {@link getAction}
     * using the provided `lexer`.
     */
    execute(lexer) {
      this.action.execute(lexer);
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hash = MurmurHash.initialize();
        hash = MurmurHash.update(hash, this.offset);
        hash = MurmurHash.updateFromComparable(hash, this.action);
        this.cachedHashCode = MurmurHash.finish(hash, 2);
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (!(other instanceof _LexerIndexedCustomAction)) {
        return false;
      }
      return this.offset === other.offset && this.action === other.action;
    }
  };
  var LexerActionExecutor = class _LexerActionExecutor {
    static {
      __name(this, "LexerActionExecutor");
    }
    lexerActions;
    actionType;
    isPositionDependent = false;
    cachedHashCode;
    /**
     * Represents an executor for a sequence of lexer actions which traversed during
     * the matching operation of a lexer rule (token).
     *
     * The executor tracks position information for position-dependent lexer actions
     * efficiently, ensuring that actions appearing only at the end of the rule do
     * not cause bloating of the {@link DFA} created for the lexer.
     */
    constructor(lexerActions) {
      this.actionType = -1;
      this.lexerActions = lexerActions ?? [];
      return this;
    }
    /**
     * Creates a {@link LexerActionExecutor} which executes the actions for
     * the input `lexerActionExecutor` followed by a specified
     * `lexerAction`.
     *
     * @param lexerActionExecutor The executor for actions already traversed by
     * the lexer while matching a token within a particular
     * {@link LexerATNConfig}. If this is `null`, the method behaves as
     * though it were an empty executor.
     * @param lexerAction The lexer action to execute after the actions
     * specified in `lexerActionExecutor`.
     *
     * @returns {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
     * of `lexerActionExecutor` and `lexerAction`.
     */
    static append(lexerActionExecutor, lexerAction) {
      if (lexerActionExecutor === null) {
        return new _LexerActionExecutor([lexerAction]);
      }
      const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
      return new _LexerActionExecutor(lexerActions);
    }
    /**
     * Creates a {@link LexerActionExecutor} which encodes the current offset
     * for position-dependent lexer actions.
     *
     * Normally, when the executor encounters lexer actions where
     * {@link LexerAction//isPositionDependent} returns `true`, it calls
     * {@link IntStream.seek} on the input {@link CharStream} to set the input
     * position to the *end* of the current token. This behavior provides
     * for efficient DFA representation of lexer actions which appear at the end
     * of a lexer rule, even when the lexer rule matches a variable number of
     * characters.
     *
     * Prior to traversing a match transition in the ATN, the current offset
     * from the token start index is assigned to all position-dependent lexer
     * actions which have not already been assigned a fixed offset. By storing
     * the offsets relative to the token start index, the DFA representation of
     * lexer actions which appear in the middle of tokens remains efficient due
     * to sharing among tokens of the same length, regardless of their absolute
     * position in the input stream.
     *
     * If the current executor already has offsets assigned to all
     * position-dependent lexer actions, the method returns `this`.
     *
     * @param offset The current offset to assign to all position-dependent
     * lexer actions which do not already have offsets assigned.
     *
     * @returns {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
     * for all position-dependent lexer actions.
     */
    fixOffsetBeforeMatch(offset) {
      let updatedLexerActions = null;
      for (let i = 0; i < this.lexerActions.length; i++) {
        if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
          if (updatedLexerActions === null) {
            updatedLexerActions = this.lexerActions.concat([]);
          }
          updatedLexerActions[i] = new LexerIndexedCustomAction(
            offset,
            this.lexerActions[i]
          );
        }
      }
      if (updatedLexerActions === null) {
        return this;
      } else {
        return new _LexerActionExecutor(updatedLexerActions);
      }
    }
    /**
     * Execute the actions encapsulated by this executor within the context of a
     * particular {@link Lexer}.
     *
     * This method calls {@link IntStream.seek} to set the position of the
     * `input` {@link CharStream} prior to calling
     * {@link LexerAction.execute} on a position-dependent action. Before the
     * method returns, the input position will be restored to the same position
     * it was in when the method was invoked.
     *
     * @param lexer The lexer instance.
     * @param input The input stream which is the source for the current token.
     * When this method is called, the current {@link IntStream.index} for
     * `input` should be the start of the following token, i.e. 1
     * character past the end of the current token.
     * @param startIndex The token start index. This value may be passed to
     * {@link IntStream.seek} to set the `input` position to the beginning
     * of the token.
     */
    execute(lexer, input, startIndex) {
      if (input === void 0 || startIndex === void 0) {
        return;
      }
      let requiresSeek = false;
      const stopIndex = input.index;
      try {
        for (const lexerAction of this.lexerActions) {
          let action = lexerAction;
          if (lexerAction instanceof LexerIndexedCustomAction) {
            const offset = lexerAction.offset;
            input.seek(startIndex + offset);
            action = lexerAction.action;
            requiresSeek = startIndex + offset !== stopIndex;
          } else if (lexerAction.isPositionDependent) {
            input.seek(stopIndex);
            requiresSeek = false;
          }
          action.execute(lexer);
        }
      } finally {
        if (requiresSeek) {
          input.seek(stopIndex);
        }
      }
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hashCode = MurmurHash.initialize(7);
        for (const lexerAction of this.lexerActions) {
          hashCode = MurmurHash.update(hashCode, lexerAction.hashCode());
        }
        this.cachedHashCode = MurmurHash.finish(hashCode, this.lexerActions.length);
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      if (this.cachedHashCode !== other.cachedHashCode) {
        return false;
      }
      if (this.lexerActions.length !== other.lexerActions.length) {
        return false;
      }
      return this.lexerActions.every((action, index) => {
        return action.equals(other.lexerActions[index]);
      });
    }
  };
  var DFASerializer = class {
    static {
      __name(this, "DFASerializer");
    }
    dfa;
    vocabulary;
    constructor(dfa, vocabulary) {
      this.dfa = dfa;
      this.vocabulary = vocabulary;
    }
    toString() {
      if (!this.dfa.s0) {
        return "";
      }
      let buf = "";
      const states = this.dfa.getStates();
      for (const s of states) {
        let n2 = 0;
        n2 = s.edges.length;
        for (let i = 0; i < n2; i++) {
          const t = s.edges[i];
          if (t && t.stateNumber !== 2147483647) {
            buf += this.getStateString(s);
            const label = this.getEdgeLabel(i);
            buf += "-";
            buf += label;
            buf += "->";
            buf += this.getStateString(t);
            buf += "\n";
          }
        }
      }
      return buf;
    }
    getEdgeLabel(i) {
      const name = this.vocabulary.getDisplayName(i - 1);
      return `${name}`;
    }
    getStateString(s) {
      const n2 = s.stateNumber;
      const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + n2 + (s.requiresFullContext ? "^" : "");
      if (s.isAcceptState) {
        if (s.predicates !== null) {
          return `${baseStateStr}=>${s.predicates.toString()}`;
        }
        return `${baseStateStr}=>${s.prediction}`;
      } else {
        return `${baseStateStr}`;
      }
    }
  };
  var LexerDFASerializer = class extends DFASerializer {
    static {
      __name(this, "LexerDFASerializer");
    }
    constructor(dfa) {
      super(dfa, Vocabulary.EMPTY_VOCABULARY);
    }
    getEdgeLabel = /* @__PURE__ */ __name((i) => {
      return "'" + String.fromCharCode(i) + "'";
    }, "getEdgeLabel");
  };
  var DFA = class {
    static {
      __name(this, "DFA");
    }
    s0;
    decision;
    /** From which ATN state did we create this DFA? */
    atnStartState;
    /**
     * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
     * start state {@link #s0} which is not stored in {@link #states}. The
     * {@link DFAState#edges} array for this start state contains outgoing edges
     * supplying individual start states corresponding to specific precedence
     * values.
     *
     * @returns `true` if this is a precedence DFA; otherwise, `false`.
     */
    isPrecedenceDfa;
    /**
     * A mapping from an ATNConfigSet hash to a DFAState.
     * Used to quick look up the DFA state for a particular configuration set.
     */
    states = /* @__PURE__ */ new Map();
    constructor(atnStartState, decision) {
      this.atnStartState = atnStartState;
      this.decision = decision ?? 0;
      let precedenceDfa = false;
      if (atnStartState instanceof StarLoopEntryState) {
        if (atnStartState.precedenceRuleDecision) {
          precedenceDfa = true;
          this.s0 = DFAState.fromState(-1);
        }
      }
      this.isPrecedenceDfa = precedenceDfa;
    }
    [Symbol.iterator] = () => {
      return this.states.values()[Symbol.iterator]();
    };
    /**
     * Get the start state for a specific precedence value.
     *
     * @param precedence The current precedence.
      @returns The start state corresponding to the specified precedence, or
     * `null` if no start state exists for the specified precedence.
     *
     * @throws IllegalStateException if this is not a precedence DFA.
     * @see #isPrecedenceDfa
     */
    getPrecedenceStartState = /* @__PURE__ */ __name((precedence) => {
      if (!this.isPrecedenceDfa) {
        throw new Error(`Only precedence DFAs may contain a precedence start state.`);
      }
      if (!this.s0 || !this.s0.edges || precedence < 0 || precedence >= this.s0.edges.length) {
        return void 0;
      }
      return this.s0.edges[precedence];
    }, "getPrecedenceStartState");
    /**
     * Set the start state for a specific precedence value.
     *
     * @param precedence The current precedence.
     * @param startState The start state corresponding to the specified precedence.
     */
    setPrecedenceStartState = /* @__PURE__ */ __name((precedence, startState) => {
      if (!this.isPrecedenceDfa) {
        throw new Error(`Only precedence DFAs may contain a precedence start state.`);
      }
      if (precedence < 0 || !this.s0) {
        return;
      }
      this.s0.edges[precedence] = startState;
    }, "setPrecedenceStartState");
    /**
     * @returns a list of all states in this DFA, ordered by state number.
     */
    getStates() {
      const result = [...this.states.values()];
      result.sort((o1, o2) => {
        return o1.stateNumber - o2.stateNumber;
      });
      return result;
    }
    getState(state) {
      return this.states.get(state.configs.hashCode()) ?? null;
    }
    getStateForConfigs(configs) {
      return this.states.get(configs.hashCode()) ?? null;
    }
    addState(state) {
      const hash = state.configs.hashCode();
      if (this.states.has(hash)) {
        return;
      }
      this.states.set(hash, state);
      state.stateNumber = this.states.size - 1;
    }
    toString(vocabulary) {
      if (!vocabulary) {
        return this.toString(Vocabulary.EMPTY_VOCABULARY);
      }
      if (!this.s0) {
        return "";
      }
      const serializer = new DFASerializer(this, vocabulary);
      return serializer.toString() ?? "";
    }
    toLexerString() {
      if (!this.s0) {
        return "";
      }
      const serializer = new LexerDFASerializer(this);
      return serializer.toString() ?? "";
    }
    get length() {
      return this.states.size;
    }
  };
  var LexerATNSimulator = class _LexerATNSimulator extends ATNSimulator {
    static {
      __name(this, "LexerATNSimulator");
    }
    static debug = false;
    decisionToDFA;
    recognizer = null;
    /**
     * The current token's starting index into the character stream.
     *  Shared across DFA to ATN simulation in case the ATN fails and the
     *  DFA did not have a previous accept state. In this case, we use the
     *  ATN-generated exception object.
     */
    startIndex = -1;
    /** line number 1..n within the input */
    line = 1;
    /** The index of the character relative to the beginning of the line 0..n-1 */
    column = 0;
    mode = Lexer.DEFAULT_MODE;
    /** Used during DFA/ATN exec to record the most recent accept configuration info */
    prevAccept;
    options;
    /** Lookup table for lexer ATN config creation. */
    lexerATNConfigFactory;
    /**
     * When we hit an accept state in either the DFA or the ATN, we
     * have to notify the character stream to start buffering characters
     * via {@link IntStream//mark} and record the current state. The current sim state
     * includes the current index into the input, the current line,
     * and current character position in that line. Note that the Lexer is
     * tracking the starting line and characterization of the token. These
     * variables track the "state" of the simulator when it hits an accept state.
     *
     * We track these variables separately for the DFA and ATN simulation
     * because the DFA simulation often has to fail over to the ATN
     * simulation. If the ATN simulation fails, we need the DFA to fall
     * back to its previously accepted state, if any. If the ATN succeeds,
     * then the ATN does the accept and the DFA simulator that invoked it
     * can simply return the predicted token type.
     */
    constructor(recog, atn, decisionToDFA, sharedContextCache) {
      super(atn, sharedContextCache);
      this.decisionToDFA = decisionToDFA;
      this.recognizer = recog;
      if (recog) {
        this.options = recog.options;
      } else {
        this.options = {
          minDFAEdge: 0,
          maxDFAEdge: 256,
          minCodePoint: 0,
          maxCodePoint: 1114111
        };
      }
    }
    match(input, mode) {
      this.mode = mode;
      const mark = input.mark();
      try {
        this.startIndex = input.index;
        this.prevAccept = void 0;
        const dfa = this.decisionToDFA[mode];
        if (!dfa.s0) {
          return this.matchATN(input);
        }
        return this.execATN(input, dfa.s0);
      } finally {
        input.release(mark);
      }
    }
    reset() {
      this.prevAccept = void 0;
      this.startIndex = -1;
      this.line = 1;
      this.column = 0;
      this.mode = Lexer.DEFAULT_MODE;
    }
    clearDFA() {
      for (let d = 0; d < this.decisionToDFA.length; d++) {
        this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);
      }
    }
    getDFA(mode) {
      return this.decisionToDFA[mode];
    }
    /** @returns the text matched so far for the current token. */
    getText(input) {
      return input.getTextFromRange(this.startIndex, input.index - 1);
    }
    consume(input) {
      const curChar = input.LA(1);
      if (curChar === "\n".charCodeAt(0)) {
        this.line += 1;
        this.column = 0;
      } else {
        this.column += 1;
      }
      input.consume();
    }
    getTokenName(tt) {
      if (tt === Token.EOF) {
        return "EOF";
      } else {
        return "'" + String.fromCharCode(tt) + "'";
      }
    }
    matchATN(input) {
      const startState = this.atn.modeToStartState[this.mode];
      if (_LexerATNSimulator.debug) {
        console.log("matchATN mode " + this.mode + " start: " + startState);
      }
      const oldMode = this.mode;
      const s0Closure = this.computeStartState(input, startState);
      const suppressEdge = s0Closure.hasSemanticContext;
      s0Closure.hasSemanticContext = false;
      const next = this.addDFAState(s0Closure);
      if (!suppressEdge) {
        this.decisionToDFA[this.mode].s0 = next;
      }
      const predict = this.execATN(input, next);
      if (_LexerATNSimulator.debug) {
        console.log("DFA after matchATN: " + this.decisionToDFA[oldMode].toLexerString());
      }
      return predict;
    }
    execATN(input, state) {
      if (_LexerATNSimulator.debug) {
        console.log("start state closure=" + state.configs);
      }
      if (state.isAcceptState) {
        this.captureSimState(input, state);
      }
      let t = input.LA(1);
      while (true) {
        if (_LexerATNSimulator.debug) {
          console.log("execATN loop starting closure: " + state.configs);
        }
        let target = this.getExistingTargetState(state, t);
        if (!target) {
          target = this.computeTargetState(input, state, t);
        }
        if (target === ATNSimulator.ERROR) {
          break;
        }
        if (t !== Token.EOF) {
          this.consume(input);
        }
        if (target.isAcceptState) {
          this.captureSimState(input, target);
          if (t === Token.EOF) {
            break;
          }
        }
        t = input.LA(1);
        state = target;
      }
      return this.failOrAccept(input, state.configs, t);
    }
    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns `null`.
     *
     * @param s The current DFA state.
     * @param t The next input symbol.
     *
     * @returns The existing target DFA state for the given input symbol
     * `t`, or `null` if the target state for this edge is not already cached
     */
    getExistingTargetState(s, t) {
      if (t >= this.options.minDFAEdge && t <= this.options.maxDFAEdge) {
        const target = s.edges[t - this.options.minDFAEdge];
        if (_LexerATNSimulator.debug && target) {
          console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
        }
        return target;
      }
      return void 0;
    }
    /**
     * Compute a target state for an edge in the DFA, and attempt to add the computed state and corresponding
     * edge to the DFA.
     *
     * @param input The input stream
     * @param s The current DFA state
     * @param t The next input symbol
     *
     * @returns The computed target DFA state for the given input symbol `t`.
     *          If `t` does not lead to a valid DFA state, this method returns `ERROR`.
     */
    computeTargetState(input, s, t) {
      const reach = new OrderedATNConfigSet();
      this.getReachableConfigSet(input, s.configs, reach, t);
      if (reach.length === 0) {
        if (!reach.hasSemanticContext) {
          this.addDFAEdge(s, t, ATNSimulator.ERROR);
        }
        return ATNSimulator.ERROR;
      }
      return this.addDFAEdge(s, t, null, reach);
    }
    failOrAccept(input, reach, t) {
      if (this.prevAccept?.dfaState) {
        const { dfaState, index, line, column } = this.prevAccept;
        this.accept(input, dfaState.lexerActionExecutor, this.startIndex, index, line, column);
        return dfaState.prediction;
      }
      if (t === Token.EOF && input.index === this.startIndex) {
        return Token.EOF;
      }
      throw new LexerNoViableAltException(this.recognizer, input, this.startIndex, reach);
    }
    /**
     * Given a starting configuration set, figure out all ATN configurations we can reach upon input `t`.
     * Parameter `reach` is a return parameter.
     */
    getReachableConfigSet(input, closure, reach, t) {
      let skipAlt = ATN.INVALID_ALT_NUMBER;
      for (const cfg of closure) {
        const currentAltReachedAcceptState = cfg.alt === skipAlt;
        if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
          continue;
        }
        if (_LexerATNSimulator.debug) {
          console.log("testing %s at %s\n", this.getTokenName(t), cfg.toString(this.recognizer, true));
        }
        for (const trans of cfg.state.transitions) {
          const target = this.getReachableTarget(trans, t);
          if (target) {
            let lexerActionExecutor = cfg.lexerActionExecutor;
            if (lexerActionExecutor) {
              lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
            }
            const treatEofAsEpsilon = t === Token.EOF;
            const config = LexerATNConfig.createWithExecutor(
              cfg,
              target,
              lexerActionExecutor
            );
            if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
              skipAlt = cfg.alt;
            }
          }
        }
      }
    }
    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
      if (_LexerATNSimulator.debug) {
        console.log("ACTION %s\n", lexerActionExecutor);
      }
      input.seek(index);
      this.line = line;
      this.column = charPos;
      if (lexerActionExecutor && this.recognizer) {
        lexerActionExecutor.execute(this.recognizer, input, startIndex);
      }
    }
    getReachableTarget(trans, t) {
      if (trans.matches(t, this.options.minCodePoint, this.options.maxCodePoint)) {
        return trans.target;
      } else {
        return void 0;
      }
    }
    computeStartState(input, p) {
      const initialContext = PredictionContext.EMPTY;
      const configs = new OrderedATNConfigSet();
      for (let i = 0; i < p.transitions.length; i++) {
        const target = p.transitions[i].target;
        const cfg = LexerATNConfig.createWithContext(target, i + 1, initialContext);
        this.closure(input, cfg, configs, false, false, false);
      }
      return configs;
    }
    /**
     * Since the alternatives within any lexer decision are ordered by
     * preference, this method stops pursuing the closure as soon as an accept
     * state is reached. After the first accept state is reached by depth-first
     * search from `config`, all other (potentially reachable) states for
     * this rule would have a lower priority.
     *
     * @returns {boolean} `true` if an accept state is reached, otherwise `false`.
     */
    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
      let cfg = null;
      if (_LexerATNSimulator.debug) {
        console.log("closure(" + config.toString(this.recognizer, true) + ")");
      }
      if (config.state.constructor.stateType === ATNState.RULE_STOP) {
        if (_LexerATNSimulator.debug) {
          if (this.recognizer !== null) {
            console.log(
              "closure at %s rule stop %s\n",
              this.recognizer.ruleNames[config.state.ruleIndex],
              config
            );
          } else {
            console.log("closure at rule stop %s\n", config);
          }
        }
        if (!config.context || config.context.hasEmptyPath()) {
          if (!config.context || config.context.isEmpty()) {
            configs.add(config);
            return true;
          } else {
            configs.add(LexerATNConfig.createWithConfig(config.state, config, PredictionContext.EMPTY));
            currentAltReachedAcceptState = true;
          }
        }
        if (config.context && !config.context.isEmpty()) {
          for (let i = 0; i < config.context.length; i++) {
            if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
              const newContext = config.context.getParent(i);
              const returnState = this.atn.states[config.context.getReturnState(i)];
              cfg = LexerATNConfig.createWithConfig(returnState, config, newContext);
              currentAltReachedAcceptState = this.closure(
                input,
                cfg,
                configs,
                currentAltReachedAcceptState,
                speculative,
                treatEofAsEpsilon
              );
            }
          }
        }
        return currentAltReachedAcceptState;
      }
      if (!config.state.epsilonOnlyTransitions) {
        if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
          configs.add(config);
        }
      }
      for (const trans of config.state.transitions) {
        cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
        if (cfg) {
          currentAltReachedAcceptState = this.closure(
            input,
            cfg,
            configs,
            currentAltReachedAcceptState,
            speculative,
            treatEofAsEpsilon
          );
        }
      }
      return currentAltReachedAcceptState;
    }
    // side-effect: can alter configs.hasSemanticContext
    getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
      if (!this.lexerATNConfigFactory) {
        this.setupATNFactoryLookup();
      }
      const factory = this.lexerATNConfigFactory[trans.transitionType];
      if (!factory) {
        return null;
      }
      return factory(input, config, trans, configs, speculative, treatEofAsEpsilon);
    }
    /**
     * Fills the lookup table for creating lexer ATN configs. This helps to avoid frequent checks of the transition
     * type, which determines the configuration of the created config.
     */
    setupATNFactoryLookup() {
      this.lexerATNConfigFactory = [];
      this.lexerATNConfigFactory[Transition.RULE] = (input, config, trans) => {
        const newContext = SingletonPredictionContext.create(
          config.context ?? void 0,
          trans.followState.stateNumber
        );
        return LexerATNConfig.createWithConfig(trans.target, config, newContext);
      };
      this.lexerATNConfigFactory[Transition.PRECEDENCE] = () => {
        throw new Error("Precedence predicates are not supported in lexers.");
      };
      this.lexerATNConfigFactory[Transition.PREDICATE] = (input, config, trans, configs, speculative) => {
        const pt = trans;
        if (_LexerATNSimulator.debug) {
          console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
        }
        configs.hasSemanticContext = true;
        if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
          return LexerATNConfig.createWithConfig(trans.target, config);
        }
        return null;
      };
      this.lexerATNConfigFactory[Transition.ACTION] = (input, config, trans) => {
        if (config.context === null || config.context.hasEmptyPath()) {
          const lexerActionExecutor = LexerActionExecutor.append(
            config.lexerActionExecutor,
            this.atn.lexerActions[trans.actionIndex]
          );
          return LexerATNConfig.createWithExecutor(config, trans.target, lexerActionExecutor);
        } else {
          return LexerATNConfig.createWithConfig(trans.target, config);
        }
      };
      this.lexerATNConfigFactory[Transition.EPSILON] = (input, config, trans) => {
        return LexerATNConfig.createWithConfig(trans.target, config);
      };
      const simple = /* @__PURE__ */ __name((input, config, trans, configs, speculative, treatEofAsEpsilon) => {
        if (treatEofAsEpsilon) {
          if (trans.matches(Token.EOF, this.options.minCodePoint, this.options.maxCodePoint)) {
            return LexerATNConfig.createWithConfig(trans.target, config);
          }
        }
        return null;
      }, "simple");
      this.lexerATNConfigFactory[Transition.ATOM] = simple;
      this.lexerATNConfigFactory[Transition.RANGE] = simple;
      this.lexerATNConfigFactory[Transition.SET] = simple;
    }
    /**
     * Evaluate a predicate specified in the lexer.
     *
     * If `speculative` is `true`, this method was called before
     * {@link consume} for the matched character. This method should call
     * {@link consume} before evaluating the predicate to ensure position
     * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
     * and {@link Lexer}, properly reflect the current
     * lexer state. This method should restore `input` and the simulator
     * to the original state before returning (i.e. undo the actions made by the
     * call to {@link consume}.
     *
     * @param input The input stream.
     * @param ruleIndex The rule containing the predicate.
     * @param predIndex The index of the predicate within the rule.
     * @param speculative `true` if the current index in `input` is
     * one character before the predicate's location.
     *
     * @returns `true` if the specified predicate evaluates to
     * `true`.
     */
    evaluatePredicate(input, ruleIndex, predIndex, speculative) {
      if (!this.recognizer) {
        return true;
      }
      if (!speculative) {
        return this.recognizer.sempred(null, ruleIndex, predIndex);
      }
      const savedColumn = this.column;
      const savedLine = this.line;
      const index = input.index;
      const marker = input.mark();
      try {
        this.consume(input);
        return this.recognizer.sempred(null, ruleIndex, predIndex);
      } finally {
        this.column = savedColumn;
        this.line = savedLine;
        input.seek(index);
        input.release(marker);
      }
    }
    captureSimState(input, dfaState) {
      this.prevAccept = {
        index: input.index,
        line: this.line,
        column: this.column,
        dfaState
      };
    }
    addDFAEdge(from, tk, to, configs) {
      if (!to && configs) {
        const suppressEdge = configs.hasSemanticContext;
        configs.hasSemanticContext = false;
        to = this.addDFAState(configs);
        if (suppressEdge) {
          return to;
        }
      }
      if (tk < this.options.minDFAEdge || tk > this.options.maxDFAEdge) {
        return to;
      }
      if (_LexerATNSimulator.debug) {
        console.log("EDGE " + from + " -> " + to + " upon " + tk);
      }
      from.edges[tk - this.options.minDFAEdge] = to;
      return to;
    }
    /**
     * Add a new DFA state if there isn't one with this set of configurations already. This method also detects
     * the first configuration containing an ATN rule stop state. Later, when traversing the DFA, we will know
     * which rule to accept.
     */
    addDFAState(configs) {
      const dfa = this.decisionToDFA[this.mode];
      const existing = dfa.getStateForConfigs(configs);
      if (existing) {
        return existing;
      }
      const proposed = DFAState.fromConfigs(configs);
      const firstConfigWithRuleStopState = configs.firstStopState;
      if (firstConfigWithRuleStopState) {
        proposed.isAcceptState = true;
        proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
        proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
      }
      configs.setReadonly(true);
      dfa.addState(proposed);
      return proposed;
    }
  };
  var ParseInfo = class {
    static {
      __name(this, "ParseInfo");
    }
    atnSimulator;
    constructor(atnSimulator) {
      this.atnSimulator = atnSimulator;
    }
    /**
     * Gets an array of {@link DecisionInfo} instances containing the profiling
     * information gathered for each decision in the ATN.
     *
     * @returns An array of {@link DecisionInfo} instances, indexed by decision
     * number.
     */
    getDecisionInfo() {
      return this.atnSimulator.getDecisionInfo();
    }
    /**
     * Gets the decision numbers for decisions that required one or more
     * full-context predictions during parsing. These are decisions for which
     * {@link DecisionInfo#llFallback} is non-zero.
     *
     * @returns A list of decision numbers which required one or more
     * full-context predictions during parsing.
     */
    getLLDecisions() {
      const decisions = this.atnSimulator.getDecisionInfo();
      const result = new Array();
      for (let i = 0; i < decisions.length; i++) {
        const fallBack = decisions[i].llFallback;
        if (fallBack > 0) {
          result.push(i);
        }
      }
      return result;
    }
    /**
     * Gets the total time spent during prediction across all decisions made
     * during parsing. This value is the sum of
     * {@link DecisionInfo#timeInPrediction} for all decisions.
     */
    getTotalTimeInPrediction() {
      const decisions = this.atnSimulator.getDecisionInfo();
      let t = 0;
      for (const decision of decisions) {
        t += decision.timeInPrediction;
      }
      return t;
    }
    /**
     * Gets the total number of SLL lookahead operations across all decisions
     * made during parsing. This value is the sum of
     * {@link DecisionInfo#sllTotalLook} for all decisions.
     */
    getTotalSLLLookaheadOps() {
      const decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (const decision of decisions) {
        k += decision.sllTotalLook;
      }
      return k;
    }
    /**
     * Gets the total number of LL lookahead operations across all decisions
     * made during parsing. This value is the sum of
     * {@link DecisionInfo#llTotalLook} for all decisions.
     */
    getTotalLLLookaheadOps() {
      const decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (const decision of decisions) {
        k += decision.llTotalLook;
      }
      return k;
    }
    /**
     * Gets the total number of ATN lookahead operations for SLL prediction
     * across all decisions made during parsing.
     */
    getTotalSLLATNLookaheadOps() {
      const decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (const decision of decisions) {
        k += decision.sllATNTransitions;
      }
      return k;
    }
    /**
     * Gets the total number of ATN lookahead operations for LL prediction
     * across all decisions made during parsing.
     */
    getTotalLLATNLookaheadOps() {
      const decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (const decision of decisions) {
        k += decision.llATNTransitions;
      }
      return k;
    }
    /**
     * Gets the total number of ATN lookahead operations for SLL and LL
     * prediction across all decisions made during parsing.
     *
     *
     * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
     * {@link #getTotalLLATNLookaheadOps}.
     */
    getTotalATNLookaheadOps() {
      const decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (const decision of decisions) {
        k += decision.sllATNTransitions;
        k += decision.llATNTransitions;
      }
      return k;
    }
    getDFASize(decision) {
      if (decision === void 0) {
        let n2 = 0;
        const decisionToDFA = this.atnSimulator.decisionToDFA;
        for (let i = 0; i < decisionToDFA.length; i++) {
          n2 += this.getDFASize(i);
        }
        return n2;
      } else {
        const decisionToDFA = this.atnSimulator.decisionToDFA[decision];
        return decisionToDFA.length;
      }
    }
  };
  var NoViableAltException = class extends RecognitionException {
    static {
      __name(this, "NoViableAltException");
    }
    /** Which configurations did we try at input.index() that couldn't match input.LT(1)? */
    deadEndConfigs = null;
    /**
     * The token object at the start index; the input stream might
     * 	not be buffering tokens so get a reference to it. (At the
     *  time the error occurred, of course the stream needs to keep a
     *  buffer all of the tokens but later we might not have access to those.)
     */
    startToken;
    constructor(recognizer, input = null, startToken = null, offendingToken = null, deadEndConfigs = null, ctx = null) {
      ctx = ctx ?? recognizer.context;
      offendingToken = offendingToken ?? recognizer.getCurrentToken();
      startToken = startToken ?? recognizer.getCurrentToken();
      input = input ?? recognizer.inputStream;
      super({ message: "", recognizer, input, ctx });
      this.deadEndConfigs = deadEndConfigs;
      this.startToken = startToken;
      this.offendingToken = offendingToken;
    }
  };
  var DoubleDict = class {
    static {
      __name(this, "DoubleDict");
    }
    cacheMap;
    constructor() {
      this.cacheMap = new HashMap();
    }
    get(a, b) {
      const d = this.cacheMap.get(a) ?? null;
      return d === null ? null : d.get(b) ?? null;
    }
    set(a, b, o) {
      let d = this.cacheMap.get(a);
      if (!d) {
        d = new HashMap();
        this.cacheMap.set(a, d);
      }
      d.set(b, o);
    }
  };
  var SubsetEqualityComparer = class _SubsetEqualityComparer {
    static {
      __name(this, "SubsetEqualityComparer");
    }
    static instance = new _SubsetEqualityComparer();
    hashCode(config) {
      let hashCode = MurmurHash.initialize(7);
      hashCode = MurmurHash.update(hashCode, config.state.stateNumber);
      hashCode = MurmurHash.updateFromComparable(hashCode, config.context);
      hashCode = MurmurHash.finish(hashCode, 2);
      return hashCode;
    }
    equals(a, b) {
      return a.state.stateNumber === b.state.stateNumber && (a.context?.equals(b.context) ?? true);
    }
  };
  var PredictionMode = class _PredictionMode {
    static {
      __name(this, "PredictionMode");
    }
    /**
     * The SLL(*) prediction mode. This prediction mode ignores the current
     * parser context when making predictions. This is the fastest prediction
     * mode, and provides correct results for many grammars. This prediction
     * mode is more powerful than the prediction mode provided by ANTLR 3, but
     * may result in syntax errors for grammar and input combinations which are
     * not SLL.
     *
     *
     * When using this prediction mode, the parser will either return a correct
     * parse tree (i.e. the same parse tree that would be returned with the
     * {@link LL} prediction mode), or it will report a syntax error. If a
     * syntax error is encountered when using the {@link SLL} prediction mode,
     * it may be due to either an actual syntax error in the input or indicate
     * that the particular combination of grammar and input requires the more
     * powerful {@link LL} prediction abilities to complete successfully.
     *
     *
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.
     */
    static SLL = 0;
    /**
     * The LL(*) prediction mode. This prediction mode allows the current parser
     * context to be used for resolving SLL conflicts that occur during
     * prediction. This is the fastest prediction mode that guarantees correct
     * parse results for all combinations of grammars with syntactically correct
     * inputs.
     *
     *
     * When using this prediction mode, the parser will make correct decisions
     * for all syntactically-correct grammar and input combinations. However, in
     * cases where the grammar is truly ambiguous this prediction mode might not
     * report a precise answer for *exactly which* alternatives are
     * ambiguous.
     *
     *
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.
     */
    static LL = 1;
    /**
     *
     * The LL(*) prediction mode with exact ambiguity detection. In addition to
     * the correctness guarantees provided by the {@link LL} prediction mode,
     * this prediction mode instructs the prediction algorithm to determine the
     * complete and exact set of ambiguous alternatives for every ambiguous
     * decision encountered while parsing.
     *
     *
     * This prediction mode may be used for diagnosing ambiguities during
     * grammar development. Due to the performance overhead of calculating sets
     * of ambiguous alternatives, this prediction mode should be avoided when
     * the exact results are not necessary.
     *
     *
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.
     */
    static LL_EXACT_AMBIG_DETECTION = 2;
    /**
     *
     *Computes the SLL prediction termination condition.
     *
     *
     *This method computes the SLL prediction termination condition for both of
     *the following cases.
     *
     * - The usual SLL+LL fallback upon SLL conflict
     * - Pure SLL without LL fallback
     *
     ***COMBINED SLL+LL PARSING**
     *
     *When LL-fallback is enabled upon SLL conflict, correct predictions are
     *ensured regardless of how the termination condition is computed by this
     *method. Due to the substantially higher cost of LL prediction, the
     *prediction should only fall back to LL when the additional lookahead
     *cannot lead to a unique SLL prediction.
     *
     *Assuming combined SLL+LL parsing, an SLL configuration set with only
     *conflicting subsets should fall back to full LL, even if the
     *configuration sets don't resolve to the same alternative (e.g.
     *`{1,2`} and `{3,4`}. If there is at least one non-conflicting
     *configuration, SLL could continue with the hopes that more lookahead will
     *resolve via one of those non-conflicting configurations.
     *
     *Here's the prediction termination rule them: SLL (for SLL+LL parsing)
     *stops when it sees only conflicting configuration subsets. In contrast,
     *full LL keeps going when there is uncertainty.
     *
     ***HEURISTIC**
     *
     *As a heuristic, we stop prediction when we see any conflicting subset
     *unless we see a state that only has one alternative associated with it.
     *The single-alt-state thing lets prediction continue upon rules like
     *(otherwise, it would admit defeat too soon):
     *
     *`[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;`
     *
     *When the ATN simulation reaches the state before `';'`, it has a
     *DFA state that looks like: `[12|1|[], 6|2|[], 12|2|[]]`. Naturally
     *`12|1|[]` and `12|2|[]` conflict, but we cannot stop
     *processing this node because alternative to has another way to continue,
     *via `[6|2|[]]`.
     *
     *It also let's us continue for this rule:
     *
     *`[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;`
     *
     *After matching input A, we reach the stop state for rule A, state 1.
     *State 8 is the state right before B. Clearly alternatives 1 and 2
     *conflict and no amount of further lookahead will separate the two.
     *However, alternative 3 will be able to continue and so we do not stop
     *working on this state. In the previous example, we're concerned with
     *states associated with the conflicting alternatives. Here alt 3 is not
     *associated with the conflicting configs, but since we can continue
     *looking for input reasonably, don't declare the state done.
     *
     ***PURE SLL PARSING**
     *
     *To handle pure SLL parsing, all we have to do is make sure that we
     *combine stack contexts for configurations that differ only by semantic
     *predicate. From there, we can do the usual SLL termination heuristic.
     *
     ***PREDICATES IN SLL+LL PARSING**
     *
     *SLL decisions don't evaluate predicates until after they reach DFA stop
     *states because they need to create the DFA cache that works in all
     *semantic situations. In contrast, full LL evaluates predicates collected
     *during start state computation so it can ignore predicates thereafter.
     *This means that SLL termination detection can totally ignore semantic
     *predicates.
     *
     *Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
     *semantic predicate contexts so we might see two configurations like the
     *following.
     *
     *`(s, 1, x, {`), (s, 1, x', {p})}
     *
     *Before testing these configurations against others, we have to merge
     *`x` and `x'` (without modifying the existing configurations).
     *For example, we test `(x+x')==x''` when looking for conflicts in
     *the following configurations.
     *
     *`(s, 1, x, {`), (s, 1, x', {p}), (s, 2, x'', {})}
     *
     *If the configuration set has predicates (as indicated by
     *{@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
     *the configurations to strip out all of the predicates so that a standard
     *{@link ATNConfigSet} will merge everything ignoring predicates.
     */
    static hasSLLConflictTerminatingPrediction(mode, configs) {
      if (_PredictionMode.allConfigsInRuleStopStates(configs)) {
        return true;
      }
      if (mode === _PredictionMode.SLL) {
        if (configs.hasSemanticContext) {
          const dup = new ATNConfigSet();
          for (let c of configs) {
            c = ATNConfig.duplicate(c, SemanticContext.NONE);
            dup.add(c);
          }
          configs = dup;
        }
      }
      const altSets = _PredictionMode.getConflictingAltSubsets(configs);
      return _PredictionMode.hasConflictingAltSet(altSets) && !_PredictionMode.hasStateAssociatedWithOneAlt(configs);
    }
    /**
     * Checks if any configuration in `configs` is in a
     * {@link RuleStopState}. Configurations meeting this condition have reached
     * the end of the decision rule (local context) or end of start rule (full
     * context).
     *
     * @param configs the configuration set to test
     * @returns `true` if any configuration in `configs` is in a
     * {@link RuleStopState}, otherwise `false`
     */
    static hasConfigInRuleStopState(configs) {
      for (const c of configs) {
        if (c.state instanceof RuleStopState) {
          return true;
        }
      }
      return false;
    }
    /**
     * Checks if all configurations in `configs` are in a
     * {@link RuleStopState}. Configurations meeting this condition have reached
     * the end of the decision rule (local context) or end of start rule (full
     * context).
     *
     * @param configs the configuration set to test
     * @returns `true` if all configurations in `configs` are in a
     * {@link RuleStopState}, otherwise `false`
     */
    static allConfigsInRuleStopStates(configs) {
      for (const c of configs) {
        if (!(c.state instanceof RuleStopState)) {
          return false;
        }
      }
      return true;
    }
    /**
     *
     * Full LL prediction termination.
     *
     * Can we stop looking ahead during ATN simulation or is there some
     * uncertainty as to which alternative we will ultimately pick, after
     * consuming more input? Even if there are partial conflicts, we might know
     * that everything is going to resolve to the same minimum alternative. That
     * means we can stop since no more lookahead will change that fact. On the
     * other hand, there might be multiple conflicts that resolve to different
     * minimums. That means we need more look ahead to decide which of those
     * alternatives we should predict.
     *
     * The basic idea is to split the set of configurations `C`, into
     * conflicting subsets `(s, _, ctx, _)` and singleton subsets with
     * non-conflicting configurations. Two configurations conflict if they have
     * identical {@link ATNConfig.state} and {@link ATNConfig.context} values
     * but different {@link ATNConfig.alt} value, e.g. `(s, i, ctx, _)`
     * and `(s, j, ctx, _)` for `i!=j`.
     *
     * Reduce these configuration subsets to the set of possible alternatives.
     * You can compute the alternative subsets in one pass as follows:
     *
     * `A_s,ctx = {i | (s, i, ctx, _)`} for each configuration in
     * `C` holding `s` and `ctx` fixed.
     *
     * Or in pseudo-code, for each configuration `c` in `C`:
     *
     * ```
     * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not
     * alt and not pred
     * ```
     *
     * The values in `map` are the set of `A_s,ctx` sets.
     *
     * If `|A_s,ctx|=1` then there is no conflict associated with
     * `s` and `ctx`.
     *
     * Reduce the subsets to singletons by choosing a minimum of each subset. If
     * the union of these alternative subsets is a singleton, then no amount of
     * more lookahead will help us. We will always pick that alternative. If,
     * however, there is more than one alternative, then we are uncertain which
     * alternative to predict and must continue looking for resolution. We may
     * or may not discover an ambiguity in the future, even if there are no
     * conflicting subsets this round.
     *
     * The biggest sin is to terminate early because it means we've made a
     * decision but were uncertain as to the eventual outcome. We haven't used
     * enough lookahead. On the other hand, announcing a conflict too late is no
     * big deal; you will still have the conflict. It's just inefficient. It
     * might even look until the end of file.
     *
     * No special consideration for semantic predicates is required because
     * predicates are evaluated on-the-fly for full LL prediction, ensuring that
     * no configuration contains a semantic context during the termination
     * check.
     *
     * **CONFLICTING CONFIGS**
     *
     * Two configurations `(s, i, x)` and `(s, j, x')`, conflict when `i!=j` but `x=x'`. Because we merge all
     * `(s, i, _)` configurations together, that means that there are at most `n` configurations associated with state
     * `s` for `n` possible alternatives in the decision. The merged stacks complicate the comparison of configuration
     * contexts `x` and `x'`. Sam checks to see if one is a subset of the other by calling merge and checking to see
     * if the merged result is either `x` or `x'`. If the `x` associated with lowest alternative `i` is the superset,
     * then `i` is the only possible prediction since the others resolve to `min(i)` as well. However, if `x` is
     * associated with `j>i` then at least one stack configuration for `j` is not in conflict with alternative `i`.
     * The algorithm should keep going, looking for more lookahead due to the uncertainty.
     *
     * For simplicity, I'm doing a equality check between `x` and `x'` that lets the algorithm continue to consume
     * lookahead longer than necessary. The reason I like the equality is of course the simplicity but also because
     * that is the test you need to detect the alternatives that are actually in conflict.
     *
     * **CONTINUE/STOP RULE**
     *
     * Continue if union of resolved alternative sets from non-conflicting and conflicting alternative subsets has more
     * than one alternative. We are uncertain about which alternative to predict.
     *
     * The complete set of alternatives, `[i for (_,i,_)]`, tells us which alternatives are still in the running for
     * the amount of input we've consumed at this point. The conflicting sets let us to strip away configurations that
     * won't lead to more states because we resolve conflicts to the configuration with a minimum alternate for the
     * conflicting set.
     *
     * **CASES**
     *
     * - no conflicts and more than 1 alternative in set => continue
     * -  `(s, 1, x)`, `(s, 2, x)`, `(s, 3, z)`, `(s', 1, y)`, `(s', 2, y)` yields non-conflicting set `{3`} U
     *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1,3`} => continue
     * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)`, `(s'', 1, z)` yields non-conflicting set `{1`} U
     *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1`} => stop and predict 1
     * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)` yields conflicting, reduced sets `{1`} U
     *   `{1`} = `{1`} => stop and predict 1, can announce ambiguity `{1,2`}
     * - `(s, 1, x)`, `(s, 2, x)`, `(s', 2, y)`, `(s', 3, y)` yields conflicting, reduced sets `{1`} U
     *   `{2`} = `{1,2`} => continue
     * - `(s, 1, x)`, `(s, 2, x)`, `(s', 3, y)`, `(s', 4, y)` yields conflicting, reduced sets `{1`} U
     *   `{3`} = `{1,3`} => continue
     *
     * **EXACT AMBIGUITY DETECTION**
     *
     *If all states report the same conflicting set of alternatives, then we
     *know we have the exact ambiguity set.
     *
     * `|A_*i*|>1` and `A_*i* = A_*j*` for all *i*, *j*.
     *
     * In other words, we continue examining lookahead until all `A_i` have more than one alternative and all `A_i`
     * are the same. If `A={{1,2`, {1,3}}}, then regular LL prediction would terminate because the resolved set
     * is `{1`}. To determine what the real ambiguity is, we have to know whether the ambiguity is between one and
     * two or one and three so we keep going. We can only stop prediction when we need exact ambiguity detection when
     * the sets look like `A={{1,2`}} or `{{1,2`,{1,2}}}, etc...
     */
    static resolvesToJustOneViableAlt(altSets) {
      return _PredictionMode.getSingleViableAlt(altSets);
    }
    /**
     * Determines if every alternative subset in `altSets` contains more
     * than one alternative.
     *
     * @param altSets a collection of alternative subsets
     * @returns `true` if every {@link BitSet} in `altSets` has
     * {@link BitSet//cardinality cardinality} > 1, otherwise `false`
     */
    static allSubsetsConflict(altSets) {
      return !_PredictionMode.hasNonConflictingAltSet(altSets);
    }
    /**
     * Determines if any single alternative subset in `altSets` contains
     * exactly one alternative.
     *
     * @param altSets a collection of alternative subsets
     * @returns `true` if `altSets` contains a {@link BitSet} with
     * {@link BitSet//cardinality cardinality} 1, otherwise `false`
     */
    static hasNonConflictingAltSet(altSets) {
      for (const alts of altSets) {
        if (alts.length === 1) {
          return true;
        }
      }
      return false;
    }
    /**
     * Determines if any single alternative subset in `altSets` contains
     * more than one alternative.
     *
     * @param altSets a collection of alternative subsets
     * @returns `true` if `altSets` contains a {@link BitSet} with
     * {@link BitSet//cardinality cardinality} > 1, otherwise `false`
     */
    static hasConflictingAltSet(altSets) {
      for (const alts of altSets) {
        if (alts.length > 1) {
          return true;
        }
      }
      return false;
    }
    /**
     * Determines if every alternative subset in `altSets` is equivalent.
     *
     * @param altSets a collection of alternative subsets
     * @returns `true` if every member of `altSets` is equal to the
     * others, otherwise `false`
     */
    static allSubsetsEqual(altSets) {
      let first = null;
      for (const alts of altSets) {
        if (first === null) {
          first = alts;
        } else if (alts !== first) {
          return false;
        }
      }
      return true;
    }
    /**
     * Returns the unique alternative predicted by all alternative subsets in
     * `altSets`. If no such alternative exists, this method returns
     * {@link ATN.INVALID_ALT_NUMBER}.
     *
     * @param altSets a collection of alternative subsets
     */
    static getUniqueAlt(altSets) {
      const all = _PredictionMode.getAlts(altSets);
      if (all.length === 1) {
        return all.nextSetBit(0);
      } else {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    /**
     * Gets the complete set of represented alternatives for a collection of
     * alternative subsets. This method returns the union of each {@link BitSet}
     * in `altSets`.
     *
     * @param altSets a collection of alternative subsets
     * @returns the set of represented alternatives in `altSets`
     */
    static getAlts(altSets) {
      const all = new BitSet();
      altSets.forEach((alts) => {
        all.or(alts);
      });
      return all;
    }
    /**
     * This function gets the conflicting alt subsets from a configuration set.
     * For each configuration `c` in `configs`:
     *
     * ```
     * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not
     * alt and not pred
     * ```
     */
    static getConflictingAltSubsets(configs) {
      const configToAlts = new HashMap(SubsetEqualityComparer.instance);
      for (const cfg of configs) {
        let alts = configToAlts.get(cfg);
        if (!alts) {
          alts = new BitSet();
          configToAlts.set(cfg, alts);
        }
        alts.set(cfg.alt);
      }
      return Array.from(configToAlts.values());
    }
    /**
     * Get a map from state to alt subset from a configuration set. For each configuration `c` in `configs`:
     *
     * ```
     * map[c.state] = c.alt
     * ```
     */
    static getStateToAltMap(configs) {
      const m2 = new HashMap(ObjectEqualityComparator.instance);
      for (const c of configs) {
        let alts = m2.get(c.state);
        if (!alts) {
          alts = new BitSet();
          m2.set(c.state, alts);
        }
        alts.set(c.alt);
      }
      return m2;
    }
    static hasStateAssociatedWithOneAlt(configs) {
      const counts = {};
      for (const c of configs) {
        const stateNumber = c.state.stateNumber;
        if (!counts[stateNumber]) {
          counts[stateNumber] = 0;
        }
        counts[stateNumber]++;
      }
      return Object.values(counts).some((count) => {
        return count === 1;
      });
    }
    static getSingleViableAlt(altSets) {
      let result = null;
      for (const alts of altSets) {
        const minAlt = alts.nextSetBit(0);
        if (result === null) {
          result = minAlt;
        } else if (result !== minAlt) {
          return ATN.INVALID_ALT_NUMBER;
        }
      }
      return result ?? 0;
    }
  };
  var ParserATNSimulator = class _ParserATNSimulator extends ATNSimulator {
    static {
      __name(this, "ParserATNSimulator");
    }
    static traceATNSimulator = false;
    static debug;
    static debugAdd = false;
    static debugClosure = false;
    static dfaDebug = false;
    static retryDebug = false;
    /** SLL, LL, or LL + exact ambig detection? */
    predictionMode;
    decisionToDFA;
    parser;
    /**
     * Each prediction operation uses a cache for merge of prediction contexts.
     * Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
     * isn't synchronized but we're ok since two threads shouldn't reuse same
     * parser/atn sim object because it can only handle one input at a time.
     * This maps graphs a and b to merged result c. (a,b)->c. We can avoid
     * the merge if we ever see a and b again.  Note that (b,a)->c should
     * also be examined during cache lookup.
     */
    mergeCache = new DoubleDict();
    // Used also in the profiling ATN simulator.
    predictionState;
    constructor(recog, atn, decisionToDFA, sharedContextCache) {
      super(atn, sharedContextCache);
      this.parser = recog;
      this.decisionToDFA = decisionToDFA;
    }
    static getUniqueAlt(configs) {
      let alt = ATN.INVALID_ALT_NUMBER;
      for (const c of configs) {
        if (alt === ATN.INVALID_ALT_NUMBER) {
          alt = c.alt;
        } else if (c.alt !== alt) {
          return ATN.INVALID_ALT_NUMBER;
        }
      }
      return alt;
    }
    reset() {
    }
    clearDFA() {
      for (let d = 0; d < this.decisionToDFA.length; d++) {
        this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);
      }
    }
    // TODO: make outerContext an optional parameter, not optional null.
    adaptivePredict(input, decision, outerContext) {
      if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
        console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
      }
      const dfa = this.decisionToDFA[decision];
      this.predictionState = {
        input,
        startIndex: input.index,
        outerContext: outerContext ?? void 0,
        dfa
      };
      const m2 = input.mark();
      const index = input.index;
      try {
        let s0;
        if (dfa.isPrecedenceDfa) {
          s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
        } else {
          s0 = dfa.s0;
        }
        if (!s0) {
          if (!outerContext) {
            outerContext = ParserRuleContext.empty;
          }
          if (_ParserATNSimulator.debug) {
            console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
          }
          const fullCtx = false;
          let s0_closure = this.computeStartState(dfa.atnStartState, ParserRuleContext.empty, fullCtx);
          if (dfa.isPrecedenceDfa) {
            s0_closure = this.applyPrecedenceFilter(s0_closure);
            s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));
            dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
          } else {
            s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));
            dfa.s0 = s0;
          }
        }
        const alt = this.execATN(dfa, s0, input, index, outerContext);
        if (_ParserATNSimulator.debug) {
          console.log("DFA after predictATN: " + dfa.toString(this.parser.vocabulary));
        }
        return alt;
      } finally {
        this.predictionState.dfa = void 0;
        this.mergeCache = new DoubleDict();
        input.seek(index);
        input.release(m2);
      }
    }
    /**
     * Performs ATN simulation to compute a predicted alternative based
     *  upon the remaining input, but also updates the DFA cache to avoid
     *  having to traverse the ATN again for the same input sequence.
     *
     * There are some key conditions we're looking for after computing a new
     * set of ATN configs (proposed DFA state):
     *       if the set is empty, there is no viable alternative for current symbol
     *       does the state uniquely predict an alternative?
     *       does the state have a conflict that would prevent us from
     *         putting it on the work list?
     *
     * We also have some key operations to do:
     *       add an edge from previous DFA state to potentially new DFA state, D,
     *         upon current symbol but only if adding to work list, which means in all
     *         cases except no viable alternative (and possibly non-greedy decisions?)
     *       collecting predicates and adding semantic context to DFA accept states
     *       adding rule context to context-sensitive DFA accept states
     *       consuming an input symbol
     *       reporting a conflict
     *       reporting an ambiguity
     *       reporting a context sensitivity
     *       reporting insufficient predicates
     *
     * cover these cases:
     *    dead end
     *    single alt
     *    single alt + preds
     *    conflict
     *    conflict + preds
     */
    execATN(dfa, s0, input, startIndex, outerContext) {
      if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
        console.log("execATN decision " + dfa.decision + ", DFA state " + s0 + ", LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
      }
      let alt;
      let previousState = s0;
      let t = input.LA(1);
      while (true) {
        let nextState = this.getExistingTargetState(previousState, t);
        if (!nextState) {
          nextState = this.computeTargetState(dfa, previousState, t);
        }
        if (nextState === ATNSimulator.ERROR) {
          const e = this.noViableAlt(input, outerContext, previousState.configs, startIndex);
          input.seek(startIndex);
          alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousState.configs, outerContext);
          if (alt !== ATN.INVALID_ALT_NUMBER) {
            return alt;
          } else {
            throw e;
          }
        }
        if (nextState.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
          let conflictingAlts = null;
          if (nextState.predicates !== null) {
            if (_ParserATNSimulator.debug) {
              console.log("DFA state has preds in DFA sim LL failover");
            }
            const conflictIndex = input.index;
            if (conflictIndex !== startIndex) {
              input.seek(startIndex);
            }
            conflictingAlts = this.evalSemanticContext(nextState.predicates, outerContext, true);
            if (conflictingAlts.length === 1) {
              if (_ParserATNSimulator.debug) {
                console.log("Full LL avoided");
              }
              return conflictingAlts.nextSetBit(0);
            }
            if (conflictIndex !== startIndex) {
              input.seek(conflictIndex);
            }
          }
          if (_ParserATNSimulator.dfaDebug) {
            console.log("ctx sensitive state " + outerContext + " in " + nextState);
          }
          const fullCtx = true;
          const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
          this.reportAttemptingFullContext(dfa, conflictingAlts, nextState.configs, startIndex, input.index);
          alt = this.execATNWithFullContext(dfa, nextState, s0_closure, input, startIndex, outerContext);
          return alt;
        }
        if (nextState.isAcceptState) {
          if (nextState.predicates === null) {
            return nextState.prediction;
          }
          const stopIndex = input.index;
          input.seek(startIndex);
          const alts = this.evalSemanticContext(nextState.predicates, outerContext, true);
          if (alts.length === 0) {
            throw this.noViableAlt(input, outerContext, nextState.configs, startIndex);
          }
          if (alts.length === 1) {
            return alts.nextSetBit(0);
          }
          this.reportAmbiguity(dfa, nextState, startIndex, stopIndex, false, alts, nextState.configs);
          return alts.nextSetBit(0);
        }
        previousState = nextState;
        if (t !== Token.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
    }
    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns `null`.
     *
     * @param previousD The current DFA state
     * @param t The next input symbol
     * @returns The existing target DFA state for the given input symbol
     * `t`, or `null` if the target state for this edge is not
     * already cached
     */
    getExistingTargetState(previousD, t) {
      return previousD.edges[t + 1];
    }
    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param dfa The DFA
     * @param previousD The current DFA state
     * @param t The next input symbol
     *
     * @returns The computed target DFA state for the given input symbol
     * `t`. If `t` does not lead to a valid DFA state, this method
     * returns {@link ERROR
     */
    computeTargetState(dfa, previousD, t) {
      const reach = this.computeReachSet(previousD.configs, t, false);
      if (reach === null) {
        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
        return ATNSimulator.ERROR;
      }
      let D = DFAState.fromConfigs(reach);
      const predictedAlt = _ParserATNSimulator.getUniqueAlt(reach);
      if (_ParserATNSimulator.debug) {
        const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        console.log("SLL altSubSets=" + arrayToString(altSubSets) + /*", previous=" + previousD.configs + */
        ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
      }
      if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
        D.isAcceptState = true;
        D.configs.uniqueAlt = predictedAlt;
        D.prediction = predictedAlt;
      } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
        D.configs.conflictingAlts = this.getConflictingAlts(reach);
        D.requiresFullContext = true;
        D.isAcceptState = true;
        D.prediction = D.configs.conflictingAlts.nextSetBit(0);
      }
      if (D.isAcceptState && D.configs.hasSemanticContext) {
        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
        if (D.predicates !== null) {
          D.prediction = ATN.INVALID_ALT_NUMBER;
        }
      }
      D = this.addDFAEdge(dfa, previousD, t, D);
      return D;
    }
    getRuleName(index) {
      if (this.parser !== null && index >= 0) {
        return this.parser.ruleNames[index];
      } else {
        return "<rule " + index + ">";
      }
    }
    getTokenName(t) {
      if (t === Token.EOF) {
        return "EOF";
      }
      const vocabulary = this.parser?.vocabulary ?? Vocabulary.EMPTY_VOCABULARY;
      const displayName = vocabulary.getDisplayName(t);
      if (displayName === t.toString()) {
        return displayName;
      }
      return displayName + "<" + t + ">";
    }
    getLookaheadName(input) {
      return this.getTokenName(input.LA(1));
    }
    /**
     * Used for debugging in adaptivePredict around execATN but I cut
     * it out for clarity now that alg. works well. We can leave this
     * "dead" code for a bit
     */
    dumpDeadEndConfigs(e) {
      console.log("dead end configs: ");
      const decs = e.deadEndConfigs;
      for (const c of decs) {
        let trans = "no edges";
        if (c.state.transitions.length > 0) {
          const t = c.state.transitions[0];
          if (t instanceof AtomTransition) {
            trans = "Atom " + this.getTokenName(t.labelValue);
          } else if (t instanceof SetTransition) {
            const neg = t instanceof NotSetTransition;
            trans = (neg ? "~" : "") + "Set " + t.label;
          }
        }
        console.error(c.toString(this.parser, true) + ":" + trans);
      }
    }
    predicateDFAState(dfaState, decisionState) {
      const altCount = decisionState.transitions.length;
      const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
      const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, altCount);
      if (altToPred !== null) {
        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
        dfaState.prediction = ATN.INVALID_ALT_NUMBER;
      } else {
        dfaState.prediction = altsToCollectPredsFrom.nextSetBit(0);
      }
    }
    // comes back with reach.uniqueAlt set to a valid alt
    execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {
      if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
        console.log("execATNWithFullContext " + s0);
      }
      const fullCtx = true;
      let foundExactAmbig = false;
      let reach;
      let previous = s0;
      input.seek(startIndex);
      let t = input.LA(1);
      let predictedAlt = -1;
      for (; ; ) {
        reach = this.computeReachSet(previous, t, fullCtx);
        if (reach === null) {
          const e = this.noViableAlt(input, outerContext, previous, startIndex);
          input.seek(startIndex);
          const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
          if (alt !== ATN.INVALID_ALT_NUMBER) {
            return alt;
          } else {
            throw e;
          }
        }
        const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        if (_ParserATNSimulator.debug) {
          console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));
        }
        reach.uniqueAlt = _ParserATNSimulator.getUniqueAlt(reach);
        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
          predictedAlt = reach.uniqueAlt;
          break;
        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
          predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
          if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
            break;
          }
        } else {
          if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
            foundExactAmbig = true;
            predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
            break;
          }
        }
        previous = reach;
        if (t !== Token.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
        return predictedAlt;
      }
      this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, reach.getAlts(), reach);
      return predictedAlt;
    }
    computeReachSet(closure, t, fullCtx) {
      if (_ParserATNSimulator.debug) {
        console.log("in computeReachSet, starting closure: " + closure);
      }
      const intermediate = new ATNConfigSet(fullCtx);
      let skippedStopStates = null;
      for (const c of closure) {
        if (_ParserATNSimulator.debug) {
          console.log("testing " + this.getTokenName(t) + " at " + c);
        }
        if (c.state instanceof RuleStopState) {
          if (fullCtx || t === Token.EOF) {
            if (skippedStopStates === null) {
              skippedStopStates = [];
            }
            skippedStopStates.push(c);
          }
          continue;
        }
        for (const trans of c.state.transitions) {
          const target = this.getReachableTarget(trans, t);
          if (target !== null) {
            const cfg = ATNConfig.createWithConfig(target, c);
            intermediate.add(cfg, this.mergeCache);
            if (_ParserATNSimulator.debugAdd) {
              console.log("added " + cfg + " to intermediate");
            }
          }
        }
      }
      let reach = null;
      if (skippedStopStates === null && t !== Token.EOF) {
        if (intermediate.length === 1) {
          reach = intermediate;
        } else if (_ParserATNSimulator.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {
          reach = intermediate;
        }
      }
      if (reach === null) {
        reach = new ATNConfigSet(fullCtx);
        const closureBusy = new HashSet();
        const treatEofAsEpsilon = t === Token.EOF;
        for (const config of intermediate) {
          this.closure(config, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
        }
      }
      if (t === Token.EOF) {
        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
      }
      if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
        for (const config of skippedStopStates) {
          reach.add(config, this.mergeCache);
        }
      }
      if (_ParserATNSimulator.traceATNSimulator) {
        console.log("computeReachSet " + closure + " -> " + reach);
      }
      if (reach.length === 0) {
        return null;
      } else {
        return reach;
      }
    }
    /**
     * Return a configuration set containing only the configurations from
     * `configs` which are in a {@link RuleStopState}. If all
     * configurations in `configs` are already in a rule stop state, this
     * method simply returns `configs`.
     *
     * When `lookToEndOfRule` is true, this method uses
     * {@link ATN.nextTokens} for each configuration in `configs` which is
     * not already in a rule stop state to see if a rule stop state is reachable
     * from the configuration via epsilon-only transitions.
     *
     * @param configs the configuration set to update
     * @param lookToEndOfRule when true, this method checks for rule stop states
     * reachable by epsilon-only transitions from each configuration in
     * `configs`.
     *
     * @returns `configs` if all configurations in `configs` are in a
     * rule stop state, otherwise return a new configuration set containing only
     * the configurations from `configs` which are in a rule stop state
     */
    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
      if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
      }
      const result = new ATNConfigSet(configs.fullCtx);
      for (const config of configs) {
        if (config.state instanceof RuleStopState) {
          result.add(config, this.mergeCache);
          continue;
        }
        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
          const nextTokens = this.atn.nextTokens(config.state);
          if (nextTokens.contains(Token.EPSILON)) {
            const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
            result.add(ATNConfig.createWithConfig(endOfRuleState, config), this.mergeCache);
          }
        }
      }
      return result;
    }
    computeStartState(p, ctx, fullCtx) {
      const initialContext = predictionContextFromRuleContext(this.atn, ctx);
      const configs = new ATNConfigSet(fullCtx);
      if (_ParserATNSimulator.traceATNSimulator) {
        console.log("computeStartState from ATN state " + p + " initialContext=" + initialContext.toString(this.parser));
      }
      for (let i = 0; i < p.transitions.length; i++) {
        const target = p.transitions[i].target;
        const c = ATNConfig.createWithContext(target, i + 1, initialContext);
        const closureBusy = new HashSet();
        this.closure(c, configs, closureBusy, true, fullCtx, false);
      }
      return configs;
    }
    /**
     * This method transforms the start state computed by
     * {@link computeStartState} to the special start state used by a
     * precedence DFA for a particular precedence value. The transformation
     * process applies the following changes to the start state's configuration
     * set.
     *
     * 1. Evaluate the precedence predicates for each configuration using
     * {@link SemanticContext//evalPrecedence}.
     * 2. Remove all configurations which predict an alternative greater than
     * 1, for which another configuration that predicts alternative 1 is in the
     * same ATN state with the same prediction context. This transformation is
     * valid for the following reasons:
     * 3. The closure block cannot contain any epsilon transitions which bypass
     * the body of the closure, so all states reachable via alternative 1 are
     * part of the precedence alternatives of the transformed left-recursive
     * rule.
     * 4. The "primary" portion of a left recursive rule cannot contain an
     * epsilon transition, so the only way an alternative other than 1 can exist
     * in a state that is also reachable via alternative 1 is by nesting calls
     * to the left-recursive rule, with the outer calls not being at the
     * preferred precedence level.
     *
     *
     * The prediction context must be considered by this filter to address
     * situations like the following.
     *
     * `
     * ```
     * grammar TA;
     * prog: statement* EOF;
     * statement: letterA | statement letterA 'b' ;
     * letterA: 'a';
     * ```
     * `
     *
     * If the above grammar, the ATN state immediately before the token
     * reference `'a'` in `letterA` is reachable from the left edge
     * of both the primary and closure blocks of the left-recursive rule
     * `statement`. The prediction context associated with each of these
     * configurations distinguishes between them, and prevents the alternative
     * which stepped out to `prog` (and then back in to `statement`
     * from being eliminated by the filter.
     *
     * @param configs The configuration set computed by
     * {@link computeStartState} as the start state for the DFA.
     * @returns The transformed configuration set representing the start state
     * for a precedence DFA at a particular precedence level (determined by
     * calling {@link Parser//getPrecedence})
     */
    applyPrecedenceFilter(configs) {
      const statesFromAlt1 = [];
      const configSet = new ATNConfigSet(configs.fullCtx);
      for (const config of configs) {
        if (config.alt !== 1) {
          continue;
        }
        const updatedContext = config.semanticContext.evalPrecedence(
          this.parser,
          this.predictionState.outerContext
        );
        if (updatedContext === null) {
          continue;
        }
        statesFromAlt1[config.state.stateNumber] = config.context;
        if (updatedContext !== config.semanticContext) {
          configSet.add(ATNConfig.duplicate(config, updatedContext), this.mergeCache);
        } else {
          configSet.add(config, this.mergeCache);
        }
      }
      for (const config of configs) {
        if (config.alt === 1) {
          continue;
        }
        if (!config.precedenceFilterSuppressed) {
          const context = statesFromAlt1[config.state.stateNumber] || null;
          if (context !== null && context.equals(config.context)) {
            continue;
          }
        }
        configSet.add(config, this.mergeCache);
      }
      return configSet;
    }
    getReachableTarget(trans, ttype) {
      if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
      } else {
        return null;
      }
    }
    getPredsForAmbigAlts(ambigAlts, configs, altCount) {
      let altToPred = [];
      for (const c of configs) {
        if (ambigAlts.get(c.alt)) {
          altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] ?? null, c.semanticContext);
        }
      }
      let nPredAlts = 0;
      for (let i = 1; i < altCount + 1; i++) {
        const pred = altToPred[i] ?? null;
        if (pred === null) {
          altToPred[i] = SemanticContext.NONE;
        } else if (pred !== SemanticContext.NONE) {
          nPredAlts += 1;
        }
      }
      if (nPredAlts === 0) {
        altToPred = null;
      }
      if (_ParserATNSimulator.debug) {
        console.log("getPredsForAmbigAlts result " + arrayToString(altToPred));
      }
      return altToPred;
    }
    getPredicatePredictions(ambigAlts, altToPred) {
      const pairs = [];
      let containsPredicate = false;
      for (let i = 1; i < altToPred.length; i++) {
        const pred = altToPred[i];
        if (ambigAlts.get(i)) {
          pairs.push({ pred, alt: i });
        }
        if (pred !== SemanticContext.NONE) {
          containsPredicate = true;
        }
      }
      if (!containsPredicate) {
        return null;
      }
      return pairs;
    }
    /**
     * This method is used to improve the localization of error messages by
     * choosing an alternative rather than throwing a
     * {@link NoViableAltException} in particular prediction scenarios where the
     * {@link ERROR} state was reached during ATN simulation.
     *
     *
     * The default implementation of this method uses the following
     * algorithm to identify an ATN configuration which successfully parsed the
     * decision entry rule. Choosing such an alternative ensures that the
     * {@link ParserRuleContext} returned by the calling rule will be complete
     * and valid, and the syntax error will be reported later at a more
     * localized location.
     *
     * - If a syntactically valid path or paths reach the end of the decision rule and
     * they are semantically valid if predicated, return the min associated alt.
     * - Else, if a semantically invalid but syntactically valid path exist
     * or paths exist, return the minimum associated alt.
     *
     * - Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.
     *
     *
     * In some scenarios, the algorithm described above could predict an
     * alternative which will result in a {@link FailedPredicateException} in
     * the parser. Specifically, this could occur if the *only* configuration
     * capable of successfully parsing to the end of the decision rule is
     * blocked by a semantic predicate. By choosing this alternative within
     * {@link adaptivePredict} instead of throwing a
     * {@link NoViableAltException}, the resulting
     * {@link FailedPredicateException} in the parser will identify the specific
     * predicate which is preventing the parser from successfully parsing the
     * decision rule, which helps developers identify and correct logic errors
     * in semantic predicates.
     *
     * @param configs The ATN configurations which were valid immediately before
     * the {@link ERROR} state was reached
     * @param outerContext The is the \gamma_0 initial parser context from the paper
     * or the parser stack at the instant before prediction commences.
     *
     * @returns The value to return from {@link adaptivePredict}, or
     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
     * identified and {@link adaptivePredict} should report an error instead
     */
    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
      const splitConfigs = this.splitAccordingToSemanticValidity(configs, outerContext);
      const semValidConfigs = splitConfigs[0];
      const semInvalidConfigs = splitConfigs[1];
      let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
      if (alt !== ATN.INVALID_ALT_NUMBER) {
        return alt;
      }
      if (semInvalidConfigs.length > 0) {
        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        }
      }
      return ATN.INVALID_ALT_NUMBER;
    }
    getAltThatFinishedDecisionEntryRule(configs) {
      const alts = [];
      for (const c of configs) {
        if (c.reachesIntoOuterContext || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {
          if (alts.indexOf(c.alt) < 0) {
            alts.push(c.alt);
          }
        }
      }
      if (alts.length === 0) {
        return ATN.INVALID_ALT_NUMBER;
      } else {
        return Math.min(...alts);
      }
    }
    /**
     * Walk the list of configurations and split them according to
     * those that have preds evaluating to true/false.  If no pred, assume
     * true pred and include in succeeded set.  Returns Pair of sets.
     *
     * Create a new set so as not to alter the incoming parameter.
     *
     * Assumption: the input stream has been restored to the starting point
     * prediction, which is where predicates need to evaluate.
     */
    splitAccordingToSemanticValidity(configs, outerContext) {
      const succeeded = new ATNConfigSet(configs.fullCtx);
      const failed = new ATNConfigSet(configs.fullCtx);
      for (const c of configs) {
        if (c.semanticContext !== SemanticContext.NONE) {
          const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
          if (predicateEvaluationResult) {
            succeeded.add(c);
          } else {
            failed.add(c);
          }
        } else {
          succeeded.add(c);
        }
      }
      return [succeeded, failed];
    }
    /**
     * Look through a list of predicate/alt pairs, returning alts for the
     * pairs that win. A `NONE` predicate indicates an alt containing an
     * unpredicated config which behaves as "always true." If !complete
     * then we stop at the first predicate that evaluates to true. This
     * includes pairs with null predicates.
     */
    evalSemanticContext(predPredictions, outerContext, complete) {
      const predictions = new BitSet();
      for (const pair of predPredictions) {
        if (pair.pred === SemanticContext.NONE) {
          predictions.set(pair.alt);
          if (!complete) {
            break;
          }
          continue;
        }
        const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
        if (_ParserATNSimulator.debug || _ParserATNSimulator.dfaDebug) {
          console.log("eval pred " + pair + "=" + predicateEvaluationResult);
        }
        if (predicateEvaluationResult) {
          predictions.set(pair.alt);
          if (!complete) {
            break;
          }
        }
      }
      return predictions;
    }
    // TODO: If we are doing predicates, there is no point in pursuing
    //     closure operations if we reach a DFA state that uniquely predicts
    //     alternative. We will not be caching that DFA state and it is a
    //     waste to pursue the closure. Might have to advance when we do
    //     ambig detection thought :(
    //
    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
      const initialDepth = 0;
      this.closureCheckingStopState(
        config,
        configs,
        closureBusy,
        collectPredicates,
        fullCtx,
        initialDepth,
        treatEofAsEpsilon
      );
    }
    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
      if (_ParserATNSimulator.traceATNSimulator || _ParserATNSimulator.debugClosure) {
        console.log("closure(" + config.toString(this.parser, true) + ")");
      }
      if (config.state instanceof RuleStopState) {
        if (config.context && !config.context.isEmpty()) {
          for (let i = 0; i < config.context.length; i++) {
            if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
              if (fullCtx) {
                configs.add(
                  ATNConfig.createWithConfig(
                    config.state,
                    config,
                    PredictionContext.EMPTY
                  ),
                  this.mergeCache
                );
                continue;
              } else {
                if (_ParserATNSimulator.debug) {
                  console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                }
                this.closure_(
                  config,
                  configs,
                  closureBusy,
                  collectPredicates,
                  fullCtx,
                  depth,
                  treatEofAsEpsilon
                );
              }
              continue;
            }
            const returnState = this.atn.states[config.context.getReturnState(i)];
            const newContext = config.context.getParent(i);
            const c = ATNConfig.createWithContext(returnState, config.alt, newContext, config.semanticContext);
            c.reachesIntoOuterContext = config.reachesIntoOuterContext;
            this.closureCheckingStopState(
              c,
              configs,
              closureBusy,
              collectPredicates,
              fullCtx,
              depth - 1,
              treatEofAsEpsilon
            );
          }
          return;
        } else if (fullCtx) {
          configs.add(config, this.mergeCache);
          return;
        } else {
          if (_ParserATNSimulator.debug) {
            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
          }
        }
      }
      this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
    }
    // Do the actual work of walking epsilon edges//
    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
      const p = config.state;
      if (!p.epsilonOnlyTransitions) {
        configs.add(config, this.mergeCache);
      }
      for (let i = 0; i < p.transitions.length; i++) {
        if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) {
          continue;
        }
        const t = p.transitions[i];
        const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
        const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
        if (c) {
          let newDepth = depth;
          if (config.state.constructor.stateType === ATNState.RULE_STOP) {
            if (this.predictionState.dfa && this.predictionState?.dfa.isPrecedenceDfa) {
              const outermostPrecedenceReturn = t.outermostPrecedenceReturn;
              if (outermostPrecedenceReturn === this.predictionState?.dfa.atnStartState?.ruleIndex) {
                c.precedenceFilterSuppressed = true;
              }
            }
            c.reachesIntoOuterContext = true;
            if (closureBusy.getOrAdd(c) !== c) {
              continue;
            }
            configs.dipsIntoOuterContext = true;
            newDepth -= 1;
            if (_ParserATNSimulator.debug) {
              console.log("dips into outer ctx: " + c);
            }
          } else {
            if (!t.isEpsilon && closureBusy.getOrAdd(c) !== c) {
              continue;
            }
            if (t instanceof RuleTransition) {
              if (newDepth >= 0) {
                newDepth += 1;
              }
            }
          }
          this.closureCheckingStopState(
            c,
            configs,
            closureBusy,
            continueCollecting,
            fullCtx,
            newDepth,
            treatEofAsEpsilon
          );
        }
      }
    }
    canDropLoopEntryEdgeInLeftRecursiveRule(config) {
      const p = config.state;
      if (p.constructor.stateType !== ATNState.STAR_LOOP_ENTRY || !config.context) {
        return false;
      }
      if (!p.precedenceRuleDecision || config.context.isEmpty() || config.context.hasEmptyPath()) {
        return false;
      }
      const numCtxs = config.context.length;
      for (let i = 0; i < numCtxs; i++) {
        const returnState = this.atn.states[config.context.getReturnState(i)];
        if (returnState.ruleIndex !== p.ruleIndex) {
          return false;
        }
      }
      const decisionStartState = p.transitions[0].target;
      const blockEndStateNum = decisionStartState.endState.stateNumber;
      const blockEndState = this.atn.states[blockEndStateNum];
      for (let i = 0; i < numCtxs; i++) {
        const returnStateNumber = config.context.getReturnState(i);
        const returnState = this.atn.states[returnStateNumber];
        if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) {
          return false;
        }
        const returnStateTarget = returnState.transitions[0].target;
        if (returnState.constructor.stateType === ATNState.BLOCK_END && returnStateTarget === p) {
          continue;
        }
        if (returnState === blockEndState) {
          continue;
        }
        if (returnStateTarget === blockEndState) {
          continue;
        }
        if (returnStateTarget.constructor.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) {
          continue;
        }
        return false;
      }
      return true;
    }
    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
      switch (t.transitionType) {
        case Transition.RULE: {
          return this.ruleTransition(config, t);
        }
        case Transition.PRECEDENCE: {
          return this.precedenceTransition(
            config,
            t,
            collectPredicates,
            inContext,
            fullCtx
          );
        }
        case Transition.PREDICATE: {
          return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
        }
        case Transition.ACTION: {
          if (_ParserATNSimulator.debug) {
            const at = t;
            const index = at.actionIndex === -1 ? 65535 : at.actionIndex;
            console.log("ACTION edge " + at.ruleIndex + ":" + index);
          }
          return ATNConfig.createWithConfig(t.target, config);
        }
        case Transition.EPSILON: {
          return ATNConfig.createWithConfig(t.target, config);
        }
        case Transition.ATOM:
        case Transition.RANGE:
        case Transition.SET: {
          if (treatEofAsEpsilon) {
            if (t.matches(Token.EOF, 0, 1)) {
              return ATNConfig.createWithConfig(t.target, config);
            }
          }
          return null;
        }
        default:
          return null;
      }
    }
    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
      if (_ParserATNSimulator.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
        if (this.parser !== null) {
          console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
        }
      }
      let c = null;
      if (collectPredicates && inContext) {
        if (fullCtx && this.predictionState?.input) {
          const currentPosition = this.predictionState.input.index;
          this.predictionState.input.seek(this.predictionState.startIndex);
          const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);
          this.predictionState.input.seek(currentPosition);
          if (predSucceeds) {
            c = ATNConfig.createWithConfig(pt.target, config);
          }
        } else {
          const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
          c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);
        }
      } else {
        c = ATNConfig.createWithConfig(pt.target, config);
      }
      if (_ParserATNSimulator.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
    predTransition(config, pt, collectPredicates, inContext, fullCtx) {
      if (_ParserATNSimulator.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this.parser !== null) {
          console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
        }
      }
      let c = null;
      if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {
        if (fullCtx && this.predictionState?.input) {
          const currentPosition = this.predictionState.input.index;
          this.predictionState.input.seek(this.predictionState.startIndex);
          const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);
          this.predictionState.input.seek(currentPosition);
          if (predSucceeds) {
            c = ATNConfig.createWithConfig(pt.target, config);
          }
        } else {
          const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
          c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);
        }
      } else {
        c = ATNConfig.createWithConfig(pt.target, config);
      }
      if (_ParserATNSimulator.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
    ruleTransition(config, t) {
      if (_ParserATNSimulator.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
      }
      const returnState = t.followState;
      const newContext = SingletonPredictionContext.create(config.context ?? void 0, returnState.stateNumber);
      return ATNConfig.createWithConfig(t.target, config, newContext);
    }
    getConflictingAlts(configs) {
      const altSets = PredictionMode.getConflictingAltSubsets(configs);
      return PredictionMode.getAlts(altSets);
    }
    /**
     * Sam pointed out a problem with the previous definition, v3, of
     * ambiguous states. If we have another state associated with conflicting
     * alternatives, we should keep going. For example, the following grammar
     *
     * s : (ID | ID ID?) ';' ;
     *
     * When the ATN simulation reaches the state before ';', it has a DFA
     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
     * because alternative to has another way to continue, via [6|2|[]].
     * The key is that we have a single state that has config's only associated
     * with a single alternative, 2, and crucially the state transitions
     * among the configurations are all non-epsilon transitions. That means
     * we don't consider any conflicts that include alternative 2. So, we
     * ignore the conflict between alts 1 and 2. We ignore a set of
     * conflicting alts when there is an intersection with an alternative
     * associated with a single alt state in the state -> config-list map.
     *
     * It's also the case that we might have two conflicting configurations but
     * also a 3rd nonconflicting configuration for a different alternative:
     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
     *
     * a : A | A | A B ;
     *
     * After matching input A, we reach the stop state for rule A, state 1.
     * State 8 is the state right before B. Clearly alternatives 1 and 2
     * conflict and no amount of further lookahead will separate the two.
     * However, alternative 3 will be able to continue and so we do not
     * stop working on this state. In the previous example, we're concerned
     * with states associated with the conflicting alternatives. Here alt
     * 3 is not associated with the conflicting configs, but since we can continue
     * looking for input reasonably, I don't declare the state done. We
     * ignore a set of conflicting alts when we have an alternative
     * that we still need to pursue
     */
    getConflictingAltsOrUniqueAlt(configs) {
      let conflictingAlts;
      if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet();
        conflictingAlts.set(configs.uniqueAlt);
      } else {
        conflictingAlts = configs.conflictingAlts;
      }
      return conflictingAlts;
    }
    noViableAlt(input, outerContext, configs, startIndex) {
      return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
    }
    /**
     * Add an edge to the DFA, if possible. This method calls
     * {@link addDFAState} to ensure the `to` state is present in the
     * DFA. If `from` is `null`, or if `t` is outside the
     * range of edges that can be represented in the DFA tables, this method
     * returns without adding the edge to the DFA.
     *
     * If `to` is `null`, this method returns `null`.
     * Otherwise, this method returns the {@link DFAState} returned by calling
     * {@link addDFAState} for the `to` state.
     *
     * @param dfa The DFA
     * @param from The source state for the edge
     * @param t The input symbol
     * @param to The target state for the edge
     *
     * @returns If `to` is `null`, this method returns `null`;
     * otherwise this method returns the result of calling {@link addDFAState}
     * on `to`
     */
    addDFAEdge(dfa, from, t, to) {
      if (_ParserATNSimulator.debug) {
        console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
      }
      to = this.addDFAState(dfa, to);
      if (t < -1 || t > this.atn.maxTokenType) {
        return to;
      }
      if (_ParserATNSimulator.debug) {
        console.log("DFA=\n" + dfa.toString(this.parser != null ? this.parser.vocabulary : Vocabulary.EMPTY_VOCABULARY));
      }
      from.edges[t + 1] = to;
      return to;
    }
    /**
     * Add state `D` to the DFA if it is not already present, and return
     * the actual instance stored in the DFA. If a state equivalent to `D`
     * is already in the DFA, the existing state is returned. Otherwise this
     * method returns `D` after adding it to the DFA.
     *
     * If `D` is {@link ERROR}, this method returns {@link ERROR} and
     * does not change the DFA.
     *
     * @param dfa The dfa.
     * @param newState The DFA state to add.
     *
     * @returns The state stored in the DFA. This will be either the existing state if `newState` is already in
     *          the DFA, or `newState` itself if the state was not already present.
     */
    addDFAState(dfa, newState) {
      if (newState === ATNSimulator.ERROR) {
        return newState;
      }
      const existing = dfa.getState(newState);
      if (existing !== null) {
        return existing;
      }
      if (!newState.configs.readOnly) {
        newState.configs.optimizeConfigs(this);
        newState.configs.setReadonly(true);
      }
      if (_ParserATNSimulator.traceATNSimulator) {
        console.log("addDFAState new " + newState);
      }
      dfa.addState(newState);
      return newState;
    }
    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
      if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
        const interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
      }
      this.parser.errorListenerDispatch.reportAttemptingFullContext(
        this.parser,
        dfa,
        startIndex,
        stopIndex,
        conflictingAlts,
        configs
      );
    }
    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
      if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
        const interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
      }
      this.parser.errorListenerDispatch.reportContextSensitivity(
        this.parser,
        dfa,
        startIndex,
        stopIndex,
        prediction,
        configs
      );
    }
    // If context sensitive parsing, we know it's ambiguity not conflict.
    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
        const interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
      }
      this.parser.errorListenerDispatch.reportAmbiguity(
        this.parser,
        dfa,
        startIndex,
        stopIndex,
        exact,
        ambigAlts,
        configs
      );
    }
  };
  var PredictionContextCache = class {
    static {
      __name(this, "PredictionContextCache");
    }
    cache = new HashMap(ObjectEqualityComparator.instance);
    /**
     * Add a context to the cache and return it. If the context already exists,
     * return that one instead and do not add a new context to the cache.
     * Protect shared cache from unsafe thread access.
     *
     * @param ctx tbd
     * @returns tbd
     */
    add(ctx) {
      if (ctx === PredictionContext.EMPTY) {
        return ctx;
      }
      const existing = this.cache.get(ctx);
      if (existing) {
        return existing;
      }
      this.cache.set(ctx, ctx);
      return ctx;
    }
    get(ctx) {
      return this.cache.get(ctx);
    }
    get length() {
      return this.cache.size;
    }
  };
  var ProfilingATNSimulator = class extends ParserATNSimulator {
    static {
      __name(this, "ProfilingATNSimulator");
    }
    decisions;
    numDecisions = 0;
    currentDecision = 0;
    currentState;
    /**
     * At the point of LL failover, we record how SLL would resolve the conflict so that
     *  we can determine whether or not a decision / input pair is context-sensitive.
     *  If LL gives a different result than SLL's predicted alternative, we have a
     *  context sensitivity for sure. The converse is not necessarily true, however.
     *  It's possible that after conflict resolution chooses minimum alternatives,
     *  SLL could get the same answer as LL. Regardless of whether or not the result indicates
     *  an ambiguity, it is not treated as a context sensitivity because LL prediction
     *  was not required in order to produce a correct prediction for this decision and input sequence.
     *  It may in fact still be a context sensitivity but we don't know by looking at the
     *  minimum alternatives for the current input.
     */
    conflictingAltResolvedBySLL;
    sllStopIndex = 0;
    llStopIndex = 0;
    constructor(parser) {
      const sharedContextCache = parser.interpreter.sharedContextCache;
      super(parser, parser.interpreter.atn, parser.interpreter.decisionToDFA, sharedContextCache);
      if (sharedContextCache) {
        this.numDecisions = this.atn.decisionToState.length;
        this.decisions = new Array(this.numDecisions);
        for (let i = 0; i < this.numDecisions; i++) {
          this.decisions[i] = new DecisionInfo(i);
        }
      }
    }
    adaptivePredict(input, decision, outerContext) {
      try {
        this.sllStopIndex = -1;
        this.llStopIndex = -1;
        this.currentDecision = decision;
        const start = performance.now();
        const alt = super.adaptivePredict(input, decision, outerContext);
        const stop = performance.now();
        this.decisions[decision].timeInPrediction += stop - start;
        this.decisions[decision].invocations++;
        const sllLook = this.sllStopIndex - this.predictionState.startIndex + 1;
        this.decisions[decision].sllTotalLook += sllLook;
        this.decisions[decision].sllMinLook = this.decisions[decision].sllMinLook === 0 ? sllLook : Math.min(this.decisions[decision].sllMinLook, sllLook);
        if (sllLook > this.decisions[decision].sllMaxLook) {
          this.decisions[decision].sllMaxLook = sllLook;
          this.decisions[decision].sllMaxLookEvent = {
            decision,
            configs: null,
            predictedAlt: alt,
            input,
            startIndex: this.predictionState.startIndex,
            stopIndex: this.sllStopIndex,
            fullCtx: false
          };
        }
        if (this.llStopIndex >= 0) {
          const llLook = this.llStopIndex - this.predictionState.startIndex + 1;
          this.decisions[decision].llTotalLook += llLook;
          this.decisions[decision].llMinLook = this.decisions[decision].llMinLook === 0 ? llLook : Math.min(this.decisions[decision].llMinLook, llLook);
          if (llLook > this.decisions[decision].llMaxLook) {
            this.decisions[decision].llMaxLook = llLook;
            this.decisions[decision].llMaxLookEvent = {
              decision,
              configs: null,
              predictedAlt: alt,
              input,
              startIndex: this.predictionState.startIndex,
              stopIndex: this.llStopIndex,
              fullCtx: true
            };
          }
        }
        return alt;
      } finally {
        this.currentDecision = -1;
      }
    }
    getExistingTargetState(previousD, t) {
      if (this.predictionState?.input) {
        this.sllStopIndex = this.predictionState.input.index;
        const existingTargetState = super.getExistingTargetState(previousD, t);
        if (existingTargetState !== null) {
          this.decisions[this.currentDecision].sllDFATransitions++;
          if (existingTargetState === ATNSimulator.ERROR) {
            this.decisions[this.currentDecision].errors.push({
              decision: this.currentDecision,
              configs: previousD.configs,
              input: this.predictionState.input,
              startIndex: this.predictionState.startIndex,
              stopIndex: this.sllStopIndex,
              fullCtx: false
            });
          }
        }
        this.currentState = existingTargetState;
        return existingTargetState;
      }
      return void 0;
    }
    computeTargetState(dfa, previousD, t) {
      const state = super.computeTargetState(dfa, previousD, t);
      this.currentState = state;
      return state;
    }
    computeReachSet(closure, t, fullCtx) {
      if (fullCtx && this.predictionState?.input) {
        this.llStopIndex = this.predictionState.input.index;
      }
      const reachConfigs = super.computeReachSet(closure, t, fullCtx);
      if (this.predictionState?.input) {
        if (fullCtx) {
          this.decisions[this.currentDecision].llATNTransitions++;
          if (reachConfigs === null) {
            this.decisions[this.currentDecision].errors.push({
              decision: this.currentDecision,
              configs: closure,
              input: this.predictionState.input,
              startIndex: this.predictionState.startIndex,
              stopIndex: this.sllStopIndex,
              fullCtx: true
            });
          }
        } else {
          this.decisions[this.currentDecision].sllATNTransitions++;
          if (reachConfigs === null) {
            this.decisions[this.currentDecision].errors.push({
              decision: this.currentDecision,
              configs: closure,
              input: this.predictionState.input,
              startIndex: this.predictionState.startIndex,
              stopIndex: this.sllStopIndex,
              fullCtx: false
            });
          }
        }
      }
      return reachConfigs;
    }
    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
      if (conflictingAlts !== null) {
        this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
      } else {
        this.conflictingAltResolvedBySLL = configs.getAlts().nextSetBit(0);
      }
      this.decisions[this.currentDecision].llFallback++;
      if (conflictingAlts) {
        super.reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex);
      }
    }
    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
      if (prediction !== this.conflictingAltResolvedBySLL && this.predictionState.input) {
        this.decisions[this.currentDecision].contextSensitivities.push({
          decision: this.currentDecision,
          configs,
          input: this.predictionState.input,
          startIndex,
          stopIndex,
          fullCtx: true
        });
      }
      super.reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex);
    }
    reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs) {
      let prediction;
      if (ambigAlts) {
        prediction = ambigAlts.nextSetBit(0);
      } else {
        prediction = configs.getAlts().nextSetBit(0);
      }
      if (this.predictionState?.input) {
        if (configs.fullCtx && prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push({
            decision: this.currentDecision,
            configs,
            input: this.predictionState.input,
            startIndex,
            stopIndex,
            fullCtx: true
          });
        }
        this.decisions[this.currentDecision].ambiguities.push({
          ambigAlts,
          decision: this.currentDecision,
          configs,
          input: this.predictionState.input,
          startIndex,
          stopIndex,
          fullCtx: configs.fullCtx
        });
      }
      super.reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs);
    }
    getDecisionInfo() {
      return this.decisions;
    }
    getCurrentState() {
      return this.currentState;
    }
  };
  var PredPrediction;
  ((PredPrediction2) => {
    PredPrediction2.toString = /* @__PURE__ */ __name((prediction) => {
      return `(${prediction.pred}, ${prediction.alt})`;
    }, "toString");
  })(PredPrediction || (PredPrediction = {}));
  var ParseCancellationException = class _ParseCancellationException extends Error {
    static {
      __name(this, "ParseCancellationException");
    }
    constructor(_e) {
      super();
      Error.captureStackTrace(this, _ParseCancellationException);
    }
  };
  var InterpreterDataReader = class {
    static {
      __name(this, "InterpreterDataReader");
    }
    /**
     * The structure of the data file is very simple. Everything is line based with empty lines
     * separating the different parts. For lexers the layout is:
     * token literal names:
     * ...
     *
     * token symbolic names:
     * ...
     *
     * rule names:
     * ...
     *
     * channel names:
     * ...
     *
     * mode names:
     * ...
     *
     * atn:
     * a single line with comma separated int values, enclosed in a pair of squared brackets.
     *
     * Data for a parser does not contain channel and mode names.
     */
    static parseInterpreterData(source) {
      const ruleNames = [];
      const channels = [];
      const modes = [];
      const literalNames = [];
      const symbolicNames = [];
      const lines = source.split("\n");
      let index = 0;
      let line = lines[index++];
      if (line !== "token literal names:") {
        throw new Error("Unexpected data entry");
      }
      do {
        line = lines[index++];
        if (line.length === 0) {
          break;
        }
        literalNames.push(line === "null" ? null : line);
      } while (true);
      line = lines[index++];
      if (line !== "token symbolic names:") {
        throw new Error("Unexpected data entry");
      }
      do {
        line = lines[index++];
        if (line.length === 0) {
          break;
        }
        symbolicNames.push(line === "null" ? null : line);
      } while (true);
      line = lines[index++];
      if (line !== "rule names:") {
        throw new Error("Unexpected data entry");
      }
      do {
        line = lines[index++];
        if (line.length === 0) {
          break;
        }
        ruleNames.push(line);
      } while (true);
      line = lines[index++];
      if (line === "channel names:") {
        do {
          line = lines[index++];
          if (line.length === 0) {
            break;
          }
          channels.push(line);
        } while (true);
        line = lines[index++];
        if (line !== "mode names:") {
          throw new Error("Unexpected data entry");
        }
        do {
          line = lines[index++];
          if (line.length === 0) {
            break;
          }
          modes.push(line);
        } while (true);
      }
      line = lines[index++];
      if (line !== "atn:") {
        throw new Error("Unexpected data entry");
      }
      line = lines[index++];
      const elements = line.split(",");
      let value;
      const serializedATN = [];
      for (let i = 0; i < elements.length; ++i) {
        const element = elements[i];
        if (element.startsWith("[")) {
          value = Number(element.substring(1).trim());
        } else if (element.endsWith("]")) {
          value = Number(element.substring(0, element.length - 1).trim());
        } else {
          value = Number(element.trim());
        }
        serializedATN[i] = value;
      }
      const deserializer = new ATNDeserializer();
      return {
        atn: deserializer.deserialize(serializedATN),
        vocabulary: new Vocabulary(literalNames, symbolicNames, []),
        ruleNames,
        channels: channels.length > 0 ? channels : void 0,
        modes: modes.length > 0 ? modes : void 0
      };
    }
  };
  var AbstractParseTreeVisitor = class {
    static {
      __name(this, "AbstractParseTreeVisitor");
    }
    visit(tree) {
      return tree.accept(this);
    }
    visitChildren(node) {
      let result = this.defaultResult();
      const n2 = node.getChildCount();
      for (let i = 0; i < n2; i++) {
        if (!this.shouldVisitNextChild(node, result)) {
          break;
        }
        const c = node.getChild(i);
        if (c) {
          const childResult = c.accept(this);
          result = this.aggregateResult(result, childResult);
        }
      }
      return result;
    }
    visitTerminal(_node) {
      return this.defaultResult();
    }
    visitErrorNode(_node) {
      return this.defaultResult();
    }
    defaultResult() {
      return null;
    }
    shouldVisitNextChild(_node, _currentResult) {
      return true;
    }
    aggregateResult(aggregate, nextResult) {
      return nextResult;
    }
  };
  var ParseTreeWalker = class _ParseTreeWalker {
    static {
      __name(this, "ParseTreeWalker");
    }
    static DEFAULT = new _ParseTreeWalker();
    /**
     * Performs a walk on the given parse tree starting at the root and going down recursively
     * with depth-first search. On each node, {@link ParseTreeWalker.enterRule} is called before
     * recursively walking down into child nodes, then
     * {@link ParseTreeWalker.exitRule} is called after the recursive call to wind up.
     *
     * @param listener The listener used by the walker to process grammar rules
     * @param t The parse tree to be walked on
     */
    walk(listener, t) {
      const errorNode = t instanceof ErrorNode;
      if (errorNode) {
        listener.visitErrorNode(t);
      } else if (t instanceof TerminalNode) {
        listener.visitTerminal(t);
      } else {
        const r = t;
        this.enterRule(listener, r);
        for (let i = 0; i < t.getChildCount(); i++) {
          this.walk(listener, t.getChild(i));
        }
        this.exitRule(listener, r);
      }
    }
    /**
     * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener.enterEveryRule}
     * then by triggering the event specific to the given parse tree node
     *
     * @param listener The listener responding to the trigger events
     * @param r The grammar rule containing the rule context
     */
    enterRule(listener, r) {
      const ctx = r.ruleContext;
      listener.enterEveryRule(ctx);
      ctx.enterRule(listener);
    }
    /**
     * Exits a grammar rule by first triggering the event specific to the given parse tree node
     * then by triggering the generic event {@link ParseTreeListener.exitEveryRule}
     *
     * @param listener The listener responding to the trigger events
     * @param r The grammar rule containing the rule context
     */
    exitRule(listener, r) {
      const ctx = r.ruleContext;
      ctx.exitRule(listener);
      listener.exitEveryRule(ctx);
    }
  };
  var CharStream;
  ((CharStream2) => {
    CharStream2.fromString = /* @__PURE__ */ __name((str) => {
      return new CharStreamImpl(str);
    }, "fromString");
  })(CharStream || (CharStream = {}));
  var CharStreamImpl = class {
    static {
      __name(this, "CharStreamImpl");
    }
    name = "";
    index = 0;
    data;
    constructor(input) {
      const codePoints = [];
      for (const char of input) {
        codePoints.push(char.codePointAt(0));
      }
      this.data = new Uint32Array(codePoints);
    }
    /**
     * Reset the stream so that it's in the same state it was
     * when the object was created *except* the data array is not
     * touched.
     */
    reset() {
      this.index = 0;
    }
    consume() {
      if (this.index >= this.data.length) {
        throw new Error("cannot consume EOF");
      }
      this.index += 1;
    }
    LA(offset) {
      if (offset === 0) {
        return 0;
      }
      if (offset < 0) {
        offset += 1;
      }
      const pos = this.index + offset - 1;
      if (pos < 0 || pos >= this.data.length) {
        return Token.EOF;
      }
      return this.data[pos];
    }
    // mark/release do nothing; we have entire buffer
    mark() {
      return -1;
    }
    release(_marker) {
    }
    /**
     * consume() ahead until p==_index; can't just set p=_index as we must
     * update line and column. If we seek backwards, just set p
     */
    seek(index) {
      if (index <= this.index) {
        this.index = index;
        return;
      }
      this.index = Math.min(index, this.data.length);
    }
    getTextFromRange(start, stop) {
      stop = stop ?? this.data.length - 1;
      if (stop >= this.data.length) {
        stop = this.data.length - 1;
      }
      if (start >= this.data.length) {
        return "";
      }
      return this.stringFromRange(start, stop + 1);
    }
    getTextFromInterval(interval) {
      const start = interval.start;
      let stop = interval.stop;
      if (stop >= this.data.length) {
        stop = this.data.length - 1;
      }
      if (start >= this.data.length) {
        return "";
      }
      return this.stringFromRange(start, stop + 1);
    }
    toString() {
      return this.stringFromRange(0);
    }
    get size() {
      return this.data.length;
    }
    getSourceName() {
      if (this.name) {
        return this.name;
      }
      return IntStream.UNKNOWN_SOURCE_NAME;
    }
    stringFromRange(start, stop) {
      const data = this.data.slice(start, stop);
      let result = "";
      data.forEach((value) => {
        result += String.fromCodePoint(value);
      });
      return result;
    }
  };
  var BufferedTokenStream = class {
    static {
      __name(this, "BufferedTokenStream");
    }
    /**
     * The {@link TokenSource} from which tokens for this stream are fetched.
     */
    tokenSource;
    /**
     * A collection of all tokens fetched from the token source. The list is
     * considered a complete view of the input once {@link fetchedEOF} is set
     * to `true`.
     */
    tokens = [];
    /**
     * The index into {@link tokens} of the current token (next token to
     * {@link consume}). {@link tokens}`[p]` should be
     * {@link LT LT(1)}.
     *
     * This field is set to -1 when the stream is first constructed or when
     * {@link setTokenSource} is called, indicating that the first token has
     * not yet been fetched from the token source. For additional information,
     * see the documentation of {@link IntStream} for a description of
     * Initializing Methods.
     */
    p = -1;
    /**
     * Indicates whether the {@link Token.EOF} token has been fetched from
     * {@link tokenSource} and added to {@link tokens}. This field improves
     * performance for the following cases:
     *
     * - {@link consume}: The lookahead check in {@link consume} to prevent
     * consuming the EOF symbol is optimized by checking the values of
     * {@link fetchedEOF} and {@link p} instead of calling {@link LA}.
     * - {@link fetch}: The check to prevent adding multiple EOF symbols into
     * {@link tokens} is trivial with this field.
     */
    fetchedEOF = false;
    constructor(tokenSource) {
      this.tokenSource = tokenSource;
    }
    mark() {
      return 0;
    }
    release(_marker) {
    }
    reset() {
      this.seek(0);
    }
    seek(index) {
      this.lazyInit();
      this.p = this.adjustSeekIndex(index);
    }
    get size() {
      return this.tokens.length;
    }
    get index() {
      return this.p;
    }
    get(index) {
      this.lazyInit();
      return this.tokens[index];
    }
    consume() {
      let skipEofCheck = false;
      if (this.p >= 0) {
        if (this.fetchedEOF) {
          skipEofCheck = this.p < this.tokens.length - 1;
        } else {
          skipEofCheck = this.p < this.tokens.length;
        }
      } else {
        skipEofCheck = false;
      }
      if (!skipEofCheck && this.LA(1) === Token.EOF) {
        throw new Error("cannot consume EOF");
      }
      if (this.sync(this.p + 1)) {
        this.p = this.adjustSeekIndex(this.p + 1);
      }
    }
    /**
     * Make sure index `i` in tokens has a token.
     *
     * @returns {boolean} `true` if a token is located at index `i`, otherwise `false`.
     */
    sync(i) {
      const n2 = i - this.tokens.length + 1;
      if (n2 > 0) {
        const fetched = this.fetch(n2);
        return fetched >= n2;
      }
      return true;
    }
    /**
     * Add `n` elements to buffer.
     *
     * @returns {number} The actual number of elements added to the buffer.
     */
    fetch(n2) {
      if (this.fetchedEOF) {
        return 0;
      }
      for (let i = 0; i < n2; i++) {
        const t = this.tokenSource.nextToken();
        t.tokenIndex = this.tokens.length;
        this.tokens.push(t);
        if (t.type === Token.EOF) {
          this.fetchedEOF = true;
          return i + 1;
        }
      }
      return n2;
    }
    /** Get all tokens from start..stop, inclusively. */
    getTokens(start, stop, types) {
      this.lazyInit();
      if (start === void 0 && stop === void 0) {
        return this.tokens;
      }
      start ??= 0;
      if (stop === void 0) {
        stop = this.tokens.length - 1;
      }
      if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
        throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
      }
      if (start > stop) {
        return [];
      }
      if (types === void 0) {
        return this.tokens.slice(start, stop + 1);
      }
      const subset = [];
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      for (let i = start; i < stop; i++) {
        const t = this.tokens[i];
        if (t.type === Token.EOF) {
          subset.push(t);
          break;
        }
        if (types.has(t.type)) {
          subset.push(t);
        }
      }
      return subset;
    }
    LA(k) {
      return this.LT(k)?.type ?? Token.INVALID_TYPE;
    }
    LB(k) {
      if (this.p - k < 0) {
        return null;
      }
      return this.tokens[this.p - k];
    }
    LT(k) {
      this.lazyInit();
      if (k === 0) {
        return null;
      }
      if (k < 0) {
        return this.LB(-k);
      }
      const i = this.p + k - 1;
      this.sync(i);
      if (i >= this.tokens.length) {
        return this.tokens[this.tokens.length - 1];
      }
      return this.tokens[i];
    }
    /**
     * Allowed derived classes to modify the behavior of operations which change
     * the current stream position by adjusting the target token index of a seek
     * operation. The default implementation simply returns `i`. If an
     * exception is thrown in this method, the current stream index should not be
     * changed.
     *
     * For example, {@link CommonTokenStream} overrides this method to ensure that
     * the seek target is always an on-channel token.
     *
     * @param  i The target token index.
     *
     * @returns The adjusted target token index.
     */
    adjustSeekIndex(i) {
      return i;
    }
    lazyInit() {
      if (this.p === -1) {
        this.setup();
      }
    }
    setup() {
      this.sync(0);
      this.p = this.adjustSeekIndex(0);
    }
    /** Reset this token stream by setting its token source. */
    setTokenSource(tokenSource) {
      this.tokenSource = tokenSource;
      this.tokens = [];
      this.p = -1;
      this.fetchedEOF = false;
    }
    /**
     * Given a starting index, return the index of the next token on channel.
     * Return i if tokens[i] is on channel. Return -1 if there are no tokens
     * on channel between i and EOF.
     */
    nextTokenOnChannel(i, channel) {
      this.sync(i);
      if (i >= this.tokens.length) {
        return -1;
      }
      let token = this.tokens[i];
      while (token.channel !== channel) {
        if (token.type === Token.EOF) {
          return -1;
        }
        i += 1;
        this.sync(i);
        token = this.tokens[i];
      }
      return i;
    }
    /**
     * Given a starting index, return the index of the previous token on
     * channel. Return `i` if `tokens[i]` is on channel. Return -1
     * if there are no tokens on channel between `i` and 0.
     *
     * If `i` specifies an index at or after the EOF token, the EOF token
     * index is returned. This is due to the fact that the EOF token is treated
     * as though it were on every channel.
     */
    previousTokenOnChannel(i, channel) {
      if (i >= this.tokens.length) {
        return this.tokens.length - 1;
      }
      while (i >= 0) {
        const token = this.tokens[i];
        if (token.type === Token.EOF || token.channel === channel) {
          return i;
        }
        --i;
      }
      return i;
    }
    /**
     * Collect all tokens on specified channel to the right of
     * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
     * EOF. If channel is -1, find any non default channel token.
     */
    getHiddenTokensToRight(tokenIndex, channel) {
      if (channel === void 0) {
        channel = -1;
      }
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);
      }
      const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
      const from = tokenIndex + 1;
      const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
      return this.filterForChannel(from, to, channel);
    }
    /**
     * Collect all tokens on specified channel to the left of
     * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
     * If channel is -1, find any non default channel token.
     */
    getHiddenTokensToLeft(tokenIndex, channel) {
      if (channel === void 0) {
        channel = -1;
      }
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);
      }
      const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
      if (prevOnChannel === tokenIndex - 1) {
        return void 0;
      }
      const from = prevOnChannel + 1;
      const to = tokenIndex - 1;
      return this.filterForChannel(from, to, channel);
    }
    filterForChannel(left, right, channel) {
      const hidden = [];
      for (let i = left; i < right + 1; i++) {
        const t = this.tokens[i];
        if (channel === -1) {
          if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
            hidden.push(t);
          }
        } else if (t.channel === channel) {
          hidden.push(t);
        }
      }
      if (hidden.length === 0) {
        return void 0;
      }
      return hidden;
    }
    getSourceName() {
      return this.tokenSource.sourceName;
    }
    /** Get the text of all tokens in this buffer. */
    getText() {
      return this.getTextFromInterval(Interval.of(0, this.size - 1));
    }
    getTextFromInterval(interval) {
      const start = interval.start;
      let stop = interval.stop;
      if (start < 0 || stop < 0) {
        return "";
      }
      this.sync(stop);
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      let result = "";
      for (let i = start; i <= stop; ++i) {
        const t = this.tokens[i];
        if (t.type === Token.EOF) {
          break;
        }
        result += t.text;
      }
      return result;
    }
    getTextFromContext(ctx) {
      return this.getTextFromInterval(ctx.getSourceInterval());
    }
    getTextFromRange(start, stop) {
      if (start !== null && stop !== null) {
        return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));
      }
      return "";
    }
    /** Get all tokens from lexer until EOF. */
    fill() {
      this.lazyInit();
      while (this.fetch(1e3) === 1e3) {
        ;
      }
    }
    setLine(line) {
      this.tokenSource.line = line;
    }
    setColumn(column) {
      this.tokenSource.column = column;
    }
  };
  var CommonTokenStream = class extends BufferedTokenStream {
    static {
      __name(this, "CommonTokenStream");
    }
    /**
     * Specifies the channel to use for filtering tokens.
     *
     *
     * The default value is {@link Token.DEFAULT_CHANNEL}, which matches the
     * default channel assigned to tokens created by the lexer.
     */
    channel = Token.DEFAULT_CHANNEL;
    constructor(lexer, channel) {
      super(lexer);
      this.channel = channel ?? Token.DEFAULT_CHANNEL;
    }
    adjustSeekIndex(i) {
      return this.nextTokenOnChannel(i, this.channel);
    }
    LB(k) {
      if (k === 0 || this.index - k < 0) {
        return null;
      }
      let i = this.index;
      let n2 = 1;
      while (n2 <= k) {
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n2 += 1;
      }
      if (i < 0) {
        return null;
      }
      return this.tokens[i];
    }
    LT(k) {
      this.lazyInit();
      if (k === 0) {
        return null;
      }
      if (k < 0) {
        return this.LB(-k);
      }
      let i = this.index;
      let n2 = 1;
      while (n2 < k) {
        if (this.sync(i + 1)) {
          i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n2 += 1;
      }
      return this.tokens[i];
    }
    // Count EOF just once.
    getNumberOfOnChannelTokens() {
      let n2 = 0;
      this.fill();
      for (const t of this.tokens) {
        if (t.channel === this.channel) {
          n2 += 1;
        }
        if (t.type === Token.EOF) {
          break;
        }
      }
      return n2;
    }
  };
  var XPathLexer = class _XPathLexer extends Lexer {
    static {
      __name(this, "XPathLexer");
    }
    static TOKEN_REF = 1;
    static RULE_REF = 2;
    static ANYWHERE = 3;
    static ROOT = 4;
    static WILDCARD = 5;
    static BANG = 6;
    static ID = 7;
    static STRING = 8;
    static channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    static literalNames = [
      null,
      null,
      null,
      "'//'",
      "'/'",
      "'*'",
      "'!'"
    ];
    static symbolicNames = [
      null,
      "TOKEN_REF",
      "RULE_REF",
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "STRING"
    ];
    static modeNames = [
      "DEFAULT_MODE"
    ];
    static ruleNames = [
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "NameChar",
      "NameStartChar",
      "STRING"
    ];
    constructor(input) {
      super(input);
      this.interpreter = new LexerATNSimulator(this, _XPathLexer._ATN, _XPathLexer.decisionsToDFA, new PredictionContextCache());
    }
    get grammarFileName() {
      return "XPathLexer.g4";
    }
    get literalNames() {
      return _XPathLexer.literalNames;
    }
    get symbolicNames() {
      return _XPathLexer.symbolicNames;
    }
    get ruleNames() {
      return _XPathLexer.ruleNames;
    }
    get serializedATN() {
      return _XPathLexer._serializedATN;
    }
    get channelNames() {
      return _XPathLexer.channelNames;
    }
    get modeNames() {
      return _XPathLexer.modeNames;
    }
    action(localContext, ruleIndex, actionIndex) {
      switch (ruleIndex) {
        case 4:
          this.ID_action(localContext, actionIndex);
          break;
      }
    }
    ID_action(localContext, actionIndex) {
      switch (actionIndex) {
        case 0:
          const text = this.text;
          if (text.charAt(0) === text.charAt(0).toUpperCase()) {
            this.type = _XPathLexer.TOKEN_REF;
          } else {
            this.type = _XPathLexer.RULE_REF;
          }
          break;
      }
    }
    static _serializedATN = [
      4,
      0,
      8,
      48,
      6,
      -1,
      2,
      0,
      7,
      0,
      2,
      1,
      7,
      1,
      2,
      2,
      7,
      2,
      2,
      3,
      7,
      3,
      2,
      4,
      7,
      4,
      2,
      5,
      7,
      5,
      2,
      6,
      7,
      6,
      2,
      7,
      7,
      7,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      2,
      1,
      2,
      1,
      3,
      1,
      3,
      1,
      4,
      1,
      4,
      5,
      4,
      29,
      8,
      4,
      10,
      4,
      12,
      4,
      32,
      9,
      4,
      1,
      4,
      1,
      4,
      1,
      5,
      1,
      5,
      1,
      6,
      1,
      6,
      1,
      7,
      1,
      7,
      5,
      7,
      42,
      8,
      7,
      10,
      7,
      12,
      7,
      45,
      9,
      7,
      1,
      7,
      1,
      7,
      1,
      43,
      0,
      8,
      1,
      3,
      3,
      4,
      5,
      5,
      7,
      6,
      9,
      7,
      11,
      0,
      13,
      0,
      15,
      8,
      1,
      0,
      2,
      784,
      0,
      0,
      8,
      14,
      27,
      48,
      57,
      65,
      90,
      95,
      95,
      97,
      122,
      127,
      159,
      170,
      170,
      173,
      173,
      181,
      181,
      186,
      186,
      192,
      214,
      216,
      246,
      248,
      705,
      710,
      721,
      736,
      740,
      748,
      748,
      750,
      750,
      768,
      884,
      886,
      887,
      890,
      893,
      895,
      895,
      902,
      902,
      904,
      906,
      908,
      908,
      910,
      929,
      931,
      1013,
      1015,
      1153,
      1155,
      1159,
      1162,
      1327,
      1329,
      1366,
      1369,
      1369,
      1376,
      1416,
      1425,
      1469,
      1471,
      1471,
      1473,
      1474,
      1476,
      1477,
      1479,
      1479,
      1488,
      1514,
      1519,
      1522,
      1536,
      1541,
      1552,
      1562,
      1564,
      1564,
      1568,
      1641,
      1646,
      1747,
      1749,
      1757,
      1759,
      1768,
      1770,
      1788,
      1791,
      1791,
      1807,
      1866,
      1869,
      1969,
      1984,
      2037,
      2042,
      2042,
      2045,
      2045,
      2048,
      2093,
      2112,
      2139,
      2144,
      2154,
      2160,
      2183,
      2185,
      2190,
      2192,
      2193,
      2200,
      2403,
      2406,
      2415,
      2417,
      2435,
      2437,
      2444,
      2447,
      2448,
      2451,
      2472,
      2474,
      2480,
      2482,
      2482,
      2486,
      2489,
      2492,
      2500,
      2503,
      2504,
      2507,
      2510,
      2519,
      2519,
      2524,
      2525,
      2527,
      2531,
      2534,
      2545,
      2556,
      2556,
      2558,
      2558,
      2561,
      2563,
      2565,
      2570,
      2575,
      2576,
      2579,
      2600,
      2602,
      2608,
      2610,
      2611,
      2613,
      2614,
      2616,
      2617,
      2620,
      2620,
      2622,
      2626,
      2631,
      2632,
      2635,
      2637,
      2641,
      2641,
      2649,
      2652,
      2654,
      2654,
      2662,
      2677,
      2689,
      2691,
      2693,
      2701,
      2703,
      2705,
      2707,
      2728,
      2730,
      2736,
      2738,
      2739,
      2741,
      2745,
      2748,
      2757,
      2759,
      2761,
      2763,
      2765,
      2768,
      2768,
      2784,
      2787,
      2790,
      2799,
      2809,
      2815,
      2817,
      2819,
      2821,
      2828,
      2831,
      2832,
      2835,
      2856,
      2858,
      2864,
      2866,
      2867,
      2869,
      2873,
      2876,
      2884,
      2887,
      2888,
      2891,
      2893,
      2901,
      2903,
      2908,
      2909,
      2911,
      2915,
      2918,
      2927,
      2929,
      2929,
      2946,
      2947,
      2949,
      2954,
      2958,
      2960,
      2962,
      2965,
      2969,
      2970,
      2972,
      2972,
      2974,
      2975,
      2979,
      2980,
      2984,
      2986,
      2990,
      3001,
      3006,
      3010,
      3014,
      3016,
      3018,
      3021,
      3024,
      3024,
      3031,
      3031,
      3046,
      3055,
      3072,
      3084,
      3086,
      3088,
      3090,
      3112,
      3114,
      3129,
      3132,
      3140,
      3142,
      3144,
      3146,
      3149,
      3157,
      3158,
      3160,
      3162,
      3165,
      3165,
      3168,
      3171,
      3174,
      3183,
      3200,
      3203,
      3205,
      3212,
      3214,
      3216,
      3218,
      3240,
      3242,
      3251,
      3253,
      3257,
      3260,
      3268,
      3270,
      3272,
      3274,
      3277,
      3285,
      3286,
      3293,
      3294,
      3296,
      3299,
      3302,
      3311,
      3313,
      3315,
      3328,
      3340,
      3342,
      3344,
      3346,
      3396,
      3398,
      3400,
      3402,
      3406,
      3412,
      3415,
      3423,
      3427,
      3430,
      3439,
      3450,
      3455,
      3457,
      3459,
      3461,
      3478,
      3482,
      3505,
      3507,
      3515,
      3517,
      3517,
      3520,
      3526,
      3530,
      3530,
      3535,
      3540,
      3542,
      3542,
      3544,
      3551,
      3558,
      3567,
      3570,
      3571,
      3585,
      3642,
      3648,
      3662,
      3664,
      3673,
      3713,
      3714,
      3716,
      3716,
      3718,
      3722,
      3724,
      3747,
      3749,
      3749,
      3751,
      3773,
      3776,
      3780,
      3782,
      3782,
      3784,
      3790,
      3792,
      3801,
      3804,
      3807,
      3840,
      3840,
      3864,
      3865,
      3872,
      3881,
      3893,
      3893,
      3895,
      3895,
      3897,
      3897,
      3902,
      3911,
      3913,
      3948,
      3953,
      3972,
      3974,
      3991,
      3993,
      4028,
      4038,
      4038,
      4096,
      4169,
      4176,
      4253,
      4256,
      4293,
      4295,
      4295,
      4301,
      4301,
      4304,
      4346,
      4348,
      4680,
      4682,
      4685,
      4688,
      4694,
      4696,
      4696,
      4698,
      4701,
      4704,
      4744,
      4746,
      4749,
      4752,
      4784,
      4786,
      4789,
      4792,
      4798,
      4800,
      4800,
      4802,
      4805,
      4808,
      4822,
      4824,
      4880,
      4882,
      4885,
      4888,
      4954,
      4957,
      4959,
      4992,
      5007,
      5024,
      5109,
      5112,
      5117,
      5121,
      5740,
      5743,
      5759,
      5761,
      5786,
      5792,
      5866,
      5870,
      5880,
      5888,
      5909,
      5919,
      5940,
      5952,
      5971,
      5984,
      5996,
      5998,
      6e3,
      6002,
      6003,
      6016,
      6099,
      6103,
      6103,
      6108,
      6109,
      6112,
      6121,
      6155,
      6169,
      6176,
      6264,
      6272,
      6314,
      6320,
      6389,
      6400,
      6430,
      6432,
      6443,
      6448,
      6459,
      6470,
      6509,
      6512,
      6516,
      6528,
      6571,
      6576,
      6601,
      6608,
      6617,
      6656,
      6683,
      6688,
      6750,
      6752,
      6780,
      6783,
      6793,
      6800,
      6809,
      6823,
      6823,
      6832,
      6845,
      6847,
      6862,
      6912,
      6988,
      6992,
      7001,
      7019,
      7027,
      7040,
      7155,
      7168,
      7223,
      7232,
      7241,
      7245,
      7293,
      7296,
      7304,
      7312,
      7354,
      7357,
      7359,
      7376,
      7378,
      7380,
      7418,
      7424,
      7957,
      7960,
      7965,
      7968,
      8005,
      8008,
      8013,
      8016,
      8023,
      8025,
      8025,
      8027,
      8027,
      8029,
      8029,
      8031,
      8061,
      8064,
      8116,
      8118,
      8124,
      8126,
      8126,
      8130,
      8132,
      8134,
      8140,
      8144,
      8147,
      8150,
      8155,
      8160,
      8172,
      8178,
      8180,
      8182,
      8188,
      8203,
      8207,
      8234,
      8238,
      8255,
      8256,
      8276,
      8276,
      8288,
      8292,
      8294,
      8303,
      8305,
      8305,
      8319,
      8319,
      8336,
      8348,
      8400,
      8412,
      8417,
      8417,
      8421,
      8432,
      8450,
      8450,
      8455,
      8455,
      8458,
      8467,
      8469,
      8469,
      8473,
      8477,
      8484,
      8484,
      8486,
      8486,
      8488,
      8488,
      8490,
      8493,
      8495,
      8505,
      8508,
      8511,
      8517,
      8521,
      8526,
      8526,
      8544,
      8584,
      11264,
      11492,
      11499,
      11507,
      11520,
      11557,
      11559,
      11559,
      11565,
      11565,
      11568,
      11623,
      11631,
      11631,
      11647,
      11670,
      11680,
      11686,
      11688,
      11694,
      11696,
      11702,
      11704,
      11710,
      11712,
      11718,
      11720,
      11726,
      11728,
      11734,
      11736,
      11742,
      11744,
      11775,
      11823,
      11823,
      12293,
      12295,
      12321,
      12335,
      12337,
      12341,
      12344,
      12348,
      12353,
      12438,
      12441,
      12442,
      12445,
      12447,
      12449,
      12538,
      12540,
      12543,
      12549,
      12591,
      12593,
      12686,
      12704,
      12735,
      12784,
      12799,
      13312,
      19903,
      19968,
      42124,
      42192,
      42237,
      42240,
      42508,
      42512,
      42539,
      42560,
      42607,
      42612,
      42621,
      42623,
      42737,
      42775,
      42783,
      42786,
      42888,
      42891,
      42954,
      42960,
      42961,
      42963,
      42963,
      42965,
      42969,
      42994,
      43047,
      43052,
      43052,
      43072,
      43123,
      43136,
      43205,
      43216,
      43225,
      43232,
      43255,
      43259,
      43259,
      43261,
      43309,
      43312,
      43347,
      43360,
      43388,
      43392,
      43456,
      43471,
      43481,
      43488,
      43518,
      43520,
      43574,
      43584,
      43597,
      43600,
      43609,
      43616,
      43638,
      43642,
      43714,
      43739,
      43741,
      43744,
      43759,
      43762,
      43766,
      43777,
      43782,
      43785,
      43790,
      43793,
      43798,
      43808,
      43814,
      43816,
      43822,
      43824,
      43866,
      43868,
      43881,
      43888,
      44010,
      44012,
      44013,
      44016,
      44025,
      44032,
      55203,
      55216,
      55238,
      55243,
      55291,
      63744,
      64109,
      64112,
      64217,
      64256,
      64262,
      64275,
      64279,
      64285,
      64296,
      64298,
      64310,
      64312,
      64316,
      64318,
      64318,
      64320,
      64321,
      64323,
      64324,
      64326,
      64433,
      64467,
      64829,
      64848,
      64911,
      64914,
      64967,
      65008,
      65019,
      65024,
      65039,
      65056,
      65071,
      65075,
      65076,
      65101,
      65103,
      65136,
      65140,
      65142,
      65276,
      65279,
      65279,
      65296,
      65305,
      65313,
      65338,
      65343,
      65343,
      65345,
      65370,
      65382,
      65470,
      65474,
      65479,
      65482,
      65487,
      65490,
      65495,
      65498,
      65500,
      65529,
      65531,
      65536,
      65547,
      65549,
      65574,
      65576,
      65594,
      65596,
      65597,
      65599,
      65613,
      65616,
      65629,
      65664,
      65786,
      65856,
      65908,
      66045,
      66045,
      66176,
      66204,
      66208,
      66256,
      66272,
      66272,
      66304,
      66335,
      66349,
      66378,
      66384,
      66426,
      66432,
      66461,
      66464,
      66499,
      66504,
      66511,
      66513,
      66517,
      66560,
      66717,
      66720,
      66729,
      66736,
      66771,
      66776,
      66811,
      66816,
      66855,
      66864,
      66915,
      66928,
      66938,
      66940,
      66954,
      66956,
      66962,
      66964,
      66965,
      66967,
      66977,
      66979,
      66993,
      66995,
      67001,
      67003,
      67004,
      67072,
      67382,
      67392,
      67413,
      67424,
      67431,
      67456,
      67461,
      67463,
      67504,
      67506,
      67514,
      67584,
      67589,
      67592,
      67592,
      67594,
      67637,
      67639,
      67640,
      67644,
      67644,
      67647,
      67669,
      67680,
      67702,
      67712,
      67742,
      67808,
      67826,
      67828,
      67829,
      67840,
      67861,
      67872,
      67897,
      67968,
      68023,
      68030,
      68031,
      68096,
      68099,
      68101,
      68102,
      68108,
      68115,
      68117,
      68119,
      68121,
      68149,
      68152,
      68154,
      68159,
      68159,
      68192,
      68220,
      68224,
      68252,
      68288,
      68295,
      68297,
      68326,
      68352,
      68405,
      68416,
      68437,
      68448,
      68466,
      68480,
      68497,
      68608,
      68680,
      68736,
      68786,
      68800,
      68850,
      68864,
      68903,
      68912,
      68921,
      69248,
      69289,
      69291,
      69292,
      69296,
      69297,
      69373,
      69404,
      69415,
      69415,
      69424,
      69456,
      69488,
      69509,
      69552,
      69572,
      69600,
      69622,
      69632,
      69702,
      69734,
      69749,
      69759,
      69818,
      69821,
      69821,
      69826,
      69826,
      69837,
      69837,
      69840,
      69864,
      69872,
      69881,
      69888,
      69940,
      69942,
      69951,
      69956,
      69959,
      69968,
      70003,
      70006,
      70006,
      70016,
      70084,
      70089,
      70092,
      70094,
      70106,
      70108,
      70108,
      70144,
      70161,
      70163,
      70199,
      70206,
      70209,
      70272,
      70278,
      70280,
      70280,
      70282,
      70285,
      70287,
      70301,
      70303,
      70312,
      70320,
      70378,
      70384,
      70393,
      70400,
      70403,
      70405,
      70412,
      70415,
      70416,
      70419,
      70440,
      70442,
      70448,
      70450,
      70451,
      70453,
      70457,
      70459,
      70468,
      70471,
      70472,
      70475,
      70477,
      70480,
      70480,
      70487,
      70487,
      70493,
      70499,
      70502,
      70508,
      70512,
      70516,
      70656,
      70730,
      70736,
      70745,
      70750,
      70753,
      70784,
      70853,
      70855,
      70855,
      70864,
      70873,
      71040,
      71093,
      71096,
      71104,
      71128,
      71133,
      71168,
      71232,
      71236,
      71236,
      71248,
      71257,
      71296,
      71352,
      71360,
      71369,
      71424,
      71450,
      71453,
      71467,
      71472,
      71481,
      71488,
      71494,
      71680,
      71738,
      71840,
      71913,
      71935,
      71942,
      71945,
      71945,
      71948,
      71955,
      71957,
      71958,
      71960,
      71989,
      71991,
      71992,
      71995,
      72003,
      72016,
      72025,
      72096,
      72103,
      72106,
      72151,
      72154,
      72161,
      72163,
      72164,
      72192,
      72254,
      72263,
      72263,
      72272,
      72345,
      72349,
      72349,
      72368,
      72440,
      72704,
      72712,
      72714,
      72758,
      72760,
      72768,
      72784,
      72793,
      72818,
      72847,
      72850,
      72871,
      72873,
      72886,
      72960,
      72966,
      72968,
      72969,
      72971,
      73014,
      73018,
      73018,
      73020,
      73021,
      73023,
      73031,
      73040,
      73049,
      73056,
      73061,
      73063,
      73064,
      73066,
      73102,
      73104,
      73105,
      73107,
      73112,
      73120,
      73129,
      73440,
      73462,
      73472,
      73488,
      73490,
      73530,
      73534,
      73538,
      73552,
      73561,
      73648,
      73648,
      73728,
      74649,
      74752,
      74862,
      74880,
      75075,
      77712,
      77808,
      77824,
      78933,
      82944,
      83526,
      92160,
      92728,
      92736,
      92766,
      92768,
      92777,
      92784,
      92862,
      92864,
      92873,
      92880,
      92909,
      92912,
      92916,
      92928,
      92982,
      92992,
      92995,
      93008,
      93017,
      93027,
      93047,
      93053,
      93071,
      93760,
      93823,
      93952,
      94026,
      94031,
      94087,
      94095,
      94111,
      94176,
      94177,
      94179,
      94180,
      94192,
      94193,
      94208,
      100343,
      100352,
      101589,
      101632,
      101640,
      110576,
      110579,
      110581,
      110587,
      110589,
      110590,
      110592,
      110882,
      110898,
      110898,
      110928,
      110930,
      110933,
      110933,
      110948,
      110951,
      110960,
      111355,
      113664,
      113770,
      113776,
      113788,
      113792,
      113800,
      113808,
      113817,
      113821,
      113822,
      113824,
      113827,
      118528,
      118573,
      118576,
      118598,
      119141,
      119145,
      119149,
      119170,
      119173,
      119179,
      119210,
      119213,
      119362,
      119364,
      119808,
      119892,
      119894,
      119964,
      119966,
      119967,
      119970,
      119970,
      119973,
      119974,
      119977,
      119980,
      119982,
      119993,
      119995,
      119995,
      119997,
      120003,
      120005,
      120069,
      120071,
      120074,
      120077,
      120084,
      120086,
      120092,
      120094,
      120121,
      120123,
      120126,
      120128,
      120132,
      120134,
      120134,
      120138,
      120144,
      120146,
      120485,
      120488,
      120512,
      120514,
      120538,
      120540,
      120570,
      120572,
      120596,
      120598,
      120628,
      120630,
      120654,
      120656,
      120686,
      120688,
      120712,
      120714,
      120744,
      120746,
      120770,
      120772,
      120779,
      120782,
      120831,
      121344,
      121398,
      121403,
      121452,
      121461,
      121461,
      121476,
      121476,
      121499,
      121503,
      121505,
      121519,
      122624,
      122654,
      122661,
      122666,
      122880,
      122886,
      122888,
      122904,
      122907,
      122913,
      122915,
      122916,
      122918,
      122922,
      122928,
      122989,
      123023,
      123023,
      123136,
      123180,
      123184,
      123197,
      123200,
      123209,
      123214,
      123214,
      123536,
      123566,
      123584,
      123641,
      124112,
      124153,
      124896,
      124902,
      124904,
      124907,
      124909,
      124910,
      124912,
      124926,
      124928,
      125124,
      125136,
      125142,
      125184,
      125259,
      125264,
      125273,
      126464,
      126467,
      126469,
      126495,
      126497,
      126498,
      126500,
      126500,
      126503,
      126503,
      126505,
      126514,
      126516,
      126519,
      126521,
      126521,
      126523,
      126523,
      126530,
      126530,
      126535,
      126535,
      126537,
      126537,
      126539,
      126539,
      126541,
      126543,
      126545,
      126546,
      126548,
      126548,
      126551,
      126551,
      126553,
      126553,
      126555,
      126555,
      126557,
      126557,
      126559,
      126559,
      126561,
      126562,
      126564,
      126564,
      126567,
      126570,
      126572,
      126578,
      126580,
      126583,
      126585,
      126588,
      126590,
      126590,
      126592,
      126601,
      126603,
      126619,
      126625,
      126627,
      126629,
      126633,
      126635,
      126651,
      130032,
      130041,
      131072,
      173791,
      173824,
      177977,
      177984,
      178205,
      178208,
      183969,
      183984,
      191456,
      194560,
      195101,
      196608,
      201546,
      201552,
      205743,
      917505,
      917505,
      917536,
      917631,
      917760,
      917999,
      662,
      0,
      65,
      90,
      97,
      122,
      170,
      170,
      181,
      181,
      186,
      186,
      192,
      214,
      216,
      246,
      248,
      705,
      710,
      721,
      736,
      740,
      748,
      748,
      750,
      750,
      880,
      884,
      886,
      887,
      890,
      893,
      895,
      895,
      902,
      902,
      904,
      906,
      908,
      908,
      910,
      929,
      931,
      1013,
      1015,
      1153,
      1162,
      1327,
      1329,
      1366,
      1369,
      1369,
      1376,
      1416,
      1488,
      1514,
      1519,
      1522,
      1568,
      1610,
      1646,
      1647,
      1649,
      1747,
      1749,
      1749,
      1765,
      1766,
      1774,
      1775,
      1786,
      1788,
      1791,
      1791,
      1808,
      1808,
      1810,
      1839,
      1869,
      1957,
      1969,
      1969,
      1994,
      2026,
      2036,
      2037,
      2042,
      2042,
      2048,
      2069,
      2074,
      2074,
      2084,
      2084,
      2088,
      2088,
      2112,
      2136,
      2144,
      2154,
      2160,
      2183,
      2185,
      2190,
      2208,
      2249,
      2308,
      2361,
      2365,
      2365,
      2384,
      2384,
      2392,
      2401,
      2417,
      2432,
      2437,
      2444,
      2447,
      2448,
      2451,
      2472,
      2474,
      2480,
      2482,
      2482,
      2486,
      2489,
      2493,
      2493,
      2510,
      2510,
      2524,
      2525,
      2527,
      2529,
      2544,
      2545,
      2556,
      2556,
      2565,
      2570,
      2575,
      2576,
      2579,
      2600,
      2602,
      2608,
      2610,
      2611,
      2613,
      2614,
      2616,
      2617,
      2649,
      2652,
      2654,
      2654,
      2674,
      2676,
      2693,
      2701,
      2703,
      2705,
      2707,
      2728,
      2730,
      2736,
      2738,
      2739,
      2741,
      2745,
      2749,
      2749,
      2768,
      2768,
      2784,
      2785,
      2809,
      2809,
      2821,
      2828,
      2831,
      2832,
      2835,
      2856,
      2858,
      2864,
      2866,
      2867,
      2869,
      2873,
      2877,
      2877,
      2908,
      2909,
      2911,
      2913,
      2929,
      2929,
      2947,
      2947,
      2949,
      2954,
      2958,
      2960,
      2962,
      2965,
      2969,
      2970,
      2972,
      2972,
      2974,
      2975,
      2979,
      2980,
      2984,
      2986,
      2990,
      3001,
      3024,
      3024,
      3077,
      3084,
      3086,
      3088,
      3090,
      3112,
      3114,
      3129,
      3133,
      3133,
      3160,
      3162,
      3165,
      3165,
      3168,
      3169,
      3200,
      3200,
      3205,
      3212,
      3214,
      3216,
      3218,
      3240,
      3242,
      3251,
      3253,
      3257,
      3261,
      3261,
      3293,
      3294,
      3296,
      3297,
      3313,
      3314,
      3332,
      3340,
      3342,
      3344,
      3346,
      3386,
      3389,
      3389,
      3406,
      3406,
      3412,
      3414,
      3423,
      3425,
      3450,
      3455,
      3461,
      3478,
      3482,
      3505,
      3507,
      3515,
      3517,
      3517,
      3520,
      3526,
      3585,
      3632,
      3634,
      3635,
      3648,
      3654,
      3713,
      3714,
      3716,
      3716,
      3718,
      3722,
      3724,
      3747,
      3749,
      3749,
      3751,
      3760,
      3762,
      3763,
      3773,
      3773,
      3776,
      3780,
      3782,
      3782,
      3804,
      3807,
      3840,
      3840,
      3904,
      3911,
      3913,
      3948,
      3976,
      3980,
      4096,
      4138,
      4159,
      4159,
      4176,
      4181,
      4186,
      4189,
      4193,
      4193,
      4197,
      4198,
      4206,
      4208,
      4213,
      4225,
      4238,
      4238,
      4256,
      4293,
      4295,
      4295,
      4301,
      4301,
      4304,
      4346,
      4348,
      4680,
      4682,
      4685,
      4688,
      4694,
      4696,
      4696,
      4698,
      4701,
      4704,
      4744,
      4746,
      4749,
      4752,
      4784,
      4786,
      4789,
      4792,
      4798,
      4800,
      4800,
      4802,
      4805,
      4808,
      4822,
      4824,
      4880,
      4882,
      4885,
      4888,
      4954,
      4992,
      5007,
      5024,
      5109,
      5112,
      5117,
      5121,
      5740,
      5743,
      5759,
      5761,
      5786,
      5792,
      5866,
      5870,
      5880,
      5888,
      5905,
      5919,
      5937,
      5952,
      5969,
      5984,
      5996,
      5998,
      6e3,
      6016,
      6067,
      6103,
      6103,
      6108,
      6108,
      6176,
      6264,
      6272,
      6276,
      6279,
      6312,
      6314,
      6314,
      6320,
      6389,
      6400,
      6430,
      6480,
      6509,
      6512,
      6516,
      6528,
      6571,
      6576,
      6601,
      6656,
      6678,
      6688,
      6740,
      6823,
      6823,
      6917,
      6963,
      6981,
      6988,
      7043,
      7072,
      7086,
      7087,
      7098,
      7141,
      7168,
      7203,
      7245,
      7247,
      7258,
      7293,
      7296,
      7304,
      7312,
      7354,
      7357,
      7359,
      7401,
      7404,
      7406,
      7411,
      7413,
      7414,
      7418,
      7418,
      7424,
      7615,
      7680,
      7957,
      7960,
      7965,
      7968,
      8005,
      8008,
      8013,
      8016,
      8023,
      8025,
      8025,
      8027,
      8027,
      8029,
      8029,
      8031,
      8061,
      8064,
      8116,
      8118,
      8124,
      8126,
      8126,
      8130,
      8132,
      8134,
      8140,
      8144,
      8147,
      8150,
      8155,
      8160,
      8172,
      8178,
      8180,
      8182,
      8188,
      8305,
      8305,
      8319,
      8319,
      8336,
      8348,
      8450,
      8450,
      8455,
      8455,
      8458,
      8467,
      8469,
      8469,
      8473,
      8477,
      8484,
      8484,
      8486,
      8486,
      8488,
      8488,
      8490,
      8493,
      8495,
      8505,
      8508,
      8511,
      8517,
      8521,
      8526,
      8526,
      8544,
      8584,
      11264,
      11492,
      11499,
      11502,
      11506,
      11507,
      11520,
      11557,
      11559,
      11559,
      11565,
      11565,
      11568,
      11623,
      11631,
      11631,
      11648,
      11670,
      11680,
      11686,
      11688,
      11694,
      11696,
      11702,
      11704,
      11710,
      11712,
      11718,
      11720,
      11726,
      11728,
      11734,
      11736,
      11742,
      11823,
      11823,
      12293,
      12295,
      12321,
      12329,
      12337,
      12341,
      12344,
      12348,
      12353,
      12438,
      12445,
      12447,
      12449,
      12538,
      12540,
      12543,
      12549,
      12591,
      12593,
      12686,
      12704,
      12735,
      12784,
      12799,
      13312,
      19903,
      19968,
      42124,
      42192,
      42237,
      42240,
      42508,
      42512,
      42527,
      42538,
      42539,
      42560,
      42606,
      42623,
      42653,
      42656,
      42735,
      42775,
      42783,
      42786,
      42888,
      42891,
      42954,
      42960,
      42961,
      42963,
      42963,
      42965,
      42969,
      42994,
      43009,
      43011,
      43013,
      43015,
      43018,
      43020,
      43042,
      43072,
      43123,
      43138,
      43187,
      43250,
      43255,
      43259,
      43259,
      43261,
      43262,
      43274,
      43301,
      43312,
      43334,
      43360,
      43388,
      43396,
      43442,
      43471,
      43471,
      43488,
      43492,
      43494,
      43503,
      43514,
      43518,
      43520,
      43560,
      43584,
      43586,
      43588,
      43595,
      43616,
      43638,
      43642,
      43642,
      43646,
      43695,
      43697,
      43697,
      43701,
      43702,
      43705,
      43709,
      43712,
      43712,
      43714,
      43714,
      43739,
      43741,
      43744,
      43754,
      43762,
      43764,
      43777,
      43782,
      43785,
      43790,
      43793,
      43798,
      43808,
      43814,
      43816,
      43822,
      43824,
      43866,
      43868,
      43881,
      43888,
      44002,
      44032,
      55203,
      55216,
      55238,
      55243,
      55291,
      63744,
      64109,
      64112,
      64217,
      64256,
      64262,
      64275,
      64279,
      64285,
      64285,
      64287,
      64296,
      64298,
      64310,
      64312,
      64316,
      64318,
      64318,
      64320,
      64321,
      64323,
      64324,
      64326,
      64433,
      64467,
      64829,
      64848,
      64911,
      64914,
      64967,
      65008,
      65019,
      65136,
      65140,
      65142,
      65276,
      65313,
      65338,
      65345,
      65370,
      65382,
      65470,
      65474,
      65479,
      65482,
      65487,
      65490,
      65495,
      65498,
      65500,
      65536,
      65547,
      65549,
      65574,
      65576,
      65594,
      65596,
      65597,
      65599,
      65613,
      65616,
      65629,
      65664,
      65786,
      65856,
      65908,
      66176,
      66204,
      66208,
      66256,
      66304,
      66335,
      66349,
      66378,
      66384,
      66421,
      66432,
      66461,
      66464,
      66499,
      66504,
      66511,
      66513,
      66517,
      66560,
      66717,
      66736,
      66771,
      66776,
      66811,
      66816,
      66855,
      66864,
      66915,
      66928,
      66938,
      66940,
      66954,
      66956,
      66962,
      66964,
      66965,
      66967,
      66977,
      66979,
      66993,
      66995,
      67001,
      67003,
      67004,
      67072,
      67382,
      67392,
      67413,
      67424,
      67431,
      67456,
      67461,
      67463,
      67504,
      67506,
      67514,
      67584,
      67589,
      67592,
      67592,
      67594,
      67637,
      67639,
      67640,
      67644,
      67644,
      67647,
      67669,
      67680,
      67702,
      67712,
      67742,
      67808,
      67826,
      67828,
      67829,
      67840,
      67861,
      67872,
      67897,
      67968,
      68023,
      68030,
      68031,
      68096,
      68096,
      68112,
      68115,
      68117,
      68119,
      68121,
      68149,
      68192,
      68220,
      68224,
      68252,
      68288,
      68295,
      68297,
      68324,
      68352,
      68405,
      68416,
      68437,
      68448,
      68466,
      68480,
      68497,
      68608,
      68680,
      68736,
      68786,
      68800,
      68850,
      68864,
      68899,
      69248,
      69289,
      69296,
      69297,
      69376,
      69404,
      69415,
      69415,
      69424,
      69445,
      69488,
      69505,
      69552,
      69572,
      69600,
      69622,
      69635,
      69687,
      69745,
      69746,
      69749,
      69749,
      69763,
      69807,
      69840,
      69864,
      69891,
      69926,
      69956,
      69956,
      69959,
      69959,
      69968,
      70002,
      70006,
      70006,
      70019,
      70066,
      70081,
      70084,
      70106,
      70106,
      70108,
      70108,
      70144,
      70161,
      70163,
      70187,
      70207,
      70208,
      70272,
      70278,
      70280,
      70280,
      70282,
      70285,
      70287,
      70301,
      70303,
      70312,
      70320,
      70366,
      70405,
      70412,
      70415,
      70416,
      70419,
      70440,
      70442,
      70448,
      70450,
      70451,
      70453,
      70457,
      70461,
      70461,
      70480,
      70480,
      70493,
      70497,
      70656,
      70708,
      70727,
      70730,
      70751,
      70753,
      70784,
      70831,
      70852,
      70853,
      70855,
      70855,
      71040,
      71086,
      71128,
      71131,
      71168,
      71215,
      71236,
      71236,
      71296,
      71338,
      71352,
      71352,
      71424,
      71450,
      71488,
      71494,
      71680,
      71723,
      71840,
      71903,
      71935,
      71942,
      71945,
      71945,
      71948,
      71955,
      71957,
      71958,
      71960,
      71983,
      71999,
      71999,
      72001,
      72001,
      72096,
      72103,
      72106,
      72144,
      72161,
      72161,
      72163,
      72163,
      72192,
      72192,
      72203,
      72242,
      72250,
      72250,
      72272,
      72272,
      72284,
      72329,
      72349,
      72349,
      72368,
      72440,
      72704,
      72712,
      72714,
      72750,
      72768,
      72768,
      72818,
      72847,
      72960,
      72966,
      72968,
      72969,
      72971,
      73008,
      73030,
      73030,
      73056,
      73061,
      73063,
      73064,
      73066,
      73097,
      73112,
      73112,
      73440,
      73458,
      73474,
      73474,
      73476,
      73488,
      73490,
      73523,
      73648,
      73648,
      73728,
      74649,
      74752,
      74862,
      74880,
      75075,
      77712,
      77808,
      77824,
      78895,
      78913,
      78918,
      82944,
      83526,
      92160,
      92728,
      92736,
      92766,
      92784,
      92862,
      92880,
      92909,
      92928,
      92975,
      92992,
      92995,
      93027,
      93047,
      93053,
      93071,
      93760,
      93823,
      93952,
      94026,
      94032,
      94032,
      94099,
      94111,
      94176,
      94177,
      94179,
      94179,
      94208,
      100343,
      100352,
      101589,
      101632,
      101640,
      110576,
      110579,
      110581,
      110587,
      110589,
      110590,
      110592,
      110882,
      110898,
      110898,
      110928,
      110930,
      110933,
      110933,
      110948,
      110951,
      110960,
      111355,
      113664,
      113770,
      113776,
      113788,
      113792,
      113800,
      113808,
      113817,
      119808,
      119892,
      119894,
      119964,
      119966,
      119967,
      119970,
      119970,
      119973,
      119974,
      119977,
      119980,
      119982,
      119993,
      119995,
      119995,
      119997,
      120003,
      120005,
      120069,
      120071,
      120074,
      120077,
      120084,
      120086,
      120092,
      120094,
      120121,
      120123,
      120126,
      120128,
      120132,
      120134,
      120134,
      120138,
      120144,
      120146,
      120485,
      120488,
      120512,
      120514,
      120538,
      120540,
      120570,
      120572,
      120596,
      120598,
      120628,
      120630,
      120654,
      120656,
      120686,
      120688,
      120712,
      120714,
      120744,
      120746,
      120770,
      120772,
      120779,
      122624,
      122654,
      122661,
      122666,
      122928,
      122989,
      123136,
      123180,
      123191,
      123197,
      123214,
      123214,
      123536,
      123565,
      123584,
      123627,
      124112,
      124139,
      124896,
      124902,
      124904,
      124907,
      124909,
      124910,
      124912,
      124926,
      124928,
      125124,
      125184,
      125251,
      125259,
      125259,
      126464,
      126467,
      126469,
      126495,
      126497,
      126498,
      126500,
      126500,
      126503,
      126503,
      126505,
      126514,
      126516,
      126519,
      126521,
      126521,
      126523,
      126523,
      126530,
      126530,
      126535,
      126535,
      126537,
      126537,
      126539,
      126539,
      126541,
      126543,
      126545,
      126546,
      126548,
      126548,
      126551,
      126551,
      126553,
      126553,
      126555,
      126555,
      126557,
      126557,
      126559,
      126559,
      126561,
      126562,
      126564,
      126564,
      126567,
      126570,
      126572,
      126578,
      126580,
      126583,
      126585,
      126588,
      126590,
      126590,
      126592,
      126601,
      126603,
      126619,
      126625,
      126627,
      126629,
      126633,
      126635,
      126651,
      131072,
      173791,
      173824,
      177977,
      177984,
      178205,
      178208,
      183969,
      183984,
      191456,
      194560,
      195101,
      196608,
      201546,
      201552,
      205743,
      47,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      3,
      1,
      0,
      0,
      0,
      0,
      5,
      1,
      0,
      0,
      0,
      0,
      7,
      1,
      0,
      0,
      0,
      0,
      9,
      1,
      0,
      0,
      0,
      0,
      15,
      1,
      0,
      0,
      0,
      1,
      17,
      1,
      0,
      0,
      0,
      3,
      20,
      1,
      0,
      0,
      0,
      5,
      22,
      1,
      0,
      0,
      0,
      7,
      24,
      1,
      0,
      0,
      0,
      9,
      26,
      1,
      0,
      0,
      0,
      11,
      35,
      1,
      0,
      0,
      0,
      13,
      37,
      1,
      0,
      0,
      0,
      15,
      39,
      1,
      0,
      0,
      0,
      17,
      18,
      5,
      47,
      0,
      0,
      18,
      19,
      5,
      47,
      0,
      0,
      19,
      2,
      1,
      0,
      0,
      0,
      20,
      21,
      5,
      47,
      0,
      0,
      21,
      4,
      1,
      0,
      0,
      0,
      22,
      23,
      5,
      42,
      0,
      0,
      23,
      6,
      1,
      0,
      0,
      0,
      24,
      25,
      5,
      33,
      0,
      0,
      25,
      8,
      1,
      0,
      0,
      0,
      26,
      30,
      3,
      13,
      6,
      0,
      27,
      29,
      3,
      11,
      5,
      0,
      28,
      27,
      1,
      0,
      0,
      0,
      29,
      32,
      1,
      0,
      0,
      0,
      30,
      28,
      1,
      0,
      0,
      0,
      30,
      31,
      1,
      0,
      0,
      0,
      31,
      33,
      1,
      0,
      0,
      0,
      32,
      30,
      1,
      0,
      0,
      0,
      33,
      34,
      6,
      4,
      0,
      0,
      34,
      10,
      1,
      0,
      0,
      0,
      35,
      36,
      7,
      0,
      0,
      0,
      36,
      12,
      1,
      0,
      0,
      0,
      37,
      38,
      7,
      1,
      0,
      0,
      38,
      14,
      1,
      0,
      0,
      0,
      39,
      43,
      5,
      39,
      0,
      0,
      40,
      42,
      9,
      0,
      0,
      0,
      41,
      40,
      1,
      0,
      0,
      0,
      42,
      45,
      1,
      0,
      0,
      0,
      43,
      44,
      1,
      0,
      0,
      0,
      43,
      41,
      1,
      0,
      0,
      0,
      44,
      46,
      1,
      0,
      0,
      0,
      45,
      43,
      1,
      0,
      0,
      0,
      46,
      47,
      5,
      39,
      0,
      0,
      47,
      16,
      1,
      0,
      0,
      0,
      3,
      0,
      30,
      43,
      1,
      1,
      4,
      0
    ];
    static __ATN;
    static get _ATN() {
      if (!_XPathLexer.__ATN) {
        _XPathLexer.__ATN = new ATNDeserializer().deserialize(_XPathLexer._serializedATN);
      }
      return _XPathLexer.__ATN;
    }
    static vocabulary = new Vocabulary(_XPathLexer.literalNames, _XPathLexer.symbolicNames, []);
    get vocabulary() {
      return _XPathLexer.vocabulary;
    }
    static decisionsToDFA = _XPathLexer._ATN.decisionToState.map((ds, index) => {
      return new DFA(ds, index);
    });
  };
  var XPathLexerErrorListener = class extends BaseErrorListener {
    static {
      __name(this, "XPathLexerErrorListener");
    }
    syntaxError(_recognizer, _offendingSymbol, _line, _charPositionInLine, _msg, _e) {
    }
  };
  var XPathElement = class {
    static {
      __name(this, "XPathElement");
    }
    invert;
    nodeName;
    /**
     * Construct element like `/ID` or `ID` or `/*` etc... `nodeName` is undefined if just node
     *
     * @param nodeName The name of the node; may be undefined for any node.
     */
    constructor(nodeName) {
      this.nodeName = nodeName;
      this.invert = false;
    }
    toString() {
      const inv = this.invert ? "!" : "";
      return "XPathElement[" + inv + this.nodeName + "]";
    }
  };
  var XPathRuleAnywhereElement = class extends XPathElement {
    static {
      __name(this, "XPathRuleAnywhereElement");
    }
    ruleIndex;
    constructor(ruleName, ruleIndex) {
      super(ruleName);
      this.ruleIndex = ruleIndex;
    }
    evaluate(t) {
      return Trees.findAllRuleNodes(t, this.ruleIndex);
    }
    toString() {
      const inv = this.invert ? "!" : "";
      return "XPathRuleAnywhereElement[" + inv + this.nodeName + "]";
    }
  };
  var XPathRuleElement = class extends XPathElement {
    static {
      __name(this, "XPathRuleElement");
    }
    ruleIndex;
    constructor(ruleName, ruleIndex) {
      super(ruleName);
      this.ruleIndex = ruleIndex;
    }
    evaluate(t) {
      const nodes = [];
      for (const c of Trees.getChildren(t)) {
        if (c instanceof ParserRuleContext) {
          if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
            nodes.push(c);
          }
        }
      }
      return nodes;
    }
    toString() {
      const inv = this.invert ? "!" : "";
      return "XPathRuleElement[" + inv + this.nodeName + "]";
    }
  };
  var XPathTokenAnywhereElement = class extends XPathElement {
    static {
      __name(this, "XPathTokenAnywhereElement");
    }
    tokenType;
    constructor(tokenName, tokenType) {
      super(tokenName);
      this.tokenType = tokenType;
    }
    evaluate(t) {
      return Trees.findAllTokenNodes(t, this.tokenType);
    }
    toString() {
      const inv = this.invert ? "!" : "";
      return "XPathTokenAnywhereElement[" + inv + this.nodeName + "]";
    }
  };
  var XPathTokenElement = class extends XPathElement {
    static {
      __name(this, "XPathTokenElement");
    }
    tokenType;
    constructor(tokenName, tokenType) {
      super(tokenName);
      this.tokenType = tokenType;
    }
    evaluate(t) {
      const nodes = [];
      for (const c of Trees.getChildren(t)) {
        if (c instanceof TerminalNode && c.symbol) {
          if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
            nodes.push(c);
          }
        }
      }
      return nodes;
    }
    toString() {
      const inv = this.invert ? "!" : "";
      return "XPathTokenElement[" + inv + this.nodeName + "]";
    }
  };
  var XPathWildcardAnywhereElement = class extends XPathElement {
    static {
      __name(this, "XPathWildcardAnywhereElement");
    }
    constructor() {
      super(XPath.WILDCARD);
    }
    evaluate(t) {
      if (this.invert) {
        return [];
      }
      return Trees.descendants(t);
    }
    toString() {
      const inv = this.invert ? "!" : "";
      return "XPathWildcardAnywhereElement[" + inv + this.nodeName + "]";
    }
  };
  var XPathWildcardElement = class extends XPathElement {
    static {
      __name(this, "XPathWildcardElement");
    }
    constructor() {
      super(XPath.WILDCARD);
    }
    evaluate(t) {
      const kids = [];
      if (this.invert) {
        return kids;
      }
      for (const c of Trees.getChildren(t)) {
        kids.push(c);
      }
      return kids;
    }
    toString() {
      const inv = this.invert ? "!" : "";
      return "XPathWildcardElement[" + inv + this.nodeName + "]";
    }
  };
  var XPath = class _XPath {
    static {
      __name(this, "XPath");
    }
    static WILDCARD = "*";
    // word not operator/separator
    static NOT = "!";
    // word for invert operator
    path;
    elements;
    parser;
    constructor(parser, path) {
      this.parser = parser;
      this.path = path;
      this.elements = this.split(path);
    }
    static findAll(tree, xpath, parser) {
      const p = new _XPath(parser, xpath);
      return p.evaluate(tree);
    }
    // TODO: check for invalid token/rule names, bad syntax
    split(path) {
      const lexer = new XPathLexer(CharStream.fromString(path));
      lexer.recover = (e) => {
        throw e;
      };
      lexer.removeErrorListeners();
      lexer.addErrorListener(new XPathLexerErrorListener());
      const tokenStream = new CommonTokenStream(lexer);
      try {
        tokenStream.fill();
      } catch (e) {
        if (e instanceof LexerNoViableAltException) {
          const pos = lexer.column;
          const msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
          throw new RangeError(msg);
        }
        throw e;
      }
      const tokens = tokenStream.getTokens();
      const elements = [];
      const n2 = tokens.length;
      let i = 0;
      loop:
        while (i < n2) {
          const el = tokens[i];
          let next;
          switch (el.type) {
            case XPathLexer.ROOT:
            case XPathLexer.ANYWHERE:
              const anywhere = el.type === XPathLexer.ANYWHERE;
              i++;
              next = tokens[i];
              const invert = next.type === XPathLexer.BANG;
              if (invert) {
                i++;
                next = tokens[i];
              }
              const pathElement = this.getXPathElement(next, anywhere);
              pathElement.invert = invert;
              elements.push(pathElement);
              i++;
              break;
            case XPathLexer.TOKEN_REF:
            case XPathLexer.RULE_REF:
            case XPathLexer.WILDCARD:
              elements.push(this.getXPathElement(el, false));
              ++i;
              break;
            case Token.EOF:
              break loop;
            default:
              throw new Error("Unknown path element " + el);
          }
        }
      return elements;
    }
    /**
     * Return a list of all nodes starting at `t` as root that satisfy the
     * path. The root `/` is relative to the node passed to {@link evaluate}.
     */
    evaluate(t) {
      const dummyRoot = new ParserRuleContext(null);
      dummyRoot.addChild(t);
      let work = /* @__PURE__ */ new Set([dummyRoot]);
      let i = 0;
      while (i < this.elements.length) {
        const next = /* @__PURE__ */ new Set();
        for (const node of work) {
          if (node.getChildCount() > 0) {
            const matching = this.elements[i].evaluate(node);
            matching.forEach((tree) => {
              next.add(tree);
            }, next);
          }
        }
        i++;
        work = next;
      }
      return work;
    }
    /**
     * Convert word like `*` or `ID` or `expr` to a path
     * element. `anywhere` is `true` if `//` precedes the
     * word.
     */
    getXPathElement(wordToken, anywhere) {
      if (wordToken.type === Token.EOF) {
        throw new Error("Missing path element at end of path");
      }
      const word = wordToken.text;
      if (word == null) {
        throw new Error("Expected wordToken to have text content.");
      }
      const ttype = this.parser.getTokenType(word);
      const ruleIndex = this.parser.getRuleIndex(word);
      switch (wordToken.type) {
        case XPathLexer.WILDCARD:
          return anywhere ? new XPathWildcardAnywhereElement() : new XPathWildcardElement();
        case XPathLexer.TOKEN_REF:
        case XPathLexer.STRING:
          if (ttype === Token.INVALID_TYPE) {
            throw new Error(word + " at index " + wordToken.start + " isn't a valid token name");
          }
          return anywhere ? new XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement(word, ttype);
        default:
          if (ruleIndex === -1) {
            throw new Error(word + " at index " + wordToken.start + " isn't a valid rule name");
          }
          return anywhere ? new XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement(word, ruleIndex);
      }
    }
  };
  var Chunk = class {
    static {
      __name(this, "Chunk");
    }
  };
  var ParseTreeMatch = class {
    static {
      __name(this, "ParseTreeMatch");
    }
    /**
     * This is the backing field for {@link #getTree()}.
     */
    tree;
    /**
     * This is the backing field for {@link #getPattern()}.
     */
    pattern;
    /**
     * This is the backing field for {@link #getLabels()}.
     */
    labels;
    /**
     * This is the backing field for {@link #getMismatchedNode()}.
     */
    mismatchedNode;
    /**
     * Constructs a new instance of {@link ParseTreeMatch} from the specified
     * parse tree and pattern.
     *
     * @param tree The parse tree to match against the pattern.
     * @param pattern The parse tree pattern.
     * @param labels A mapping from label names to collections of
     * {@link ParseTree} objects located by the tree pattern matching process.
     * @param mismatchedNode The first node which failed to match the tree
     * pattern during the matching process.
     */
    constructor(tree, pattern, labels, mismatchedNode) {
      this.tree = tree;
      this.pattern = pattern;
      this.labels = labels;
      this.mismatchedNode = mismatchedNode;
    }
    /**
     * Get the last node associated with a specific `label`.
     *
     * For example, for pattern `<id:ID>`, `get("id")` returns the
     * node matched for that `ID`. If more than one node
     * matched the specified label, only the last is returned. If there is
     * no node associated with the label, this returns `null`.
     *
     * Pattern tags like `<ID>` and `<expr>` without labels are
     * considered to be labeled with `ID` and `expr`, respectively.
     *
     * @param label The label to check.
     *
     * @returns The last {@link ParseTree} to match a tag with the specified
     * label, or `null` if no parse tree matched a tag with the label.
     */
    get(label) {
      const parseTrees = this.labels.get(label);
      if (!parseTrees || parseTrees.length === 0) {
        return null;
      }
      return parseTrees[parseTrees.length - 1];
    }
    /**
     * Return all nodes matching a rule or token tag with the specified label.
     *
     * If the `label` is the name of a parser rule or token in the
     * grammar, the resulting list will contain both the parse trees matching
     * rule or tags explicitly labeled with the label and the complete set of
     * parse trees matching the labeled and unlabeled tags in the pattern for
     * the parser rule or token. For example, if `label` is `"foo"`,
     * the result will contain *all* of the following.
     *
     * - Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
     * `<foo:AnyTokenName>`.
     * - Parse tree nodes matching tags of the form `<anyLabel:foo>`.
     * - Parse tree nodes matching tags of the form `<foo>`.
     *
     * @param label The label.
     *
     * @returns A collection of all {@link ParseTree} nodes matching tags with
     * the specified `label`. If no nodes matched the label, an empty list
     * is returned.
     */
    getAll(label) {
      const nodes = this.labels.get(label);
      return nodes ?? [];
    }
    /**
     * Return a mapping from label -> [list of nodes].
     *
     * The map includes special entries corresponding to the names of rules and
     * tokens referenced in tags in the original pattern. For additional
     * information, see the description of {@link getAll(String)}.
     *
     * @returns A mapping from labels to parse tree nodes. If the parse tree
     * pattern did not contain any rule or token tags, this map will be empty.
     */
    getLabels() {
      return this.labels;
    }
    /**
     * Get the node at which we first detected a mismatch.
     *
     * @returns the node at which we first detected a mismatch, or `null`
     * if the match was successful.
     */
    getMismatchedNode() {
      return this.mismatchedNode;
    }
    /**
     * Gets a value indicating whether the match operation succeeded.
     *
     * @returns `true` if the match operation succeeded; otherwise, `false`.
     */
    succeeded() {
      return !this.mismatchedNode;
    }
    /**
     * Get the tree pattern we are matching against.
     *
     * @returns The tree pattern we are matching against.
     */
    getPattern() {
      return this.pattern;
    }
    /**
     * Get the parse tree we are trying to match to a pattern.
     *
     * @returns The {@link ParseTree} we are trying to match to a pattern.
     */
    getTree() {
      return this.tree;
    }
    toString() {
      return `Match ${this.succeeded() ? "succeeded" : "failed"}; found ${this.getLabels().size} labels`;
    }
  };
  var ParseTreePattern = class {
    static {
      __name(this, "ParseTreePattern");
    }
    /**
     * This is the backing field for {@link #getPatternRuleIndex()}.
     */
    patternRuleIndex;
    /**
     * This is the backing field for {@link #getPattern()}.
     */
    pattern;
    /**
     * This is the backing field for {@link #getPatternTree()}.
     */
    patternTree;
    /**
     * This is the backing field for {@link #getMatcher()}.
     */
    matcher;
    /**
     * Construct a new instance of the {@link ParseTreePattern} class.
     *
     * @param matcher The {@link ParseTreePatternMatcher} which created this
     * tree pattern.
     * @param pattern The tree pattern in concrete syntax form.
     * @param patternRuleIndex The parser rule which serves as the root of the
     * tree pattern.
     * @param patternTree The tree pattern in {@link ParseTree} form.
     */
    constructor(matcher, pattern, patternRuleIndex, patternTree) {
      this.matcher = matcher;
      this.patternRuleIndex = patternRuleIndex;
      this.pattern = pattern;
      this.patternTree = patternTree;
    }
    /**
     * Match a specific parse tree against this tree pattern.
     *
     * @param tree The parse tree to match against this tree pattern.
     * @returns A {@link ParseTreeMatch} object describing the result of the
     * match operation. The {@link ParseTreeMatch#succeeded()} method can be
     * used to determine whether or not the match was successful.
     */
    match(tree) {
      return this.matcher.match(tree, this);
    }
    /**
     * Determine whether or not a parse tree matches this tree pattern.
     *
     * @param tree The parse tree to match against this tree pattern.
     * @returns `true` if `tree` is a match for the current tree
     * pattern; otherwise, `false`.
     */
    matches(tree) {
      return this.matcher.match(tree, this).succeeded();
    }
    /**
     * Find all nodes using XPath and then try to match those subtrees against
     * this tree pattern.
     *
     * @param tree The {@link ParseTree} to match against this pattern.
     * @param xpath An expression matching the nodes
     *
     * @returns A collection of {@link ParseTreeMatch} objects describing the
     * successful matches. Unsuccessful matches are omitted from the result,
     * regardless of the reason for the failure.
     */
    findAll(tree, xpath) {
      const subtrees = XPath.findAll(tree, xpath, this.matcher.getParser());
      const matches = new Array();
      for (const t of subtrees) {
        const match = this.match(t);
        if (match.succeeded()) {
          matches.push(match);
        }
      }
      return matches;
    }
    /**
     * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
     *
     * @returns The {@link ParseTreePatternMatcher} which created this tree
     * pattern.
     */
    getMatcher() {
      return this.matcher;
    }
    /**
     * Get the tree pattern in concrete syntax form.
     *
     * @returns The tree pattern in concrete syntax form.
     */
    getPattern() {
      return this.pattern;
    }
    /**
     * Get the parser rule which serves as the outermost rule for the tree
     * pattern.
     *
     * @returns The parser rule which serves as the outermost rule for the tree
     * pattern.
     */
    getPatternRuleIndex() {
      return this.patternRuleIndex;
    }
    /**
     * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
     * the pattern are present in the parse tree as terminal nodes with a symbol
     * of type {@link RuleTagToken} or {@link TokenTagToken}.
     *
     * @returns The tree pattern as a {@link ParseTree}.
     */
    getPatternTree() {
      return this.patternTree;
    }
  };
  var InputMismatchException = class extends RecognitionException {
    static {
      __name(this, "InputMismatchException");
    }
    constructor(recognizer) {
      super({ message: "", recognizer, input: recognizer.inputStream, ctx: recognizer.context });
      this.offendingToken = recognizer.getCurrentToken();
    }
  };
  var FailedPredicateException = class extends RecognitionException {
    static {
      __name(this, "FailedPredicateException");
    }
    ruleIndex = 0;
    predicateIndex = 0;
    predicate;
    constructor(recognizer, predicate, message = null) {
      super({
        message: formatMessage(predicate ?? "no predicate", message ?? null),
        recognizer,
        input: recognizer.inputStream,
        ctx: recognizer.context
      });
      const s = recognizer.atn.states[recognizer.state];
      const trans = s.transitions[0];
      if (trans instanceof PredicateTransition) {
        this.ruleIndex = trans.ruleIndex;
        this.predicateIndex = trans.predIndex;
      } else {
        this.ruleIndex = 0;
        this.predicateIndex = 0;
      }
      this.predicate = predicate;
      this.offendingToken = recognizer.getCurrentToken();
    }
  };
  var formatMessage = /* @__PURE__ */ __name((predicate, message) => {
    if (message !== null) {
      return message;
    }
    return "failed predicate: {" + predicate + "}?";
  }, "formatMessage");
  var DefaultErrorStrategy = class {
    static {
      __name(this, "DefaultErrorStrategy");
    }
    /**
     * Indicates whether the error strategy is currently "recovering from an
     * error". This is used to suppress reporting multiple error messages while
     * attempting to recover from a detected syntax error.
     *
     * @see #inErrorRecoveryMode
     */
    errorRecoveryMode = false;
    /**
     * The index into the input stream where the last error occurred.
     * 	This is used to prevent infinite loops where an error is found
     *  but no token is consumed during recovery...another error is found,
     *  ad nauseam.  This is a failsafe mechanism to guarantee that at least
     *  one token/tree node is consumed for two errors.
     */
    lastErrorIndex = -1;
    lastErrorStates = new IntervalSet();
    /**
     * This field is used to propagate information about the lookahead following
     * the previous match. Since prediction prefers completing the current rule
     * to error recovery efforts, error reporting may occur later than the
     * original point where it was discoverable. The original context is used to
     * compute the true expected sets as though the reporting occurred as early
     * as possible.
     */
    nextTokensContext = null;
    nextTokenState = 0;
    /**
     * The default implementation simply calls {@link endErrorCondition} to
     * ensure that the handler is not in error recovery mode.
     */
    reset(recognizer) {
      this.endErrorCondition(recognizer);
    }
    /**
     * This method is called to enter error recovery mode when a recognition
     * exception is reported.
     *
     * @param _recognizer the parser instance
     */
    beginErrorCondition(_recognizer) {
      this.errorRecoveryMode = true;
    }
    inErrorRecoveryMode(_recognizer) {
      return this.errorRecoveryMode;
    }
    /**
     * This method is called to leave error recovery mode after recovering from
     * a recognition exception.
     */
    endErrorCondition(_recognizer) {
      this.errorRecoveryMode = false;
      this.lastErrorStates = new IntervalSet();
      this.lastErrorIndex = -1;
    }
    /**
     * The default implementation simply calls {@link endErrorCondition}.
     */
    reportMatch(recognizer) {
      this.endErrorCondition(recognizer);
    }
    /**
     * The default implementation returns immediately if the handler is already
     * in error recovery mode. Otherwise, it calls {@link beginErrorCondition}
     * and dispatches the reporting task based on the runtime type of `e`
     * according to the following table.
     *
     * - {@link NoViableAltException}: Dispatches the call to {@link reportNoViableAlternative}
     * - {@link InputMismatchException}: Dispatches the call to {@link reportInputMismatch}
     * - {@link FailedPredicateException}: Dispatches the call to {@link reportFailedPredicate}
     * - All other types: calls {@link Parser.notifyErrorListeners} to report the exception
     */
    reportError(recognizer, e) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      if (e instanceof NoViableAltException) {
        this.reportNoViableAlternative(recognizer, e);
      } else if (e instanceof InputMismatchException) {
        this.reportInputMismatch(recognizer, e);
      } else if (e instanceof FailedPredicateException) {
        this.reportFailedPredicate(recognizer, e);
      } else {
        recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
      }
    }
    /**
     * The default implementation resynchronizes the parser by consuming tokens
     * until we find one in the resynchronization set--loosely the set of tokens
     * that can follow the current rule.
     *
     */
    recover(recognizer, _e) {
      if (this.lastErrorIndex === recognizer.inputStream?.index && this.lastErrorStates.contains(recognizer.state)) {
        recognizer.consume();
      }
      this.lastErrorIndex = recognizer.inputStream?.index ?? 0;
      this.lastErrorStates.addOne(recognizer.state);
      const followSet = this.getErrorRecoverySet(recognizer);
      this.consumeUntil(recognizer, followSet);
    }
    /**
     * The default implementation of {@link ANTLRErrorStrategy.sync} makes sure
     * that the current lookahead symbol is consistent with what were expecting
     * at this point in the ATN. You can call this anytime but ANTLR only
     * generates code to check before subrules/loops and each iteration.
     *
     * Implements Jim Idle's magic sync mechanism in closures and optional
     * subrules. E.g.,
     *
     * ```
     * a : sync ( stuff sync )* ;
     * sync : {consume to what can follow sync} ;
     * ```
     *
     * At the start of a sub rule upon error, {@link sync} performs single
     * token deletion, if possible. If it can't do that, it bails on the current
     * rule and uses the default error recovery, which consumes until the
     * resynchronization set of the current rule.
     *
     * If the sub rule is optional (`(...)?`, `(...)*`, or block
     * with an empty alternative), then the expected set includes what follows
     * the subrule.
     *
     * During loop iteration, it consumes until it sees a token that can start a
     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
     * stay in the loop as long as possible.
     *
     * **ORIGINS**
     *
     * Previous versions of ANTLR did a poor job of their recovery within loops.
     * A single mismatch token or missing token would force the parser to bail
     * out of the entire rules surrounding the loop. So, for rule
     *
     * ```
     * classDef : 'class' ID '{' member* '}'
     * ```
     *
     * input with an extra token between members would force the parser to
     * consume until it found the next class definition rather than the next
     * member definition of the current class.
     *
     * This functionality cost a little bit of effort because the parser has to
     * compare token set at the start of the loop and at each iteration. If for
     * some reason speed is suffering for you, you can turn off this
     * functionality by simply overriding this method as a blank { }.
     *
     */
    sync(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      const s = recognizer.atn.states[recognizer.state];
      const la = recognizer.tokenStream.LA(1);
      const nextTokens = recognizer.atn.nextTokens(s);
      if (nextTokens.contains(la)) {
        this.nextTokensContext = null;
        this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
        return;
      }
      if (nextTokens.contains(Token.EPSILON)) {
        if (this.nextTokensContext === null) {
          this.nextTokensContext = recognizer.context;
          this.nextTokenState = recognizer.state;
        }
        return;
      }
      switch (s.constructor.stateType) {
        case ATNState.BLOCK_START:
        case ATNState.STAR_BLOCK_START:
        case ATNState.PLUS_BLOCK_START:
        case ATNState.STAR_LOOP_ENTRY: {
          if (this.singleTokenDeletion(recognizer) !== null) {
            return;
          }
          throw new InputMismatchException(recognizer);
        }
        case ATNState.PLUS_LOOP_BACK:
        case ATNState.STAR_LOOP_BACK: {
          this.reportUnwantedToken(recognizer);
          const expecting = new IntervalSet();
          expecting.addSet(recognizer.getExpectedTokens());
          const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
          break;
        }
        default:
      }
    }
    /**
     * This is called by {@link reportError} when the exception is a
     * {@link NoViableAltException}.
     *
     * @see reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportNoViableAlternative(recognizer, e) {
      if (e.message.length > 0) {
        recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
        return;
      }
      const tokens = recognizer.tokenStream;
      let input;
      if (tokens !== null && e.startToken) {
        if (e.startToken.type === Token.EOF) {
          input = "<EOF>";
        } else {
          input = tokens.getTextFromRange(e.startToken, e.offendingToken);
        }
      } else {
        input = "<unknown input>";
      }
      const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
      recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    /**
     * This is called by {@link reportError} when the exception is an {@link InputMismatchException}.
     *
     * @see reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportInputMismatch(recognizer, e) {
      if (e.message.length > 0) {
        recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
        return;
      }
      const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toStringWithVocabulary(recognizer.vocabulary);
      recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    /**
     * This is called by {@link reportError} when the exception is a
     * {@link FailedPredicateException}.
     *
     * @see reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportFailedPredicate(recognizer, e) {
      const ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
      const msg = "rule " + ruleName + " " + e.message;
      recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    /**
     * This method is called to report a syntax error which requires the removal
     * of a token from the input stream. At the time this method is called, the
     * erroneous symbol is current `LT(1)` symbol and has not yet been
     * removed from the input stream. When this method returns,
     * `recognizer` is in error recovery mode.
     *
     * This method is called when {@link singleTokenDeletion} identifies
     * single-token deletion as a viable recovery strategy for a mismatched
     * input error.
     *
     * The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser.notifyErrorListeners}.
     *
     * @param recognizer the parser instance
     */
    reportUnwantedToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      const t = recognizer.getCurrentToken();
      const tokenName = this.getTokenErrorDisplay(t);
      const expecting = this.getExpectedTokens(recognizer);
      const msg = "extraneous input " + tokenName + " expecting " + expecting.toStringWithVocabulary(recognizer.vocabulary);
      recognizer.notifyErrorListeners(msg, t, null);
    }
    /**
     * This method is called to report a syntax error which requires the
     * insertion of a missing token into the input stream. At the time this
     * method is called, the missing token has not yet been inserted. When this
     * method returns, `recognizer` is in error recovery mode.
     *
     * This method is called when {@link singleTokenInsertion} identifies
     * single-token insertion as a viable recovery strategy for a mismatched
     * input error.
     *
     * The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser.notifyErrorListeners}.
     *
     * @param recognizer the parser instance
     */
    reportMissingToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      const t = recognizer.getCurrentToken();
      const expecting = this.getExpectedTokens(recognizer);
      const msg = "missing " + expecting.toStringWithVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
      recognizer.notifyErrorListeners(msg, t, null);
    }
    /**
     * The default implementation attempts to recover from the mismatched input
     * by using single token insertion and deletion as described below. If the
     * recovery attempt fails, this method throws an
     * {@link InputMismatchException}.
     *
     * **EXTRA TOKEN** (single token deletion)
     *
     * `LA(1)` is not what we are looking for. If `LA(2)` has the
     * right token, however, then assume `LA(1)` is some extra spurious
     * token and delete it. Then consume and return the next token (which was
     * the `LA(2)` token) as the successful result of the match operation.
     *
     * This recovery strategy is implemented by {@link singleTokenDeletion}.
     *
     * **MISSING TOKEN** (single token insertion)
     *
     * If current token (at `LA(1)`) is consistent with what could come
     * after the expected `LA(1)` token, then assume the token is missing
     * and use the parser's {@link TokenFactory} to create it on the fly. The
     * "insertion" is performed by returning the created token as the successful
     * result of the match operation.
     *
     * This recovery strategy is implemented by {@link singleTokenInsertion}.
     *
     * **EXAMPLE**
     *
     * For example, Input `i=(3;` is clearly missing the `')'`. When
     * the parser returns from the nested call to `expr`, it will have
     * call chain:
     *
     * ```
     * stat -> expr -> atom
     * ```
     *
     * and it will be trying to match the `')'` at this point in the
     * derivation:
     *
     * ```
     * => ID '=' '(' INT ')' ('+' atom)* ';'
     * ^
     * ```
     *
     * The attempt to match `')'` will fail when it sees `';'` and
     * call {@link recoverInline}. To recover, it sees that `LA(1)==';'`
     * is in the set of tokens that can follow the `')'` token reference
     * in rule `atom`. It can assume that you forgot the `')'`.
     */
    recoverInline(recognizer) {
      const matchedSymbol = this.singleTokenDeletion(recognizer);
      if (matchedSymbol) {
        recognizer.consume();
        return matchedSymbol;
      }
      if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
      }
      throw new InputMismatchException(recognizer);
    }
    /**
     * This method implements the single-token insertion inline error recovery
     * strategy. It is called by {@link recoverInline} if the single-token
     * deletion strategy fails to recover from the mismatched input. If this
     * method returns `true`, `recognizer` will be in error recovery
     * mode.
     *
     * This method determines whether or not single-token insertion is viable by
     * checking if the `LA(1)` input symbol could be successfully matched
     * if it were instead the `LA(2)` symbol. If this method returns
     * `true`, the caller is responsible for creating and inserting a
     * token with the correct type to produce this behavior.
     *
     * @param recognizer the parser instance
     * @returns `true` if single-token insertion is a viable recovery
     * strategy for the current mismatched input, otherwise `false`
     */
    singleTokenInsertion(recognizer) {
      const currentSymbolType = recognizer.tokenStream?.LA(1) ?? -1;
      const atn = recognizer.atn;
      const currentState = atn.states[recognizer.state];
      const next = currentState.transitions[0].target;
      const expectingAtLL2 = atn.nextTokens(next, recognizer.context ?? void 0);
      if (expectingAtLL2.contains(currentSymbolType)) {
        this.reportMissingToken(recognizer);
        return true;
      }
      return false;
    }
    /**
     * This method implements the single-token deletion inline error recovery
     * strategy. It is called by {@link recoverInline} to attempt to recover
     * from mismatched input. If this method returns null, the parser and error
     * handler state will not have changed. If this method returns non-null,
     * `recognizer` will *not* be in error recovery mode since the
     * returned token was a successful match.
     *
     * If the single-token deletion is successful, this method calls
     * {@link reportUnwantedToken} to report the error, followed by
     * {@link Parser.consume} to actually "delete" the extraneous token. Then,
     * before returning {@link reportMatch} is called to signal a successful
     * match.
     *
     * @param recognizer the parser instance
     * @returns the successfully matched {@link Token} instance if single-token
     * deletion successfully recovers from the mismatched input, otherwise
     * `null`
     */
    singleTokenDeletion(recognizer) {
      const nextTokenType = recognizer.tokenStream?.LA(2) ?? -1;
      const expecting = this.getExpectedTokens(recognizer);
      if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        recognizer.consume();
        const matchedSymbol = recognizer.getCurrentToken();
        this.reportMatch(recognizer);
        return matchedSymbol;
      }
      return null;
    }
    /**
     * Conjure up a missing token during error recovery.
     *
     * The recognizer attempts to recover from single missing
     * symbols. But, actions might refer to that missing symbol.
     * For example, x=ID {f($x);}. The action clearly assumes
     * that there has been an identifier matched previously and that
     * $x points at that token. If that token is missing, but
     * the next token in the stream is what we want we assume that
     * this token is missing and we keep going. Because we
     * have to return some token to replace the missing token,
     * we have to conjure one up. This method gives the user control
     * over the tokens returned for missing tokens. Mostly,
     * you will want to create something special for identifier
     * tokens. For literals such as '{' and ',', the default
     * action in the parser or tree parser works. It simply creates
     * a CommonToken of the appropriate type. The text will be the token.
     * If you change what tokens must be created by the lexer,
     * override this method to create the appropriate tokens.
     */
    getMissingSymbol(recognizer) {
      const currentSymbol = recognizer.getCurrentToken();
      const expecting = this.getExpectedTokens(recognizer);
      let expectedTokenType = Token.INVALID_TYPE;
      if (expecting.length !== 0) {
        expectedTokenType = expecting.minElement;
      }
      let tokenText;
      if (expectedTokenType === Token.EOF) {
        tokenText = "<missing EOF>";
      } else {
        tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
      }
      let current = currentSymbol;
      const lookBack = recognizer.tokenStream?.LT(-1);
      if (current.type === Token.EOF && lookBack !== null) {
        current = lookBack;
      }
      return recognizer.getTokenFactory().create(
        current.source,
        expectedTokenType,
        tokenText,
        Token.DEFAULT_CHANNEL,
        -1,
        -1,
        current.line,
        current.column
      );
    }
    getExpectedTokens(recognizer) {
      return recognizer.getExpectedTokens();
    }
    /**
     * How should a token be displayed in an error message? The default
     * is to display just the text, but during development you might
     * want to have a lot of information spit out. Override in that case
     * to use t.toString() (which, for CommonToken, dumps everything about
     * the token). This is better than forcing you to override a method in
     * your token objects because you don't have to go modify your lexer
     * so that it creates a new Java type.
     */
    getTokenErrorDisplay(t) {
      if (t === null) {
        return "<no token>";
      }
      let s = t.text;
      if (!s) {
        if (t.type === Token.EOF) {
          s = "<EOF>";
        } else {
          s = "<" + t.type + ">";
        }
      }
      return this.escapeWSAndQuote(s);
    }
    escapeWSAndQuote(s) {
      s = s.replace(/\n/g, "\\n");
      s = s.replace(/\r/g, "\\r");
      s = s.replace(/\t/g, "\\t");
      return "'" + s + "'";
    }
    /**
     * Compute the error recovery set for the current rule. During
     * rule invocation, the parser pushes the set of tokens that can
     * follow that rule reference on the stack; this amounts to
     * computing FIRST of what follows the rule reference in the
     * enclosing rule. See LinearApproximator.FIRST().
     * This local follow set only includes tokens
     * from within the rule; i.e., the FIRST computation done by
     * ANTLR stops at the end of a rule.
     *
     * EXAMPLE
     *
     * When you find a "no viable alt exception", the input is not
     * consistent with any of the alternatives for rule r. The best
     * thing to do is to consume tokens until you see something that
     * can legally follow a call to r//or* any rule that called r.
     * You don't want the exact set of viable next tokens because the
     * input might just be missing a token--you might consume the
     * rest of the input looking for one of the missing tokens.
     *
     * Consider grammar:
     *
     * a : '[' b ']'
     * | '(' b ')'
     * ;
     * b : c '^' INT ;
     * c : ID
     * | INT
     * ;
     *
     * At each rule invocation, the set of tokens that could follow
     * that rule is pushed on a stack. Here are the various
     * context-sensitive follow sets:
     *
     * FOLLOW(b1_in_a) = FIRST(']') = ']'
     * FOLLOW(b2_in_a) = FIRST(')') = ')'
     * FOLLOW(c_in_b) = FIRST('^') = '^'
     *
     * Upon erroneous input "[]", the call chain is
     *
     * a -> b -> c
     *
     * and, hence, the follow context stack is:
     *
     * depth follow set start of rule execution
     * 0 <EOF> a (from main())
     * 1 ']' b
     * 2 '^' c
     *
     * Notice that ')' is not included, because b would have to have
     * been called from a different context in rule a for ')' to be
     * included.
     *
     * For error recovery, we cannot consider FOLLOW(c)
     * (context-sensitive or otherwise). We need the combined set of
     * all context-sensitive FOLLOW sets--the set of all tokens that
     * could follow any reference in the call chain. We need to
     * resync to one of those tokens. Note that FOLLOW(c)='^' and if
     * we resync'd to that token, we'd consume until EOF. We need to
     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
     * In this case, for input "[]", LA(1) is ']' and in the set, so we would
     * not consume anything. After printing an error, rule c would
     * return normally. Rule b would not find the required '^' though.
     * At this point, it gets a mismatched token error and throws an
     * exception (since LA(1) is not in the viable following token
     * set). The rule exception handler tries to recover, but finds
     * the same recovery set and doesn't consume anything. Rule b
     * exits normally returning to rule a. Now it finds the ']' (and
     * with the successful match exits errorRecovery mode).
     *
     * So, you can see that the parser walks up the call chain looking
     * for the token that was a member of the recovery set.
     *
     * Errors are not generated in errorRecovery mode.
     *
     * ANTLR's error recovery mechanism is based upon original ideas:
     *
     * "Algorithms + Data Structures = Programs" by Niklaus Wirth
     *
     * and
     *
     * "A note on error recovery in recursive descent parsers":
     * http://portal.acm.org/citation.cfm?id=947902.947905
     *
     * Later, Josef Grosch had some good ideas:
     *
     * "Efficient and Comfortable Error Recovery in Recursive Descent
     * Parsers":
     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
     *
     * Like Grosch I implement context-sensitive FOLLOW sets that are combined
     * at run-time upon error to avoid overhead during parsing.
     */
    getErrorRecoverySet(recognizer) {
      const atn = recognizer.atn;
      let ctx = recognizer.context;
      const recoverSet = new IntervalSet();
      while (ctx !== null && ctx.invokingState >= 0) {
        const invokingState = atn.states[ctx.invokingState];
        const rt = invokingState.transitions[0];
        const follow = atn.nextTokens(rt.followState);
        recoverSet.addSet(follow);
        ctx = ctx.parent;
      }
      recoverSet.removeOne(Token.EPSILON);
      return recoverSet;
    }
    /** Consume tokens until one matches the given token set. */
    consumeUntil(recognizer, set) {
      let ttype = recognizer.tokenStream?.LA(1) ?? -1;
      while (ttype !== Token.EOF && !set.contains(ttype)) {
        recognizer.consume();
        ttype = recognizer.tokenStream?.LA(1) ?? -1;
      }
    }
  };
  var BailErrorStrategy = class extends DefaultErrorStrategy {
    static {
      __name(this, "BailErrorStrategy");
    }
    /**
     * Instead of recovering from exception `e`, re-throw it wrapped
     * in a {@link ParseCancellationException} so it is not caught by the
     * rule function catches. Use {@link Exception//getCause()} to get the
     * original {@link RecognitionException}.
     */
    recover(recognizer, e) {
      throw new ParseCancellationException(e);
    }
    /**
     * Make sure we don't attempt to recover inline; if the parser
     * successfully recovers, it won't throw an exception.
     */
    recoverInline(recognizer) {
      const exception = new InputMismatchException(recognizer);
      throw new ParseCancellationException(exception);
    }
    // Make sure we don't attempt to recover from problems in subrules.
    sync(_recognizer) {
    }
  };
  var ListTokenSource = class {
    static {
      __name(this, "ListTokenSource");
    }
    /**
     * The name of the input source. If this value is `null`, a call to
     * {@link #getSourceName} should return the source name used to create the
     * the next token in {@link #tokens} (or the previous token if the end of
     * the input has been reached).
     */
    sourceName;
    tokenFactory = CommonTokenFactory.DEFAULT;
    /**
     * The wrapped collection of {@link Token} objects to return.
     */
    tokens;
    /**
     * The index into {@link tokens} of token to return by the next call to
     * {@link #nextToken}. The end of the input is indicated by this value
     * being greater than or equal to the number of items in {@link #tokens}.
     */
    i;
    /**
     * This field caches the EOF token for the token source.
     */
    eofToken;
    constructor(tokens, sourceName) {
      this.tokens = tokens;
      this.sourceName = sourceName ?? "";
    }
    get column() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].column;
      }
      if (this.eofToken !== null) {
        return this.eofToken.column;
      }
      if (this.tokens.length > 0) {
        const lastToken = this.tokens[this.tokens.length - 1];
        const tokenText = lastToken.text;
        if (tokenText) {
          const lastNewLine = tokenText.lastIndexOf("\n");
          if (lastNewLine >= 0) {
            return tokenText.length - lastNewLine - 1;
          }
        }
        return lastToken.column + lastToken.stop - lastToken.start + 1;
      }
      return 0;
    }
    nextToken() {
      if (this.i >= this.tokens.length) {
        if (this.eofToken === null) {
          let start = -1;
          if (this.tokens.length > 0) {
            const previousStop = this.tokens[this.tokens.length - 1].stop;
            if (previousStop !== -1) {
              start = previousStop + 1;
            }
          }
          const stop = Math.max(-1, start - 1);
          this.eofToken = this.tokenFactory.create(
            [this, this.inputStream],
            Token.EOF,
            "EOF",
            Token.DEFAULT_CHANNEL,
            start,
            stop,
            this.line,
            this.column
          );
        }
        return this.eofToken;
      }
      const t = this.tokens[this.i];
      if (this.i === this.tokens.length - 1 && t.type === Token.EOF) {
        this.eofToken = t;
      }
      this.i++;
      return t;
    }
    get line() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].line;
      }
      if (this.eofToken !== null) {
        return this.eofToken.line;
      }
      if (this.tokens.length > 0) {
        const lastToken = this.tokens[this.tokens.length - 1];
        let line = lastToken.line;
        const tokenText = lastToken.text;
        if (tokenText) {
          for (const char of tokenText) {
            if (char === "\n") {
              line++;
            }
          }
        }
        return line;
      }
      return 1;
    }
    get inputStream() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].inputStream;
      }
      if (this.eofToken !== null) {
        return this.eofToken.inputStream;
      }
      if (this.tokens.length > 0) {
        return this.tokens[this.tokens.length - 1].inputStream;
      }
      return null;
    }
    getSourceName() {
      if (this.sourceName !== null) {
        return this.sourceName;
      }
      const inputStream = this.inputStream;
      if (inputStream !== null) {
        return inputStream.getSourceName();
      }
      return "List";
    }
  };
  var InterpreterRuleContext = class extends ParserRuleContext {
    static {
      __name(this, "InterpreterRuleContext");
    }
    /** This is the backing field for {@link #getRuleIndex}. */
    #ruleIndex;
    constructor(ruleIndex, parent, invokingStateNumber) {
      super(parent, invokingStateNumber);
      this.#ruleIndex = ruleIndex;
    }
    get ruleIndex() {
      return this.#ruleIndex;
    }
  };
  var TraceListener = class {
    static {
      __name(this, "TraceListener");
    }
    parser;
    constructor(parser) {
      this.parser = parser;
    }
    enterEveryRule(ctx) {
      console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser.inputStream?.LT(1)?.text);
    }
    visitTerminal(node) {
      console.log("consume " + node.getSymbol() + " rule " + this.parser.ruleNames[this.parser.context.ruleIndex]);
    }
    exitEveryRule(ctx) {
      console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser.inputStream?.LT(1)?.text);
    }
    visitErrorNode(_node) {
    }
  };
  var Parser = class extends Recognizer {
    static {
      __name(this, "Parser");
    }
    /** For testing only. */
    printer = null;
    /**
     * Specifies whether or not the parser should construct a parse tree during
     * the parsing process. The default value is `true`.
     *
     * @see #getBuildParseTree
     * @see #setBuildParseTree
     */
    buildParseTrees = true;
    /**
     * The error handling strategy for the parser. The default value is a new
     * instance of {@link DefaultErrorStrategy}.
     *
     * @see #getErrorHandler
     * @see #setErrorHandler
     */
    errorHandler = new DefaultErrorStrategy();
    /**
     * The {@link ParserRuleContext} object for the currently executing rule.
     * This is always non-null during the parsing process.
     */
    // TODO: make private
    context = null;
    precedenceStack = [];
    /**
     * The list of {@link ParseTreeListener} listeners registered to receive
     * events during the parse.
     *
     * @see #addParseListener
     */
    parseListeners = null;
    /**
     * The number of syntax errors reported during parsing. This value is
     * incremented each time {@link #notifyErrorListeners} is called.
     */
    syntaxErrors = 0;
    /** Indicates parser has matched EOF token. See {@link #exitRule()}. */
    matchedEOF = false;
    /**
     * When {@link #setTrace}`(true)` is called, a reference to the
     * {@link TraceListener} is stored here so it can be easily removed in a
     * later call to {@link #setTrace}`(false)`. The listener itself is
     * implemented as a parser listener so this field is not directly used by
     * other parser methods.
     */
    tracer = null;
    /**
     * This field holds the deserialized {@link ATN} with bypass alternatives, created
     * lazily upon first demand. In 4.10 I changed from map<serializedATNstring, ATN>
     * since we only need one per parser object and also it complicates other targets
     * that don't use ATN strings.
     *
     * @see ATNDeserializationOptions#isGenerateRuleBypassTransitions()
     */
    bypassAltsAtnCache = null;
    #inputStream;
    /**
     * This is all the parsing support code essentially. Most of it is error recovery stuff.
     */
    constructor(input) {
      super();
      this.precedenceStack.push(0);
      this.syntaxErrors = 0;
      this.#inputStream = input;
    }
    /** reset the parser's state */
    reset(rewindInputStream = true) {
      if (rewindInputStream) {
        this.inputStream.seek(0);
      }
      this.errorHandler.reset(this);
      this.context = null;
      this.syntaxErrors = 0;
      this.matchedEOF = false;
      this.setTrace(false);
      this.precedenceStack = [];
      this.precedenceStack.push(0);
      if (this.interpreter) {
        this.interpreter.reset();
      }
    }
    /**
     * Match current input symbol against `ttype`. If the symbol type
     * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link consume} are
     * called to complete the match process.
     *
     * If the symbol type does not match,
     * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link buildParseTree} is
     * `true` and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link ParserRuleContext//addErrorNode}.
     *
     * @param ttype the token type to match
     * @returns the matched symbol
     * @throws RecognitionException if the current input symbol did not match
     * `ttype` and the error strategy could not recover from the
     * mismatched symbol
     */
    match(ttype) {
      let t = this.getCurrentToken();
      if (t.type === ttype) {
        if (ttype === Token.EOF) {
          this.matchedEOF = true;
        }
        this.errorHandler.reportMatch(this);
        this.consume();
      } else {
        t = this.errorHandler.recoverInline(this);
        if (this.buildParseTrees && t.tokenIndex === -1) {
          this.context.addErrorNode(this.createErrorNode(this.context, t));
        }
      }
      return t;
    }
    /**
     * Match current input symbol as a wildcard. If the symbol type matches
     * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
     * and {@link consume} are called to complete the match process.
     *
     * If the symbol type does not match,
     * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link buildParseTree} is
     * `true` and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link ParserRuleContext//addErrorNode}.
     *
     * @returns the matched symbol
     * @throws RecognitionException if the current input symbol did not match
     * a wildcard and the error strategy could not recover from the mismatched
     * symbol
     */
    matchWildcard() {
      let t = this.getCurrentToken();
      if (t.type > 0) {
        this.errorHandler.reportMatch(this);
        this.consume();
      } else {
        t = this.errorHandler.recoverInline(this);
        if (this.buildParseTrees && t.tokenIndex === -1) {
          this.context.addErrorNode(this.createErrorNode(this.context, t));
        }
      }
      return t;
    }
    getParseListeners() {
      return this.parseListeners ?? [];
    }
    /**
     * Registers `listener` to receive events during the parsing process.
     *
     * To support output-preserving grammar transformations (including but not
     * limited to left-recursion removal, automated left-factoring, and
     * optimized code generation), calls to listener methods during the parse
     * may differ substantially from calls made by
     * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
     * particular, rule entry and exit events may occur in a different order
     * during the parse than after the parser. In addition, calls to certain
     * rule entry methods may be omitted.
     *
     * With the following specific exceptions, calls to listener events are
     * deterministic*, i.e. for identical input the calls to listener
     * methods will be the same.
     *
     * - Alterations to the grammar used to generate code may change the
     * behavior of the listener calls.
     * - Alterations to the command line options passed to ANTLR 4 when
     * generating the parser may change the behavior of the listener calls.
     * - Changing the version of the ANTLR Tool used to generate the parser
     * may change the behavior of the listener calls.
     *
     * @param listener the listener to add
     *
     * @throws NullPointerException if {@code} listener is `null`
     */
    addParseListener(listener) {
      if (listener === null) {
        throw new Error("listener");
      }
      if (this.parseListeners === null) {
        this.parseListeners = [];
      }
      this.parseListeners.push(listener);
    }
    /**
     * Remove `listener` from the list of parse listeners.
     *
     * If `listener` is `null` or has not been added as a parse
     * listener, this method does nothing.
     *
     * @param listener the listener to remove
     */
    removeParseListener(listener) {
      if (this.parseListeners !== null && listener !== null) {
        const idx = this.parseListeners.indexOf(listener);
        if (idx >= 0) {
          this.parseListeners.splice(idx, 1);
        }
        if (this.parseListeners.length === 0) {
          this.parseListeners = null;
        }
      }
    }
    // Remove all parse listeners.
    removeParseListeners() {
      this.parseListeners = null;
    }
    // Notify any parse listeners of an enter rule event.
    triggerEnterRuleEvent() {
      if (this.parseListeners !== null) {
        const ctx = this.context;
        this.parseListeners.forEach((listener) => {
          listener.enterEveryRule(ctx);
          ctx.enterRule(listener);
        });
      }
    }
    /**
     * Notify any parse listeners of an exit rule event.
     *
     * @see //addParseListener
     */
    triggerExitRuleEvent() {
      if (this.parseListeners !== null) {
        const ctx = this.context;
        this.parseListeners.slice(0).reverse().forEach((listener) => {
          ctx.exitRule(listener);
          listener.exitEveryRule(ctx);
        });
      }
    }
    getTokenFactory() {
      return this.inputStream.tokenSource.tokenFactory;
    }
    // Tell our token source and error strategy about a new way to create tokens.
    setTokenFactory(factory) {
      this.inputStream.tokenSource.tokenFactory = factory;
    }
    /**
     * The preferred method of getting a tree pattern. For example, here's a
     * sample use:
     *
     * ```
     * const t = parser.expr();
     * const p = parser.compileParseTreePattern("<ID>+0", MyParser.RULE_expr);
     * const m = p.match(t);
     * const id = m.get("ID");
     * ```
     */
    compileParseTreePattern(pattern, patternRuleIndex, lexer) {
      if (!lexer) {
        if (this.tokenStream !== null) {
          const tokenSource = this.tokenStream.tokenSource;
          if (tokenSource instanceof Lexer) {
            lexer = tokenSource;
          }
        }
      }
      if (!lexer) {
        throw new Error("Parser can't discover a lexer to use");
      }
      const m2 = new ParseTreePatternMatcher(lexer, this);
      return m2.compile(pattern, patternRuleIndex);
    }
    /**
     * The ATN with bypass alternatives is expensive to create so we create it
     * lazily.
     *
     * @throws UnsupportedOperationException if the current parser does not
     * implement the {@link getSerializedATN()} method.
     */
    getATNWithBypassAlts() {
      const serializedAtn = this.getSerializedATN();
      if (serializedAtn === null) {
        throw new Error("The current parser does not support an ATN with bypass alternatives.");
      }
      if (this.bypassAltsAtnCache !== null) {
        return this.bypassAltsAtnCache;
      }
      const deserializationOptions = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: true };
      this.bypassAltsAtnCache = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);
      return this.bypassAltsAtnCache;
    }
    /**
     * Gets the number of syntax errors reported during parsing. This value is
     * incremented each time {@link notifyErrorListeners} is called.
     */
    get numberOfSyntaxErrors() {
      return this.syntaxErrors;
    }
    get inputStream() {
      return this.#inputStream;
    }
    set inputStream(input) {
      this.tokenStream = input;
    }
    get tokenStream() {
      return this.#inputStream;
    }
    /** Set the token stream and reset the parser. */
    set tokenStream(input) {
      this.reset(false);
      this.#inputStream = input;
    }
    /**
     * Match needs to return the current input symbol, which gets put
     * into the label for the associated token ref; e.g., x=ID.
     */
    getCurrentToken() {
      return this.inputStream.LT(1);
    }
    notifyErrorListeners(msg, offendingToken, err) {
      offendingToken = offendingToken ?? null;
      err = err ?? null;
      if (offendingToken === null) {
        offendingToken = this.getCurrentToken();
      }
      this.syntaxErrors += 1;
      const line = offendingToken.line;
      const column = offendingToken.column;
      this.errorListenerDispatch.syntaxError(this, offendingToken, line, column, msg, err);
    }
    /**
     * Consume and return the {@link getCurrentToken current symbol}.
     *
     * E.g., given the following input with `A` being the current
     * lookahead symbol, this function moves the cursor to `B` and returns
     * `A`.
     *
     * ```
     * A B
     * ^
     * ```
     *
     * If the parser is not in error recovery mode, the consumed symbol is added
     * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
     * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
     * If the parser *is* in error recovery mode, the consumed symbol is
     * added to the parse tree using
     * {@link ParserRuleContext//addErrorNode(Token)}, and
     * {@link ParseTreeListener//visitErrorNode} is called on any parse
     * listeners.
     */
    consume() {
      const o = this.getCurrentToken();
      if (o.type !== Token.EOF) {
        this.tokenStream.consume();
      }
      const hasListener = this.parseListeners !== null && this.parseListeners.length > 0;
      if (this.buildParseTrees || hasListener) {
        let node;
        if (this.errorHandler.inErrorRecoveryMode(this)) {
          node = this.context.addErrorNode(this.createErrorNode(this.context, o));
        } else {
          node = this.context.addTokenNode(o);
        }
        if (hasListener) {
          this.parseListeners.forEach((listener) => {
            if (node instanceof ErrorNode) {
              listener.visitErrorNode(node);
            } else {
              listener.visitTerminal(node);
            }
          });
        }
      }
      return o;
    }
    addContextToParseTree() {
      if (this.context?.parent) {
        this.context.parent.addChild(this.context);
      }
    }
    /**
     * Always called by generated parsers upon entry to a rule. Access field
     * {@link context} get the current context.
     */
    enterRule(localctx, state, _ruleIndex) {
      this.state = state;
      this.context = localctx;
      this.context.start = this.inputStream.LT(1);
      if (this.buildParseTrees) {
        this.addContextToParseTree();
      }
      this.triggerEnterRuleEvent();
    }
    exitRule() {
      if (this.matchedEOF) {
        this.context.stop = this.inputStream.LT(1);
      } else {
        this.context.stop = this.inputStream.LT(-1);
      }
      this.triggerExitRuleEvent();
      this.state = this.context.invokingState;
      this.context = this.context.parent;
    }
    enterOuterAlt(localctx, altNum) {
      localctx.setAltNumber(altNum);
      if (this.buildParseTrees && this.context !== localctx) {
        if (this.context?.parent) {
          this.context.parent.removeLastChild();
          this.context.parent.addChild(localctx);
        }
      }
      this.context = localctx;
    }
    /**
     * Get the precedence level for the top-most precedence rule.
     *
     * @returns The precedence level for the top-most precedence rule, or -1 if
     * the parser context is not nested within a precedence rule.
     */
    getPrecedence() {
      if (this.precedenceStack.length === 0) {
        return -1;
      }
      return this.precedenceStack[this.precedenceStack.length - 1];
    }
    enterRecursionRule(localctx, state, ruleIndex, precedence) {
      this.state = state;
      this.precedenceStack.push(precedence);
      this.context = localctx;
      this.context.start = this.inputStream.LT(1);
      this.triggerEnterRuleEvent();
    }
    /** Like {@link enterRule} but for recursive rules. */
    pushNewRecursionContext(localctx, state, _ruleIndex) {
      const previous = this.context;
      previous.parent = localctx;
      previous.invokingState = state;
      previous.stop = this.inputStream.LT(-1);
      this.context = localctx;
      this.context.start = previous.start;
      if (this.buildParseTrees) {
        this.context.addChild(previous);
      }
      this.triggerEnterRuleEvent();
    }
    unrollRecursionContexts(parent) {
      this.precedenceStack.pop();
      this.context.stop = this.inputStream.LT(-1);
      const retCtx = this.context;
      const parseListeners = this.getParseListeners();
      if (parseListeners !== null && parseListeners.length > 0) {
        while (this.context !== parent) {
          this.triggerExitRuleEvent();
          this.context = this.context.parent;
        }
      } else {
        this.context = parent;
      }
      retCtx.parent = parent;
      if (this.buildParseTrees && parent !== null) {
        parent.addChild(retCtx);
      }
    }
    getInvokingContext(ruleIndex) {
      let ctx = this.context;
      while (ctx !== null) {
        if (ctx.ruleIndex === ruleIndex) {
          return ctx;
        }
        ctx = ctx.parent;
      }
      return null;
    }
    precpred(_localctx, precedence) {
      return precedence >= this.precedenceStack[this.precedenceStack.length - 1];
    }
    /**
     * Checks whether or not `symbol` can follow the current state in the
     * ATN. The behavior of this method is equivalent to the following, but is
     * implemented such that the complete context-sensitive follow set does not
     * need to be explicitly constructed.
     *
     * ```
     * return getExpectedTokens().contains(symbol);
     * ```
     *
     * @param symbol the symbol type to check
     * @returns `true` if `symbol` can follow the current state in
     * the ATN, otherwise `false`.
     */
    isExpectedToken(symbol) {
      const atn = this.interpreter.atn;
      let ctx = this.context;
      const s = atn.states[this.state];
      let following = atn.nextTokens(s);
      if (following.contains(symbol)) {
        return true;
      }
      if (!following.contains(Token.EPSILON)) {
        return false;
      }
      while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
        const invokingState = atn.states[ctx.invokingState];
        const rt = invokingState.transitions[0];
        following = atn.nextTokens(rt.followState);
        if (following.contains(symbol)) {
          return true;
        }
        ctx = ctx.parent;
      }
      if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
        return true;
      } else {
        return false;
      }
    }
    /**
     * Computes the set of input symbols which could follow the current parser
     * state and context, as given by {@link getState} and {@link getContext},
     * respectively.
     *
     * {@link ATN.getExpectedTokens ATN.getExpectedTokens(int, RuleContext)}
     */
    getExpectedTokens() {
      return this.interpreter.atn.getExpectedTokens(this.state, this.context);
    }
    getExpectedTokensWithinCurrentRule() {
      const atn = this.interpreter.atn;
      const s = atn.states[this.state];
      return atn.nextTokens(s);
    }
    /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
    getRuleIndex(ruleName) {
      return this.getRuleIndexMap().get(ruleName) ?? -1;
    }
    /**
     * @returns an array of string of the rule names in your parser instance
     * leading up to a call to the current rule. You could override if
     * you want more details such as the file/line info of where
     * in the ATN a rule is invoked.
     *
     * this is very useful for error messages.
     */
    getRuleInvocationStack(p) {
      p = p ?? null;
      if (p === null) {
        p = this.context;
      }
      const stack = [];
      while (p !== null) {
        const ruleIndex = p.ruleIndex;
        if (ruleIndex < 0) {
          stack.push("n/a");
        } else {
          stack.push(this.ruleNames[ruleIndex]);
        }
        p = p.parent;
      }
      return stack;
    }
    /**
     * For debugging and other purposes.
     *
     * TODO: this differs from the Java version. Change it.
     */
    getDFAStrings() {
      return this.interpreter.decisionToDFA.toString();
    }
    /** For debugging and other purposes. */
    dumpDFA() {
      let seenOne = false;
      for (const dfa of this.interpreter.decisionToDFA) {
        if (dfa.length > 0) {
          if (seenOne) {
            console.log();
          }
          if (this.printer) {
            this.printer.println("Decision " + dfa.decision + ":");
            this.printer.print(dfa.toString(this.vocabulary));
          }
          seenOne = true;
        }
      }
    }
    getSourceName() {
      return this.inputStream.getSourceName();
    }
    getParseInfo() {
      const interp = this.interpreter;
      if (interp instanceof ProfilingATNSimulator) {
        return new ParseInfo(interp);
      }
      return void 0;
    }
    setProfile(profile) {
      const interp = this.interpreter;
      const saveMode = interp.predictionMode;
      if (profile) {
        if (!(interp instanceof ProfilingATNSimulator)) {
          this.interpreter = new ProfilingATNSimulator(this);
        }
      } else if (interp instanceof ProfilingATNSimulator) {
        const sharedContextCache = interp.sharedContextCache;
        if (sharedContextCache) {
          const sim = new ParserATNSimulator(this, this.atn, interp.decisionToDFA, sharedContextCache);
          this.interpreter = sim;
        }
      }
      this.interpreter.predictionMode = saveMode;
    }
    /**
     * During a parse is sometimes useful to listen in on the rule entry and exit
     * events as well as token matches. this is for quick and dirty debugging.
     */
    setTrace(trace) {
      if (!trace) {
        this.removeParseListener(this.tracer);
        this.tracer = null;
      } else {
        if (this.tracer !== null) {
          this.removeParseListener(this.tracer);
        }
        this.tracer = new TraceListener(this);
        this.addParseListener(this.tracer);
      }
    }
    createTerminalNode(parent, t) {
      return new TerminalNode(t);
    }
    createErrorNode(parent, t) {
      return new ErrorNode(t);
    }
  };
  var ParserInterpreter = class extends Parser {
    static {
      __name(this, "ParserInterpreter");
    }
    rootContext;
    overrideDecisionRoot = null;
    parentContextStack = [];
    overrideDecisionAlt = -1;
    overrideDecisionReached = false;
    decisionToDFA;
    sharedContextCache = new PredictionContextCache();
    pushRecursionContextStates;
    #overrideDecision = -1;
    #overrideDecisionInputIndex = -1;
    #grammarFileName;
    #atn;
    #ruleNames;
    #vocabulary;
    constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
      super(input);
      this.#grammarFileName = grammarFileName;
      this.#atn = atn;
      this.#ruleNames = ruleNames.slice(0);
      this.#vocabulary = vocabulary;
      this.pushRecursionContextStates = new BitSet();
      for (const state of atn.states) {
        if (state instanceof StarLoopEntryState && state.precedenceRuleDecision) {
          this.pushRecursionContextStates.set(state.stateNumber);
        }
      }
      this.decisionToDFA = atn.decisionToState.map((ds, i) => {
        return new DFA(ds, i);
      });
      this.interpreter = new ParserATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);
    }
    reset() {
      super.reset();
      this.overrideDecisionReached = false;
      this.overrideDecisionRoot = null;
    }
    get atn() {
      return this.#atn;
    }
    get vocabulary() {
      return this.#vocabulary;
    }
    get ruleNames() {
      return this.#ruleNames;
    }
    get grammarFileName() {
      return this.#grammarFileName;
    }
    get atnState() {
      return this.#atn.states[this.state];
    }
    parse(startRuleIndex) {
      const startRuleStartState = this.#atn.ruleToStartState[startRuleIndex];
      this.rootContext = this.createInterpreterRuleContext(null, ATNState.INVALID_STATE_NUMBER, startRuleIndex);
      if (startRuleStartState.isLeftRecursiveRule) {
        this.enterRecursionRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
      } else {
        this.enterRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex);
      }
      while (true) {
        const p = this.atnState;
        switch (p.constructor.stateType) {
          case ATNState.RULE_STOP:
            if (this.context?.isEmpty()) {
              if (startRuleStartState.isLeftRecursiveRule) {
                const result = this.context;
                const parentContext = this.parentContextStack.pop();
                this.unrollRecursionContexts(parentContext[0]);
                return result;
              } else {
                this.exitRule();
                return this.rootContext;
              }
            }
            this.visitRuleStopState(p);
            break;
          default:
            try {
              this.visitState(p);
            } catch (e) {
              if (e instanceof RecognitionException) {
                this.state = this.#atn.ruleToStopState[p.ruleIndex].stateNumber;
                this.errorHandler.reportError(this, e);
                this.recover(e);
              } else {
                throw e;
              }
            }
            break;
        }
      }
    }
    addDecisionOverride(decision, tokenIndex, forcedAlt) {
      this.#overrideDecision = decision;
      this.#overrideDecisionInputIndex = tokenIndex;
      this.overrideDecisionAlt = forcedAlt;
    }
    get overrideDecision() {
      return this.#overrideDecision;
    }
    get overrideDecisionInputIndex() {
      return this.#overrideDecisionInputIndex;
    }
    enterRecursionRule(localctx, state, ruleIndex, precedence) {
      this.parentContextStack.push([this.context, localctx.invokingState]);
      super.enterRecursionRule(localctx, state, ruleIndex, precedence);
    }
    visitState(p) {
      let predictedAlt = 1;
      if (p instanceof DecisionState) {
        predictedAlt = this.visitDecisionState(p);
      }
      const transition = p.transitions[predictedAlt - 1];
      switch (transition.transitionType) {
        case Transition.EPSILON:
          if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target.constructor.stateType === ATNState.LOOP_END)) {
            const parentContext = this.parentContextStack[this.parentContextStack.length - 1];
            const localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this.context.ruleIndex);
            this.pushNewRecursionContext(
              localctx,
              this.#atn.ruleToStartState[p.ruleIndex].stateNumber,
              this.context.ruleIndex
            );
          }
          break;
        case Transition.ATOM:
          this.match(transition.label.minElement);
          break;
        case Transition.RANGE:
        case Transition.SET:
        case Transition.NOT_SET:
          if (!transition.matches(this.inputStream.LA(1), Token.MIN_USER_TOKEN_TYPE, 65535)) {
            this.recoverInline();
          }
          this.matchWildcard();
          break;
        case Transition.WILDCARD:
          this.matchWildcard();
          break;
        case Transition.RULE:
          const ruleStartState = transition.target;
          const ruleIndex = ruleStartState.ruleIndex;
          const newContext = this.createInterpreterRuleContext(this.context, p.stateNumber, ruleIndex);
          if (ruleStartState.isLeftRecursiveRule) {
            this.enterRecursionRule(
              newContext,
              ruleStartState.stateNumber,
              ruleIndex,
              transition.precedence
            );
          } else {
            this.enterRule(newContext, transition.target.stateNumber, ruleIndex);
          }
          break;
        case Transition.PREDICATE:
          const predicateTransition = transition;
          if (!this.sempred(this.context, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
            throw new FailedPredicateException(this);
          }
          break;
        case Transition.ACTION:
          const actionTransition = transition;
          this.action(this.context, actionTransition.ruleIndex, actionTransition.actionIndex);
          break;
        case Transition.PRECEDENCE:
          if (!this.precpred(this.context, transition.precedence)) {
            const precedence = transition.precedence;
            throw new FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
          }
          break;
        default:
          throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
      }
      this.state = transition.target.stateNumber;
    }
    visitDecisionState(p) {
      let predictedAlt = 1;
      if (p.transitions.length > 1) {
        this.errorHandler.sync(this);
        const decision = p.decision;
        if (decision === this.#overrideDecision && this.inputStream.index === this.#overrideDecisionInputIndex && !this.overrideDecisionReached) {
          predictedAlt = this.overrideDecisionAlt;
          this.overrideDecisionReached = true;
        } else {
          predictedAlt = this.interpreter.adaptivePredict(this.inputStream, decision, this.context);
        }
      }
      return predictedAlt;
    }
    createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
      return new InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
    }
    visitRuleStopState(p) {
      const ruleStartState = this.#atn.ruleToStartState[p.ruleIndex];
      if (ruleStartState.isLeftRecursiveRule) {
        const [parentContext, state] = this.parentContextStack.pop();
        this.unrollRecursionContexts(parentContext);
        this.state = state;
      } else {
        this.exitRule();
      }
      const ruleTransition = this.#atn.states[this.state].transitions[0];
      this.state = ruleTransition.followState.stateNumber;
    }
    recover(e) {
      const i = this.inputStream.index;
      this.errorHandler.recover(this, e);
      if (this.inputStream.index === i) {
        const tok = e.offendingToken;
        if (!tok) {
          throw new Error("Expected exception to have an offending token");
        }
        const source = tok.tokenSource;
        const stream = source?.inputStream ?? null;
        const sourcePair = [source, stream];
        if (e instanceof InputMismatchException) {
          const expectedTokens = e.getExpectedTokens();
          if (!expectedTokens) {
            throw new Error("Expected the exception to provide expected tokens");
          }
          let expectedTokenType = Token.INVALID_TYPE;
          if (expectedTokens.length !== 0) {
            expectedTokenType = expectedTokens.minElement;
          }
          const errToken = this.getTokenFactory().create(
            sourcePair,
            expectedTokenType,
            tok.text,
            Token.DEFAULT_CHANNEL,
            -1,
            -1,
            tok.line,
            tok.column
          );
          this.context.addErrorNode(this.createErrorNode(this.context, errToken));
        } else {
          const errToken = this.getTokenFactory().create(
            sourcePair,
            Token.INVALID_TYPE,
            tok.text,
            Token.DEFAULT_CHANNEL,
            -1,
            -1,
            tok.line,
            tok.column
          );
          this.context.addErrorNode(this.createErrorNode(this.context, errToken));
        }
      }
    }
    recoverInline() {
      return this.errorHandler.recoverInline(this);
    }
  };
  var MultiMap = class extends Map {
    static {
      __name(this, "MultiMap");
    }
    map(key, value) {
      let elementsForKey = this.get(key);
      if (!elementsForKey) {
        elementsForKey = new Array();
        this.set(key, elementsForKey);
      }
      elementsForKey.push(value);
    }
    getPairs() {
      const pairs = new Array();
      for (const key of this.keys()) {
        const keys = this.get(key) ?? [];
        for (const value of keys) {
          pairs.push([key, value]);
        }
      }
      return pairs;
    }
  };
  var CannotInvokeStartRuleError = class extends Error {
    static {
      __name(this, "CannotInvokeStartRuleError");
    }
    constructor(e) {
      super();
      this.cause = e;
    }
  };
  var RuleTagToken = class {
    static {
      __name(this, "RuleTagToken");
    }
    /** The name of the label associated with the rule tag. */
    label;
    /** The name of the parser rule associated with this rule tag. */
    ruleName;
    /**
     * The token type for the current token. This is the token type assigned to
     * the bypass alternative for the rule during ATN deserialization.
     */
    bypassTokenType;
    constructor(ruleName, bypassTokenType, label) {
      this.ruleName = ruleName;
      this.bypassTokenType = bypassTokenType;
      this.label = label;
    }
    /**
     * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
     */
    get channel() {
      return Token.DEFAULT_CHANNEL;
    }
    /**
     * This method returns the rule tag formatted with `<` and `>`
     * delimiters.
     */
    get text() {
      if (this.label !== null) {
        return "<" + this.label + ":" + this.ruleName + ">";
      }
      return "<" + this.ruleName + ">";
    }
    /**
     * Rule tag tokens have types assigned according to the rule bypass
     * transitions created during ATN deserialization.
     */
    get type() {
      return this.bypassTokenType;
    }
    /**
     * The implementation for {@link RuleTagToken} always returns 0.
     */
    get line() {
      return 0;
    }
    /**
     * The implementation for {@link RuleTagToken} always returns -1.
     */
    get column() {
      return -1;
    }
    /**
     * The implementation for {@link RuleTagToken} always returns -1.
     */
    get tokenIndex() {
      return -1;
    }
    /**
     * The implementation for {@link RuleTagToken} always returns -1.
     */
    get start() {
      return -1;
    }
    /**
     * The implementation for {@link RuleTagToken} always returns -1.
     */
    get stop() {
      return -1;
    }
    /**
     * The implementation for {@link RuleTagToken} always returns `null`.
     */
    get tokenSource() {
      return null;
    }
    /**
     * The implementation for {@link RuleTagToken} always returns `null`.
     */
    get inputStream() {
      return null;
    }
    /**
     * The implementation for {@link RuleTagToken} returns a string of the form
     * `ruleName:bypassTokenType`.
     */
    toString() {
      return this.ruleName + ":" + this.bypassTokenType;
    }
  };
  var StartRuleDoesNotConsumeFullPatternError = class extends Error {
    static {
      __name(this, "StartRuleDoesNotConsumeFullPatternError");
    }
  };
  var TagChunk = class extends Chunk {
    static {
      __name(this, "TagChunk");
    }
    tag;
    label;
    constructor(...args) {
      let label;
      let tag;
      if (args.length === 1) {
        tag = args[0];
      } else {
        label = args[0];
        tag = args[1];
      }
      super();
      if (!tag) {
        throw new Error("tag cannot be null or empty");
      }
      this.label = label;
      this.tag = tag;
    }
    /**
     * @returns a text representation of the tag chunk. Labeled tags
     * are returned in the form `label:tag`, and unlabeled tags are
     * returned as just the tag name.
     */
    toString() {
      if (this.label !== null) {
        return this.label + ":" + this.tag;
      }
      return this.tag;
    }
  };
  var TextChunk = class extends Chunk {
    static {
      __name(this, "TextChunk");
    }
    text;
    /**
     * Constructs a new instance of {@link TextChunk} with the specified text.
     *
     * @param text The text of this chunk.
     */
    constructor(text) {
      super();
      this.text = text;
    }
    /**
     * @returns the result of {@link #getText()} in single quotes.
     */
    toString() {
      return "'" + this.text + "'";
    }
  };
  var TokenTagToken = class extends CommonToken {
    static {
      __name(this, "TokenTagToken");
    }
    tokenName;
    /**
     * The name of the label associated with the rule tag, or undefined if this is an unlabeled rule tag.
     */
    label;
    constructor(tokenName, type, label) {
      super({ type, source: CommonToken.EMPTY_SOURCE });
      this.tokenName = tokenName;
      this.label = label;
    }
    /**
     *
     * @returns the token tag formatted with `<` and `>` delimiters.
     */
    get text() {
      if (this.label !== null) {
        return "<" + this.label + ":" + this.tokenName + ">";
      }
      return "<" + this.tokenName + ">";
    }
    /**
     * @returns a string of the form `tokenName:type`.
     */
    toString() {
      return this.tokenName + ":" + this.type;
    }
  };
  var ParseTreePatternMatcher = class {
    static {
      __name(this, "ParseTreePatternMatcher");
    }
    start = "<";
    stop = ">";
    escape = "\\";
    /**
     * This is the backing field for {@link #getLexer()}.
     */
    lexer;
    /**
     * This is the backing field for {@link #getParser()}.
     */
    parser;
    // e.g., \< and \> must escape BOTH!
    /**
     * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
     * {@link Parser} object. The lexer input stream is altered for tokenizing
     * the tree patterns. The parser is used as a convenient mechanism to get
     * the grammar name, plus token, rule names.
     */
    constructor(lexer, parser) {
      this.lexer = lexer;
      this.parser = parser;
    }
    /**
     * Set the delimiters used for marking rule and token tags within concrete
     * syntax used by the tree pattern parser.
     *
     * @param start The start delimiter.
     * @param stop The stop delimiter.
     * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
     *
     * @throws Error if `start` is `null` or empty.
     * @throws Error if `stop` is `null` or empty.
     */
    setDelimiters(start, stop, escapeLeft) {
      if (start === null || start.length === 0) {
        throw new Error("start cannot be null or empty");
      }
      if (stop === null || stop.length === 0) {
        throw new Error("stop cannot be null or empty");
      }
      this.start = start;
      this.stop = stop;
      this.escape = escapeLeft;
    }
    matches(...args) {
      switch (args.length) {
        case 2: {
          const [tree, pattern] = args;
          const labels = new MultiMap();
          const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);
          return mismatchedNode === null;
        }
        case 3: {
          const [tree, pattern, patternRuleIndex] = args;
          const p = this.compile(pattern, patternRuleIndex);
          return this.matches(tree, p);
        }
        default: {
          throw new Error("Invalid number of arguments");
        }
      }
    }
    match(...args) {
      switch (args.length) {
        case 2: {
          const [tree, pattern] = args;
          const labels = new MultiMap();
          const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);
          return new ParseTreeMatch(tree, pattern, labels, mismatchedNode);
        }
        case 3: {
          const [tree, pattern, patternRuleIndex] = args;
          const p = this.compile(pattern, patternRuleIndex);
          return this.match(tree, p);
        }
        default: {
          throw new Error("Invalid number of arguments");
        }
      }
    }
    /**
     * For repeated use of a tree pattern, compile it to a
     * {@link ParseTreePattern} using this method.
     */
    compile(pattern, patternRuleIndex) {
      const tokenList = this.tokenize(pattern);
      const tokenSrc = new ListTokenSource(tokenList);
      const tokens = new CommonTokenStream(tokenSrc);
      const parserInterp = new ParserInterpreter(
        this.parser.grammarFileName,
        this.parser.vocabulary,
        this.parser.ruleNames,
        this.parser.getATNWithBypassAlts(),
        tokens
      );
      let tree = null;
      try {
        parserInterp.errorHandler = new BailErrorStrategy();
        tree = parserInterp.parse(patternRuleIndex);
      } catch (eOrRe) {
        if (eOrRe instanceof ParseCancellationException) {
          const e = eOrRe;
          throw e.cause;
        } else if (eOrRe instanceof RecognitionException) {
          throw eOrRe;
        } else if (eOrRe instanceof Error) {
          throw new CannotInvokeStartRuleError(eOrRe);
        } else {
          throw eOrRe;
        }
      }
      if (tokens.LA(1) !== Token.EOF) {
        throw new StartRuleDoesNotConsumeFullPatternError();
      }
      return new ParseTreePattern(this, pattern, patternRuleIndex, tree);
    }
    /**
     * Used to convert the tree pattern string into a series of tokens. The
     * input stream is reset.
     */
    getLexer() {
      return this.lexer;
    }
    /**
     * Used to collect to the grammar file name, token names, rule names for
     * used to parse the pattern into a parse tree.
     */
    getParser() {
      return this.parser;
    }
    // ---- SUPPORT CODE ----
    tokenize(pattern) {
      const chunks = this.split(pattern);
      const tokens = new Array();
      for (const chunk of chunks) {
        if (chunk instanceof TagChunk) {
          const tagChunk = chunk;
          const char = tagChunk.tag[0];
          if (char === char.toUpperCase()) {
            const ttype = this.parser.getTokenType(tagChunk.tag);
            if (ttype === Token.INVALID_TYPE) {
              throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
            }
            const t = new TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
            tokens.push(t);
          } else {
            if (char === char.toLowerCase()) {
              const ruleIndex = this.parser.getRuleIndex(tagChunk.tag);
              if (ruleIndex === -1) {
                throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
              }
              const ruleImaginaryTokenType = this.parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
              tokens.push(new RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
            } else {
              throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
            }
          }
        } else {
          const textChunk = chunk;
          const input = CharStream.fromString(textChunk.text);
          this.lexer.inputStream = input;
          let t = this.lexer.nextToken();
          while (t.type !== Token.EOF) {
            tokens.push(t);
            t = this.lexer.nextToken();
          }
        }
      }
      return tokens;
    }
    /**
     * Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}.
     */
    split(pattern) {
      let p = 0;
      const n2 = pattern.length;
      const chunks = new Array();
      const starts = new Array();
      const stops = new Array();
      while (p < n2) {
        if (p === pattern.indexOf(this.escape + this.start, p)) {
          p += this.escape.length + this.start.length;
        } else {
          if (p === pattern.indexOf(this.escape + this.stop, p)) {
            p += this.escape.length + this.stop.length;
          } else {
            if (p === pattern.indexOf(this.start, p)) {
              starts.push(p);
              p += this.start.length;
            } else {
              if (p === pattern.indexOf(this.stop, p)) {
                stops.push(p);
                p += this.stop.length;
              } else {
                p++;
              }
            }
          }
        }
      }
      if (starts.length > stops.length) {
        throw new Error("unterminated tag in pattern: " + pattern);
      }
      if (starts.length < stops.length) {
        throw new Error("missing start tag in pattern: " + pattern);
      }
      const tagCount = starts.length;
      for (let i = 0; i < tagCount; i++) {
        if (starts[i] >= stops[i]) {
          throw new Error("tag delimiters out of order in pattern: " + pattern);
        }
      }
      if (tagCount === 0) {
        const text = pattern.substring(0, n2);
        chunks.push(new TextChunk(text));
      }
      if (tagCount > 0 && starts[0] > 0) {
        const text = pattern.substring(0, starts[0]);
        chunks.push(new TextChunk(text));
      }
      for (let i = 0; i < tagCount; i++) {
        const tag = pattern.substring(starts[i] + this.start.length, stops[i]);
        let ruleOrToken = tag;
        let label;
        const colon = tag.indexOf(":");
        if (colon >= 0) {
          label = tag.substring(0, colon);
          ruleOrToken = tag.substring(colon + 1, tag.length);
        }
        chunks.push(new TagChunk(label, ruleOrToken));
        if (i + 1 < tagCount) {
          const text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
          chunks.push(new TextChunk(text));
        }
      }
      if (tagCount > 0) {
        const afterLastTag = stops[tagCount - 1] + this.stop.length;
        if (afterLastTag < n2) {
          const text = pattern.substring(afterLastTag, n2);
          chunks.push(new TextChunk(text));
        }
      }
      for (let i = 0; i < chunks.length; i++) {
        const c = chunks[i];
        if (c instanceof TextChunk) {
          const tc = c;
          const unescaped = tc.text.replace(this.escape, "");
          if (unescaped.length < tc.text.length) {
            chunks[i] = new TextChunk(unescaped);
          }
        }
      }
      return chunks;
    }
    /**
     * Recursively walk `tree` against `patternTree`, filling
     * `match.`{@link ParseTreeMatch#labels labels}.
     *
     * @returns the first node encountered in `tree` which does not match
     * a corresponding node in `patternTree`, or `null` if the match
     * was successful. The specific node returned depends on the matching
     * algorithm used by the implementation, and may be overridden.
     */
    matchImpl(tree, patternTree, labels) {
      if (tree instanceof TerminalNode && patternTree instanceof TerminalNode) {
        const t1 = tree;
        const t2 = patternTree;
        let mismatchedNode;
        if (t1.getSymbol().type === t2.getSymbol().type) {
          if (t2.getSymbol() instanceof TokenTagToken) {
            const tokenTagToken = t2.getSymbol();
            labels.map(tokenTagToken.tokenName, tree);
            if (tokenTagToken.label !== void 0) {
              labels.map(tokenTagToken.label, tree);
            }
          } else {
            if (t1.getText() === t2.getText()) {
            } else {
              if (!mismatchedNode) {
                mismatchedNode = t1;
              }
            }
          }
        } else {
          if (!mismatchedNode) {
            mismatchedNode = t1;
          }
        }
        return mismatchedNode;
      }
      if (tree instanceof ParserRuleContext && patternTree instanceof ParserRuleContext) {
        let mismatchedNode;
        const ruleTagToken = this.getRuleTagToken(patternTree);
        if (ruleTagToken) {
          if (tree.ruleIndex === patternTree.ruleIndex) {
            labels.map(ruleTagToken.ruleName, tree);
            if (ruleTagToken.label) {
              labels.map(ruleTagToken.label, tree);
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
          return mismatchedNode;
        }
        if (tree.getChildCount() !== patternTree.getChildCount()) {
          if (!mismatchedNode) {
            mismatchedNode = tree;
          }
          return mismatchedNode;
        }
        const n2 = tree.getChildCount();
        for (let i = 0; i < n2; i++) {
          const childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
          if (childMatch) {
            return childMatch;
          }
        }
        return mismatchedNode;
      }
      return tree;
    }
    /**
     * Is `t` `(expr <expr>)` subtree?
     */
    getRuleTagToken(t) {
      if (t instanceof ParserRuleContext) {
        if (t.getChildCount() === 1 && t.getChild(0) instanceof TerminalNode) {
          const c = t.getChild(0);
          if (c.getSymbol() instanceof RuleTagToken) {
            return c.getSymbol();
          }
        }
      }
      return void 0;
    }
  };
  var DiagnosticErrorListener = class extends BaseErrorListener {
    static {
      __name(this, "DiagnosticErrorListener");
    }
    /**
     * When `true`, only exactly known ambiguities are reported.
     */
    exactOnly;
    constructor(exactOnly) {
      super();
      this.exactOnly = exactOnly ?? true;
    }
    reportAmbiguity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) => {
      if (this.exactOnly && !exact) {
        return;
      }
      const decision = this.getDecisionDescription(recognizer, dfa);
      const conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
      const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
      const message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;
      recognizer.notifyErrorListeners(message, null, null);
    }, "reportAmbiguity");
    reportAttemptingFullContext = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _conflictingAlts, _configs) => {
      const decision = this.getDecisionDescription(recognizer, dfa);
      const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
      const message = `reportAttemptingFullContext d=${decision}, input='${text}'`;
      recognizer.notifyErrorListeners(message, null, null);
    }, "reportAttemptingFullContext");
    reportContextSensitivity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _prediction, _configs) => {
      const decision = this.getDecisionDescription(recognizer, dfa);
      const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
      const message = `reportContextSensitivity d=${decision}, input='${text}'`;
      recognizer.notifyErrorListeners(message, null, null);
    }, "reportContextSensitivity");
    getDecisionDescription = /* @__PURE__ */ __name((recognizer, dfa) => {
      const decision = dfa.decision;
      const ruleIndex = dfa.atnStartState.ruleIndex;
      const ruleNames = recognizer.ruleNames;
      if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
        return decision.toString();
      }
      const ruleName = ruleNames[ruleIndex];
      if (ruleName.length === 0) {
        return decision.toString();
      }
      return `${decision} (${ruleName})`;
    }, "getDecisionDescription");
    /**
     * Computes the set of conflicting or ambiguous alternatives from a
     * configuration set, if that information was not already provided by the
     * parser.
     *
     * @param reportedAlts The set of conflicting or ambiguous alternatives, as
     * reported by the parser.
     * @param configs The conflicting or ambiguous configuration set.
     * @returns Returns `reportedAlts` if it is not `null`, otherwise
     * returns the set of alternatives represented in `configs`.
     */
    getConflictingAlts = /* @__PURE__ */ __name((reportedAlts, configs) => {
      if (reportedAlts) {
        return reportedAlts;
      }
      const result = new BitSet();
      for (let i = 0; i < configs.configs.length; i++) {
        result.set(configs.configs[i].alt);
      }
      return result;
    }, "getConflictingAlts");
  };
  var LexerInterpreter = class extends Lexer {
    static {
      __name(this, "LexerInterpreter");
    }
    decisionToDFA;
    sharedContextCache = new PredictionContextCache();
    #grammarFileName;
    #atn;
    #ruleNames;
    #channelNames;
    #modeNames;
    #vocabulary;
    constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
      super(input);
      if (atn.grammarType !== ATN.LEXER) {
        throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
      }
      this.#grammarFileName = grammarFileName;
      this.#atn = atn;
      this.#ruleNames = ruleNames.slice(0);
      this.#channelNames = channelNames.slice(0);
      this.#modeNames = modeNames.slice(0);
      this.#vocabulary = vocabulary;
      this.decisionToDFA = atn.decisionToState.map((ds, i) => {
        return new DFA(ds, i);
      });
      this.interpreter = new LexerATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);
    }
    get atn() {
      return this.#atn;
    }
    get grammarFileName() {
      return this.#grammarFileName;
    }
    get ruleNames() {
      return this.#ruleNames;
    }
    get channelNames() {
      return this.#channelNames;
    }
    get modeNames() {
      return this.#modeNames;
    }
    get vocabulary() {
      return this.#vocabulary;
    }
  };
  var RuntimeMetaData = class _RuntimeMetaData {
    static {
      __name(this, "RuntimeMetaData");
    }
    /**
     * A compile-time constant containing the current version of the ANTLR 4
     * runtime library.
     *
     * This compile-time constant value allows generated parsers and other
     * libraries to include a literal reference to the version of the ANTLR 4
     * runtime library the code was compiled against. At each release, we
     * change this value.
     *
     * Version numbers are assumed to have the form
     *
     * major.minor.patch.revision-suffix,
     *
     * with the individual components defined as follows.
     *
     * - major is a required non-negative integer, and is equal to `4` for ANTLR 4.
     * - minor is a required non-negative integer.
     * - patch is an optional non-negative integer. When patch is omitted, the `.` (dot) appearing before it is
     *   also omitted.
     * - revision is an optional non-negative integer, and may only be included when patch is also included.
     *   When revision is omitted, the `.` (dot) appearing before it is also omitted.
     * - suffix is an optional string. When suffix is omitted, the `-` (hyphen-minus) appearing before it is also
     *   omitted.
     */
    static VERSION = "4.13.1";
    /**
     * Gets the currently executing version of the ANTLR 4 runtime library.
     *
     * This method provides runtime access to the {@link VERSION} field, as
     * opposed to directly referencing the field as a compile-time constant.
     *
     * @returns The currently executing version of the ANTLR 4 library
     */
    static getRuntimeVersion() {
      return _RuntimeMetaData.VERSION;
    }
    /**
     * This method provides the ability to detect mismatches between the version
     * of ANTLR 4 used to generate a parser, the version of the ANTLR runtime a
     * parser was compiled against, and the version of the ANTLR runtime which
     * is currently executing.
     *
     * The version check is designed to detect the following two specific
     * scenarios.
     *
     * - The ANTLR Tool version used for code generation does not match the
     * currently executing runtime version.
     * - The ANTLR Runtime version referenced at the time a parser was
     * compiled does not match the currently executing runtime version.
     *
     *
     * Starting with ANTLR 4.3, the code generator emits a call to this method
     * using two constants in each generated lexer and parser: a hard-coded
     * constant indicating the version of the tool used to generate the parser
     * and a reference to the compile-time constant {@link VERSION}. At
     * runtime, this method is called during the initialization of the generated
     * parser to detect mismatched versions, and notify the registered listeners
     * prior to creating instances of the parser.
     *
     *
     * This method does not perform any detection or filtering of semantic
     * changes between tool and runtime versions. It simply checks for a
     * version match and emits an error to stderr if a difference
     * is detected.
     *
     *
     * Note that some breaking changes between releases could result in other
     * types of runtime exceptions, such as a {@link LinkageError}, prior to
     * calling this method. In these cases, the underlying version mismatch will
     * not be reported here. This method is primarily intended to
     * notify users of potential semantic changes between releases that do not
     * result in binary compatibility problems which would be detected by the
     * class loader. As with semantic changes, changes that break binary
     * compatibility between releases are mentioned in the release notes
     * accompanying the affected release.
     *
     *
     * **Additional note for target developers:** The version check
     * implemented by this class is designed to address specific compatibility
     * concerns that may arise during the execution of Java applications. Other
     * targets should consider the implementation of this method in the context
     * of that target's known execution environment, which may or may not
     * resemble the design provided for the Java target.
     *
     * @param generatingToolVersion The version of the tool used to generate a parser.
     * This value may be null when called from user code that was not generated
     * by, and does not reference, the ANTLR 4 Tool itself.
     * @param compileTimeVersion The version of the runtime the parser was
     * compiled against. This should always be passed using a direct reference
     * to {@link VERSION}.
     */
    static checkVersion(generatingToolVersion, compileTimeVersion) {
      const runtimeVersion = _RuntimeMetaData.VERSION;
      let runtimeConflictsWithGeneratingTool = false;
      let runtimeConflictsWithCompileTimeTool = false;
      runtimeConflictsWithGeneratingTool = runtimeVersion !== generatingToolVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(generatingToolVersion);
      runtimeConflictsWithCompileTimeTool = runtimeVersion !== compileTimeVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(compileTimeVersion);
      if (runtimeConflictsWithGeneratingTool) {
        console.error(`ANTLR Tool version ${generatingToolVersion} used for code generation does not match the current runtime version ${runtimeVersion}`);
      }
      if (runtimeConflictsWithCompileTimeTool) {
        console.error(`ANTLR Runtime version ${compileTimeVersion} used for parser compilation does not match the current runtime version ${runtimeVersion}`);
      }
    }
    /**
     * Gets the major and minor version numbers from a version string. For
     * details about the syntax of the input `version`.
     * E.g., from x.y.z return x.y.
     *
     * @param version The complete version string.
     * @returns A string of the form *major*.*minor* containing
     * only the major and minor components of the version string.
     */
    static getMajorMinorVersion(version) {
      const firstDot = version.indexOf(".");
      const secondDot = firstDot >= 0 ? version.indexOf(".", firstDot + 1) : -1;
      const firstDash = version.indexOf("-");
      let referenceLength = version.length;
      if (secondDot >= 0) {
        referenceLength = Math.min(referenceLength, secondDot);
      }
      if (firstDash >= 0) {
        referenceLength = Math.min(referenceLength, firstDash);
      }
      return version.substring(0, referenceLength);
    }
  };
  var TokenStreamRewriter = class _TokenStreamRewriter {
    static {
      __name(this, "TokenStreamRewriter");
    }
    static DEFAULT_PROGRAM_NAME = "default";
    static PROGRAM_INIT_SIZE = 100;
    static MIN_TOKEN_INDEX = 0;
    /** Our source stream */
    tokens;
    /**
     * You may have multiple, named streams of rewrite operations.
     *  I'm calling these things "programs."
     *  Maps String (name) -> rewrite (List)
     */
    programs = /* @__PURE__ */ new Map();
    /** Map String (program name) -> Integer index */
    lastRewriteTokenIndexes;
    /**
     * @param tokens The token stream to modify
     */
    constructor(tokens) {
      this.tokens = tokens;
    }
    getTokenStream() {
      return this.tokens;
    }
    /**
     * Insert the supplied text after the specified token (or token index)
     */
    insertAfter(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let index;
      if (typeof tokenOrIndex === "number") {
        index = tokenOrIndex;
      } else {
        index = tokenOrIndex.tokenIndex;
      }
      const rewrites = this.getProgram(programName);
      const op = new InsertAfterOp(this.tokens, index, rewrites.length, text);
      rewrites.push(op);
    }
    /**
     * Insert the supplied text before the specified token (or token index)
     */
    insertBefore(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let index;
      if (typeof tokenOrIndex === "number") {
        index = tokenOrIndex;
      } else {
        index = tokenOrIndex.tokenIndex;
      }
      const rewrites = this.getProgram(programName);
      const op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);
      rewrites.push(op);
    }
    /**
     * Replace the specified token with the supplied text
     */
    replaceSingle(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      this.replace(tokenOrIndex, tokenOrIndex, text, programName);
    }
    /**
     * Replace the specified range of tokens with the supplied text.
     */
    replace(from, to, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      if (typeof from !== "number") {
        from = from.tokenIndex;
      }
      if (typeof to !== "number") {
        to = to.tokenIndex;
      }
      if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
        throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
      }
      const rewrites = this.getProgram(programName);
      const op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);
      rewrites.push(op);
    }
    /**
     * Delete the specified range of tokens
     */
    delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      if (to == null) {
        to = from;
      }
      this.replace(from, to, null, programName);
    }
    getProgram(name) {
      let is = this.programs.get(name);
      if (is == null) {
        is = this.initializeProgram(name);
      }
      return is;
    }
    initializeProgram(name) {
      const is = [];
      this.programs.set(name, is);
      return is;
    }
    /**
     * @returns the text from the original tokens altered per the instructions given to this rewriter
     */
    getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let interval;
      if (intervalOrProgram instanceof Interval) {
        interval = intervalOrProgram;
      } else {
        interval = new Interval(0, this.tokens.size - 1);
      }
      if (typeof intervalOrProgram === "string") {
        programName = intervalOrProgram;
      }
      const rewrites = this.programs.get(programName);
      let start = interval.start;
      let stop = interval.stop;
      if (stop > this.tokens.size - 1) {
        stop = this.tokens.size - 1;
      }
      if (start < 0) {
        start = 0;
      }
      if (rewrites == null || rewrites.length === 0) {
        return this.tokens.getTextFromInterval(new Interval(start, stop));
      }
      const buf = [];
      const indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
      let i = start;
      while (i <= stop && i < this.tokens.size) {
        const op = indexToOp.get(i);
        indexToOp.delete(i);
        const t = this.tokens.get(i);
        if (op == null) {
          if (t.type !== Token.EOF) {
            buf.push(String(t.text));
          }
          i++;
        } else {
          i = op.execute(buf);
        }
      }
      if (stop === this.tokens.size - 1) {
        for (const op of indexToOp.values()) {
          if (op && op.index >= this.tokens.size - 1) {
            buf.push(String(op.text));
          }
        }
      }
      return buf.join("");
    }
    /**
     * @returns a map from token index to operation
     */
    reduceToSingleOperationPerIndex(rewrites) {
      for (let i = 0; i < rewrites.length; i++) {
        const op = rewrites[i];
        if (op == null) {
          continue;
        }
        if (!(op instanceof ReplaceOp)) {
          continue;
        }
        const rop = op;
        const inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
        for (const iop of inserts) {
          if (iop.index === rop.index) {
            rewrites[iop.instructionIndex] = null;
            rop.text = String(iop.text) + (rop.text != null ? rop.text.toString() : "");
          } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
            rewrites[iop.instructionIndex] = null;
          }
        }
        const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
        for (const prevRop of prevReplaces) {
          if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
            rewrites[prevRop.instructionIndex] = null;
            continue;
          }
          const disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
          if (prevRop.text == null && rop.text == null && !disjoint) {
            rewrites[prevRop.instructionIndex] = null;
            rop.index = Math.min(prevRop.index, rop.index);
            rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
          } else if (!disjoint) {
            throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
          }
        }
      }
      for (let i = 0; i < rewrites.length; i++) {
        const op = rewrites[i];
        if (op == null) {
          continue;
        }
        if (!(op instanceof InsertBeforeOp)) {
          continue;
        }
        const iop = op;
        const prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
        for (const prevIop of prevInserts) {
          if (prevIop.index === iop.index) {
            if (prevIop instanceof InsertAfterOp) {
              iop.text = this.catOpText(prevIop.text, iop.text);
              rewrites[prevIop.instructionIndex] = null;
            } else if (prevIop instanceof InsertBeforeOp) {
              iop.text = this.catOpText(iop.text, prevIop.text);
              rewrites[prevIop.instructionIndex] = null;
            }
          }
        }
        const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
        for (const rop of prevReplaces) {
          if (iop.index === rop.index) {
            rop.text = this.catOpText(iop.text, rop.text);
            rewrites[i] = null;
            continue;
          }
          if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
            throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
          }
        }
      }
      const m2 = /* @__PURE__ */ new Map();
      for (const op of rewrites) {
        if (op == null) {
          continue;
        }
        if (m2.get(op.index) != null) {
          throw new Error("should only be one op per index");
        }
        m2.set(op.index, op);
      }
      return m2;
    }
    catOpText(a, b) {
      let x = "";
      let y = "";
      if (a != null) {
        x = a.toString();
      }
      if (b != null) {
        y = b.toString();
      }
      return x + y;
    }
    /**
     * Get all operations before an index of a particular kind
     */
    getKindOfOps(rewrites, kind, before) {
      return rewrites.slice(0, before).filter((op) => {
        return op && op instanceof kind;
      });
    }
  };
  var RewriteOperation = class {
    static {
      __name(this, "RewriteOperation");
    }
    /** What index into rewrites List are we? */
    instructionIndex;
    /** Token buffer index. */
    index;
    text;
    tokens;
    constructor(tokens, index, instructionIndex, text) {
      this.tokens = tokens;
      this.instructionIndex = instructionIndex;
      this.index = index;
      this.text = text === void 0 ? "" : text;
    }
    execute(_buf) {
      return this.index;
    }
    toString() {
      return "<RewriteOperation@" + this.tokens.get(this.index) + ':"' + this.text + '">';
    }
  };
  var InsertBeforeOp = class extends RewriteOperation {
    static {
      __name(this, "InsertBeforeOp");
    }
    constructor(tokens, index, instructionIndex, text) {
      super(tokens, index, instructionIndex, text);
    }
    /**
     * @returns the index of the next token to operate on
     */
    execute(buf) {
      if (this.text) {
        buf.push(this.text.toString());
      }
      if (this.tokens.get(this.index).type !== Token.EOF) {
        buf.push(String(this.tokens.get(this.index).text));
      }
      return this.index + 1;
    }
    toString() {
      return "<InsertBeforeOp@" + this.tokens.get(this.index) + ':"' + this.text + '">';
    }
  };
  var InsertAfterOp = class extends InsertBeforeOp {
    static {
      __name(this, "InsertAfterOp");
    }
    constructor(tokens, index, instructionIndex, text) {
      super(tokens, index + 1, instructionIndex, text);
    }
    toString() {
      return "<InsertAfterOp@" + this.tokens.get(this.index) + ':"' + this.text + '">';
    }
  };
  var ReplaceOp = class extends RewriteOperation {
    static {
      __name(this, "ReplaceOp");
    }
    lastIndex;
    constructor(tokens, from, to, instructionIndex, text) {
      super(tokens, from, instructionIndex, text);
      this.lastIndex = to;
    }
    /**
     * @returns the index of the next token to operate on
     */
    execute(buf) {
      if (this.text) {
        buf.push(this.text.toString());
      }
      return this.lastIndex + 1;
    }
    toString() {
      if (this.text == null) {
        return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
      }
      return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
    }
  };
  var isWritableToken = /* @__PURE__ */ __name((candidate) => {
    return candidate.setText !== void 0;
  }, "isWritableToken");
  var UnbufferedTokenStream = class {
    static {
      __name(this, "UnbufferedTokenStream");
    }
    tokenSource;
    /**
     * A moving window buffer of the data being scanned. While there's a marker,
     * we keep adding to buffer. Otherwise, {@link #consume consume()} resets so
     * we start filling at index 0 again.
     */
    tokens;
    /**
     * The number of tokens currently in {@link #tokens tokens}.
     *
     * This is not the buffer capacity, that's `tokens.length`.
     */
    n;
    /**
     * 0..n-1 index into {@link #tokens tokens} of next token.
     *
     * The `LT(1)` token is `tokens[p]`. If `p == n`, we are
     * out of buffered tokens.
     */
    p = 0;
    /**
     * Count up with {@link #mark mark()} and down with
     * {@link #release release()}. When we `release()` the last mark,
     * `numMarkers` reaches 0 and we reset the buffer. Copy
     * `tokens[p]..tokens[n-1]` to `tokens[0]..tokens[(n-1)-p]`.
     */
    numMarkers = 0;
    /**
     * This is the `LT(-1)` token for the current position.
     */
    lastToken;
    /**
     * When `numMarkers > 0`, this is the `LT(-1)` token for the
     * first token in {@link #tokens}. Otherwise, this is `null`.
     */
    lastTokenBufferStart;
    /**
     * Absolute token index. It's the index of the token about to be read via
     * `LT(1)`. Goes from 0 to the number of tokens in the entire stream,
     * although the stream size is unknown before the end is reached.
     *
     * This value is used to set the token indexes if the stream provides tokens
     * that implement {@link WritableToken}.
     */
    currentTokenIndex = 0;
    constructor(tokenSource, bufferSize) {
      this.tokenSource = tokenSource;
      bufferSize = bufferSize ?? 256;
      this.tokens = new Array(bufferSize);
      this.n = 0;
      this.fill(1);
    }
    get(i) {
      const bufferStartIndex = this.getBufferStartIndex();
      if (i < bufferStartIndex || i >= bufferStartIndex + this.n) {
        throw new Error("get(" + i + ") outside buffer: " + bufferStartIndex + ".." + (bufferStartIndex + this.n));
      }
      return this.tokens[i - bufferStartIndex];
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    LT(i) {
      if (i === -1) {
        return this.lastToken;
      }
      this.sync(i);
      const index = this.p + i - 1;
      if (index < 0) {
        throw new Error("LT(" + i + ") gives negative index");
      }
      if (index >= this.n) {
        return this.tokens[this.n - 1];
      }
      return this.tokens[index];
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    LA(i) {
      return this.LT(i).type;
    }
    getText() {
      return "";
    }
    getTextFromContext(ctx) {
      return this.getTextFromInterval(ctx.getSourceInterval());
    }
    getTextFromInterval(interval) {
      const bufferStartIndex = this.getBufferStartIndex();
      const bufferStopIndex = bufferStartIndex + this.tokens.length - 1;
      const start = interval.start;
      const stop = interval.stop;
      if (start < bufferStartIndex || stop > bufferStopIndex) {
        throw new Error("interval " + interval + " not in token buffer window: " + bufferStartIndex + ".." + bufferStopIndex);
      }
      const a = start - bufferStartIndex;
      const b = stop - bufferStartIndex;
      let result = "";
      for (let i = a; i <= b; i++) {
        const t = this.tokens[i];
        result += t.text;
      }
      return result;
    }
    getTextFromRange(start, stop) {
      return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));
    }
    consume() {
      if (this.LA(1) === Token.EOF) {
        throw new Error("cannot consume EOF");
      }
      this.lastToken = this.tokens[this.p];
      if (this.p === this.n - 1 && this.numMarkers === 0) {
        this.n = 0;
        this.p = -1;
        this.lastTokenBufferStart = this.lastToken;
      }
      this.p++;
      this.currentTokenIndex++;
      this.sync(1);
    }
    /**
     * Return a marker that we can release later.
     *
     * The specific marker value used for this class allows for some level of
     * protection against misuse where `seek()` is called on a mark or
     * `release()` is called in the wrong order.
     */
    mark() {
      if (this.numMarkers === 0) {
        this.lastTokenBufferStart = this.lastToken;
      }
      const mark = -this.numMarkers - 1;
      this.numMarkers++;
      return mark;
    }
    release(marker) {
      const expectedMark = -this.numMarkers;
      if (marker !== expectedMark) {
        throw new Error("release() called with an invalid marker.");
      }
      this.numMarkers--;
      if (this.numMarkers === 0) {
        if (this.p > 0) {
          this.tokens.copyWithin(0, this.p, this.n);
          this.n = this.n - this.p;
          this.p = 0;
        }
        this.lastTokenBufferStart = this.lastToken;
      }
    }
    get index() {
      return this.currentTokenIndex;
    }
    seek(index) {
      if (index === this.currentTokenIndex) {
        return;
      }
      if (index > this.currentTokenIndex) {
        this.sync(index - this.currentTokenIndex);
        index = Math.min(index, this.getBufferStartIndex() + this.n - 1);
      }
      const bufferStartIndex = this.getBufferStartIndex();
      const i = index - bufferStartIndex;
      if (i < 0) {
        throw new Error("cannot seek to negative index " + index);
      } else {
        if (i >= this.n) {
          throw new Error("seek to index outside buffer: " + index + " not in " + bufferStartIndex + ".." + (bufferStartIndex + this.n));
        }
      }
      this.p = i;
      this.currentTokenIndex = index;
      if (this.p === 0) {
        this.lastToken = this.lastTokenBufferStart;
      } else {
        this.lastToken = this.tokens[this.p - 1];
      }
    }
    get size() {
      throw new Error("Unbuffered stream cannot know its size");
    }
    getSourceName() {
      return this.tokenSource.sourceName;
    }
    setLine(line) {
      this.tokenSource.line = line;
    }
    setColumn(column) {
      this.tokenSource.column = column;
    }
    /**
     * Make sure we have 'need' elements from current position {@link #p p}. Last valid
     * `p` index is `tokens.length-1`.  `p+need-1` is the tokens index 'need' elements
     * ahead.  If we need 1 element, `(p+1-1)==p` must be less than `tokens.length`.
     */
    sync(want) {
      const need = this.p + want - 1 - this.n + 1;
      if (need > 0) {
        this.fill(need);
      }
    }
    /**
     * Add `n` elements to the buffer. Returns the number of tokens
     * actually added to the buffer. If the return value is less than `n`,
     * then EOF was reached before `n` tokens could be added.
     */
    fill(n2) {
      for (let i = 0; i < n2; i++) {
        if (this.n > 0 && this.tokens[this.n - 1].type === Token.EOF) {
          return i;
        }
        const t = this.tokenSource.nextToken();
        this.add(t);
      }
      return n2;
    }
    add(t) {
      if (this.n >= this.tokens.length) {
        this.tokens.length = this.tokens.length * 2;
      }
      if (isWritableToken(t)) {
        t.setTokenIndex(this.getBufferStartIndex() + this.n);
      }
      this.tokens[this.n++] = t;
    }
    getBufferStartIndex() {
      return this.currentTokenIndex - this.p;
    }
  };

  // build/QBasicLexer.ts
  var QBasicLexer = class _QBasicLexer extends Lexer {
    static COLON = 1;
    static LEFT_PAREN = 2;
    static RIGHT_PAREN = 3;
    static NUMBER = 4;
    static DIVIDE = 5;
    static INTEGER_DIVIDE = 6;
    static EXP = 7;
    static MINUS = 8;
    static PLUS = 9;
    static TIMES = 10;
    static COMMA = 11;
    static SEMICOLON = 12;
    static LT = 13;
    static LE = 14;
    static NE = 15;
    static EQ = 16;
    static GT = 17;
    static GE = 18;
    static AMP = 19;
    static PERCENT = 20;
    static DOT = 21;
    static DIGITS = 22;
    static HEX = 23;
    static OCTAL = 24;
    static PROBABLY_SINGLE_PRECISION_NUMBER = 25;
    static DOUBLE_PRECISION_NUMBER = 26;
    static STRING_LITERAL = 27;
    static ABSOLUTE = 28;
    static ACCESS = 29;
    static AND = 30;
    static ANY = 31;
    static APPEND = 32;
    static AS = 33;
    static BASE = 34;
    static BINARY = 35;
    static CALL = 36;
    static CASE = 37;
    static CIRCLE = 38;
    static CLEAR = 39;
    static CLOSE = 40;
    static COLOR = 41;
    static COM = 42;
    static COMMON = 43;
    static CONST = 44;
    static DATA = 45;
    static DECLARE = 46;
    static DEF = 47;
    static DEFDBL = 48;
    static DEFINT = 49;
    static DEFLNG = 50;
    static DEFSNG = 51;
    static DEFSTR = 52;
    static DIM = 53;
    static DO = 54;
    static DOUBLE = 55;
    static ELSE = 56;
    static ELSEIF = 57;
    static EQV = 58;
    static ERROR = 59;
    static END = 60;
    static EXIT = 61;
    static FIELD = 62;
    static FOR = 63;
    static FN = 64;
    static FUNCTION = 65;
    static GET = 66;
    static GOSUB = 67;
    static GOTO = 68;
    static IF = 69;
    static IMP = 70;
    static INPUT = 71;
    static INPUT_STRING = 72;
    static IOCTL = 73;
    static IOCTL_STRING = 74;
    static IS = 75;
    static INTEGER = 76;
    static KEY = 77;
    static LEN = 78;
    static LET = 79;
    static LINE = 80;
    static LIST = 81;
    static LOCATE = 82;
    static LOCK = 83;
    static LONG = 84;
    static LOOP = 85;
    static LPRINT = 86;
    static LSET = 87;
    static MID_STRING = 88;
    static MOD = 89;
    static NAME = 90;
    static NEXT = 91;
    static NOT = 92;
    static OPTION = 93;
    static OFF = 94;
    static OPEN = 95;
    static OUTPUT = 96;
    static OR = 97;
    static ON = 98;
    static PAINT = 99;
    static PALETTE = 100;
    static PEN = 101;
    static PLAY = 102;
    static PRINT = 103;
    static PRESET = 104;
    static PSET = 105;
    static PUT = 106;
    static RANDOM = 107;
    static READ = 108;
    static REDIM = 109;
    static REM = 110;
    static RESUME = 111;
    static RETURN = 112;
    static RSET = 113;
    static SCREEN = 114;
    static SEEK = 115;
    static SEG = 116;
    static SELECT = 117;
    static SHARED = 118;
    static SINGLE = 119;
    static STATIC = 120;
    static STEP = 121;
    static STOP = 122;
    static STRIG = 123;
    static STRING = 124;
    static SUB = 125;
    static THEN = 126;
    static TO = 127;
    static TYPE = 128;
    static TIMER = 129;
    static UNLOCK = 130;
    static UNTIL = 131;
    static USING = 132;
    static VIEW = 133;
    static WEND = 134;
    static WHILE = 135;
    static WIDTH = 136;
    static WINDOW = 137;
    static WRITE = 138;
    static XOR = 139;
    static FNID = 140;
    static ID = 141;
    static CONTINUED_LINE = 142;
    static NL = 143;
    static COMMENT = 144;
    static WS = 145;
    static COMMENT_TEXT = 146;
    static NEXT_WITH_MANDATORY_ID = 147;
    static NEXT_CONTINUED_LINE = 148;
    static NEXT_WS = 149;
    static NEXT_COMMENT = 150;
    static DATA_COMMA = 151;
    static DATA_QUOTED = 152;
    static DATA_UNQUOTED = 153;
    static DATA_WS = 154;
    static COMMENT_MODE = 1;
    static NEXT_MODE = 2;
    static DATA_MODE = 3;
    static channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    static literalNames = [
      null,
      null,
      "'('",
      "')'",
      "'#'",
      "'/'",
      "'\\'",
      "'^'",
      "'-'",
      "'+'",
      "'*'",
      null,
      "';'",
      "'<'",
      "'<='",
      "'<>'",
      "'='",
      "'>'",
      "'>='",
      "'&'",
      "'%'",
      "'.'"
    ];
    static symbolicNames = [
      null,
      "COLON",
      "LEFT_PAREN",
      "RIGHT_PAREN",
      "NUMBER",
      "DIVIDE",
      "INTEGER_DIVIDE",
      "EXP",
      "MINUS",
      "PLUS",
      "TIMES",
      "COMMA",
      "SEMICOLON",
      "LT",
      "LE",
      "NE",
      "EQ",
      "GT",
      "GE",
      "AMP",
      "PERCENT",
      "DOT",
      "DIGITS",
      "HEX",
      "OCTAL",
      "PROBABLY_SINGLE_PRECISION_NUMBER",
      "DOUBLE_PRECISION_NUMBER",
      "STRING_LITERAL",
      "ABSOLUTE",
      "ACCESS",
      "AND",
      "ANY",
      "APPEND",
      "AS",
      "BASE",
      "BINARY",
      "CALL",
      "CASE",
      "CIRCLE",
      "CLEAR",
      "CLOSE",
      "COLOR",
      "COM",
      "COMMON",
      "CONST",
      "DATA",
      "DECLARE",
      "DEF",
      "DEFDBL",
      "DEFINT",
      "DEFLNG",
      "DEFSNG",
      "DEFSTR",
      "DIM",
      "DO",
      "DOUBLE",
      "ELSE",
      "ELSEIF",
      "EQV",
      "ERROR",
      "END",
      "EXIT",
      "FIELD",
      "FOR",
      "FN",
      "FUNCTION",
      "GET",
      "GOSUB",
      "GOTO",
      "IF",
      "IMP",
      "INPUT",
      "INPUT_STRING",
      "IOCTL",
      "IOCTL_STRING",
      "IS",
      "INTEGER",
      "KEY",
      "LEN",
      "LET",
      "LINE",
      "LIST",
      "LOCATE",
      "LOCK",
      "LONG",
      "LOOP",
      "LPRINT",
      "LSET",
      "MID_STRING",
      "MOD",
      "NAME",
      "NEXT",
      "NOT",
      "OPTION",
      "OFF",
      "OPEN",
      "OUTPUT",
      "OR",
      "ON",
      "PAINT",
      "PALETTE",
      "PEN",
      "PLAY",
      "PRINT",
      "PRESET",
      "PSET",
      "PUT",
      "RANDOM",
      "READ",
      "REDIM",
      "REM",
      "RESUME",
      "RETURN",
      "RSET",
      "SCREEN",
      "SEEK",
      "SEG",
      "SELECT",
      "SHARED",
      "SINGLE",
      "STATIC",
      "STEP",
      "STOP",
      "STRIG",
      "STRING",
      "SUB",
      "THEN",
      "TO",
      "TYPE",
      "TIMER",
      "UNLOCK",
      "UNTIL",
      "USING",
      "VIEW",
      "WEND",
      "WHILE",
      "WIDTH",
      "WINDOW",
      "WRITE",
      "XOR",
      "FNID",
      "ID",
      "CONTINUED_LINE",
      "NL",
      "COMMENT",
      "WS",
      "COMMENT_TEXT",
      "NEXT_WITH_MANDATORY_ID",
      "NEXT_CONTINUED_LINE",
      "NEXT_WS",
      "NEXT_COMMENT",
      "DATA_COMMA",
      "DATA_QUOTED",
      "DATA_UNQUOTED",
      "DATA_WS"
    ];
    static modeNames = [
      "DEFAULT_MODE",
      "COMMENT_MODE",
      "NEXT_MODE",
      "DATA_MODE"
    ];
    static ruleNames = [
      "COLON",
      "LEFT_PAREN",
      "RIGHT_PAREN",
      "NUMBER",
      "DIVIDE",
      "INTEGER_DIVIDE",
      "EXP",
      "MINUS",
      "PLUS",
      "TIMES",
      "COMMA",
      "SEMICOLON",
      "LT",
      "LE",
      "NE",
      "EQ",
      "GT",
      "GE",
      "AMP",
      "PERCENT",
      "DOT",
      "DIGITS",
      "HEX",
      "OCTAL",
      "PROBABLY_SINGLE_PRECISION_NUMBER",
      "E_EXPONENT",
      "DOUBLE_PRECISION_NUMBER",
      "D_EXPONENT",
      "STRING_LITERAL",
      "ABSOLUTE",
      "ACCESS",
      "AND",
      "ANY",
      "APPEND",
      "AS",
      "BASE",
      "BINARY",
      "CALL",
      "CASE",
      "CIRCLE",
      "CLEAR",
      "CLOSE",
      "COLOR",
      "COM",
      "COMMON",
      "CONST",
      "DATA",
      "DECLARE",
      "DEF",
      "DEFDBL",
      "DEFINT",
      "DEFLNG",
      "DEFSNG",
      "DEFSTR",
      "DIM",
      "DO",
      "DOUBLE",
      "ELSE",
      "ELSEIF",
      "EQV",
      "ERROR",
      "END",
      "EXIT",
      "FIELD",
      "FOR",
      "FN",
      "FUNCTION",
      "GET",
      "GOSUB",
      "GOTO",
      "IF",
      "IMP",
      "INPUT",
      "INPUT_STRING",
      "IOCTL",
      "IOCTL_STRING",
      "IS",
      "INTEGER",
      "KEY",
      "LEN",
      "LET",
      "LINE",
      "LIST",
      "LOCATE",
      "LOCK",
      "LONG",
      "LOOP",
      "LPRINT",
      "LSET",
      "MID_STRING",
      "MOD",
      "NAME",
      "NEXT",
      "NOT",
      "OPTION",
      "OFF",
      "OPEN",
      "OUTPUT",
      "OR",
      "ON",
      "PAINT",
      "PALETTE",
      "PEN",
      "PLAY",
      "PRINT",
      "PRESET",
      "PSET",
      "PUT",
      "RANDOM",
      "READ",
      "REDIM",
      "REM",
      "RESUME",
      "RETURN",
      "RSET",
      "SCREEN",
      "SEEK",
      "SEG",
      "SELECT",
      "SHARED",
      "SINGLE",
      "STATIC",
      "STEP",
      "STOP",
      "STRIG",
      "STRING",
      "SUB",
      "THEN",
      "TO",
      "TYPE",
      "TIMER",
      "UNLOCK",
      "UNTIL",
      "USING",
      "VIEW",
      "WEND",
      "WHILE",
      "WIDTH",
      "WINDOW",
      "WRITE",
      "XOR",
      "FNID",
      "ID",
      "TYPE_SIGIL",
      "CONTINUED_LINE",
      "NL",
      "COMMENT",
      "WS",
      "COMMENT_TEXT",
      "COMMENT_NL",
      "NEXT_WITH_MANDATORY_ID",
      "NEXT_ID",
      "NEXT_CONTINUED_LINE",
      "NEXT_NL",
      "NEXT_COLON",
      "NEXT_WS",
      "NEXT_COMMENT",
      "DATA_COMMA",
      "DATA_COLON",
      "DATA_NL",
      "DATA_QUOTED",
      "DATA_UNQUOTED",
      "DATA_WS"
    ];
    constructor(input) {
      super(input);
      this.interpreter = new LexerATNSimulator(this, _QBasicLexer._ATN, _QBasicLexer.decisionsToDFA, new PredictionContextCache());
    }
    get grammarFileName() {
      return "QBasicLexer.g4";
    }
    get literalNames() {
      return _QBasicLexer.literalNames;
    }
    get symbolicNames() {
      return _QBasicLexer.symbolicNames;
    }
    get ruleNames() {
      return _QBasicLexer.ruleNames;
    }
    get serializedATN() {
      return _QBasicLexer._serializedATN;
    }
    get channelNames() {
      return _QBasicLexer.channelNames;
    }
    get modeNames() {
      return _QBasicLexer.modeNames;
    }
    static _serializedATN = [
      4,
      0,
      154,
      1320,
      6,
      -1,
      6,
      -1,
      6,
      -1,
      6,
      -1,
      2,
      0,
      7,
      0,
      2,
      1,
      7,
      1,
      2,
      2,
      7,
      2,
      2,
      3,
      7,
      3,
      2,
      4,
      7,
      4,
      2,
      5,
      7,
      5,
      2,
      6,
      7,
      6,
      2,
      7,
      7,
      7,
      2,
      8,
      7,
      8,
      2,
      9,
      7,
      9,
      2,
      10,
      7,
      10,
      2,
      11,
      7,
      11,
      2,
      12,
      7,
      12,
      2,
      13,
      7,
      13,
      2,
      14,
      7,
      14,
      2,
      15,
      7,
      15,
      2,
      16,
      7,
      16,
      2,
      17,
      7,
      17,
      2,
      18,
      7,
      18,
      2,
      19,
      7,
      19,
      2,
      20,
      7,
      20,
      2,
      21,
      7,
      21,
      2,
      22,
      7,
      22,
      2,
      23,
      7,
      23,
      2,
      24,
      7,
      24,
      2,
      25,
      7,
      25,
      2,
      26,
      7,
      26,
      2,
      27,
      7,
      27,
      2,
      28,
      7,
      28,
      2,
      29,
      7,
      29,
      2,
      30,
      7,
      30,
      2,
      31,
      7,
      31,
      2,
      32,
      7,
      32,
      2,
      33,
      7,
      33,
      2,
      34,
      7,
      34,
      2,
      35,
      7,
      35,
      2,
      36,
      7,
      36,
      2,
      37,
      7,
      37,
      2,
      38,
      7,
      38,
      2,
      39,
      7,
      39,
      2,
      40,
      7,
      40,
      2,
      41,
      7,
      41,
      2,
      42,
      7,
      42,
      2,
      43,
      7,
      43,
      2,
      44,
      7,
      44,
      2,
      45,
      7,
      45,
      2,
      46,
      7,
      46,
      2,
      47,
      7,
      47,
      2,
      48,
      7,
      48,
      2,
      49,
      7,
      49,
      2,
      50,
      7,
      50,
      2,
      51,
      7,
      51,
      2,
      52,
      7,
      52,
      2,
      53,
      7,
      53,
      2,
      54,
      7,
      54,
      2,
      55,
      7,
      55,
      2,
      56,
      7,
      56,
      2,
      57,
      7,
      57,
      2,
      58,
      7,
      58,
      2,
      59,
      7,
      59,
      2,
      60,
      7,
      60,
      2,
      61,
      7,
      61,
      2,
      62,
      7,
      62,
      2,
      63,
      7,
      63,
      2,
      64,
      7,
      64,
      2,
      65,
      7,
      65,
      2,
      66,
      7,
      66,
      2,
      67,
      7,
      67,
      2,
      68,
      7,
      68,
      2,
      69,
      7,
      69,
      2,
      70,
      7,
      70,
      2,
      71,
      7,
      71,
      2,
      72,
      7,
      72,
      2,
      73,
      7,
      73,
      2,
      74,
      7,
      74,
      2,
      75,
      7,
      75,
      2,
      76,
      7,
      76,
      2,
      77,
      7,
      77,
      2,
      78,
      7,
      78,
      2,
      79,
      7,
      79,
      2,
      80,
      7,
      80,
      2,
      81,
      7,
      81,
      2,
      82,
      7,
      82,
      2,
      83,
      7,
      83,
      2,
      84,
      7,
      84,
      2,
      85,
      7,
      85,
      2,
      86,
      7,
      86,
      2,
      87,
      7,
      87,
      2,
      88,
      7,
      88,
      2,
      89,
      7,
      89,
      2,
      90,
      7,
      90,
      2,
      91,
      7,
      91,
      2,
      92,
      7,
      92,
      2,
      93,
      7,
      93,
      2,
      94,
      7,
      94,
      2,
      95,
      7,
      95,
      2,
      96,
      7,
      96,
      2,
      97,
      7,
      97,
      2,
      98,
      7,
      98,
      2,
      99,
      7,
      99,
      2,
      100,
      7,
      100,
      2,
      101,
      7,
      101,
      2,
      102,
      7,
      102,
      2,
      103,
      7,
      103,
      2,
      104,
      7,
      104,
      2,
      105,
      7,
      105,
      2,
      106,
      7,
      106,
      2,
      107,
      7,
      107,
      2,
      108,
      7,
      108,
      2,
      109,
      7,
      109,
      2,
      110,
      7,
      110,
      2,
      111,
      7,
      111,
      2,
      112,
      7,
      112,
      2,
      113,
      7,
      113,
      2,
      114,
      7,
      114,
      2,
      115,
      7,
      115,
      2,
      116,
      7,
      116,
      2,
      117,
      7,
      117,
      2,
      118,
      7,
      118,
      2,
      119,
      7,
      119,
      2,
      120,
      7,
      120,
      2,
      121,
      7,
      121,
      2,
      122,
      7,
      122,
      2,
      123,
      7,
      123,
      2,
      124,
      7,
      124,
      2,
      125,
      7,
      125,
      2,
      126,
      7,
      126,
      2,
      127,
      7,
      127,
      2,
      128,
      7,
      128,
      2,
      129,
      7,
      129,
      2,
      130,
      7,
      130,
      2,
      131,
      7,
      131,
      2,
      132,
      7,
      132,
      2,
      133,
      7,
      133,
      2,
      134,
      7,
      134,
      2,
      135,
      7,
      135,
      2,
      136,
      7,
      136,
      2,
      137,
      7,
      137,
      2,
      138,
      7,
      138,
      2,
      139,
      7,
      139,
      2,
      140,
      7,
      140,
      2,
      141,
      7,
      141,
      2,
      142,
      7,
      142,
      2,
      143,
      7,
      143,
      2,
      144,
      7,
      144,
      2,
      145,
      7,
      145,
      2,
      146,
      7,
      146,
      2,
      147,
      7,
      147,
      2,
      148,
      7,
      148,
      2,
      149,
      7,
      149,
      2,
      150,
      7,
      150,
      2,
      151,
      7,
      151,
      2,
      152,
      7,
      152,
      2,
      153,
      7,
      153,
      2,
      154,
      7,
      154,
      2,
      155,
      7,
      155,
      2,
      156,
      7,
      156,
      2,
      157,
      7,
      157,
      2,
      158,
      7,
      158,
      2,
      159,
      7,
      159,
      2,
      160,
      7,
      160,
      2,
      161,
      7,
      161,
      2,
      162,
      7,
      162,
      1,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      2,
      1,
      2,
      1,
      3,
      1,
      3,
      1,
      4,
      1,
      4,
      1,
      5,
      1,
      5,
      1,
      6,
      1,
      6,
      1,
      7,
      1,
      7,
      1,
      8,
      1,
      8,
      1,
      9,
      1,
      9,
      1,
      10,
      1,
      10,
      1,
      11,
      1,
      11,
      1,
      12,
      1,
      12,
      1,
      13,
      1,
      13,
      1,
      13,
      1,
      14,
      1,
      14,
      1,
      14,
      1,
      15,
      1,
      15,
      1,
      16,
      1,
      16,
      1,
      17,
      1,
      17,
      1,
      17,
      1,
      18,
      1,
      18,
      1,
      19,
      1,
      19,
      1,
      20,
      1,
      20,
      1,
      21,
      4,
      21,
      377,
      8,
      21,
      11,
      21,
      12,
      21,
      378,
      1,
      22,
      1,
      22,
      1,
      22,
      4,
      22,
      384,
      8,
      22,
      11,
      22,
      12,
      22,
      385,
      1,
      23,
      1,
      23,
      1,
      23,
      4,
      23,
      391,
      8,
      23,
      11,
      23,
      12,
      23,
      392,
      1,
      24,
      4,
      24,
      396,
      8,
      24,
      11,
      24,
      12,
      24,
      397,
      1,
      24,
      1,
      24,
      5,
      24,
      402,
      8,
      24,
      10,
      24,
      12,
      24,
      405,
      9,
      24,
      1,
      24,
      3,
      24,
      408,
      8,
      24,
      1,
      24,
      3,
      24,
      411,
      8,
      24,
      1,
      24,
      1,
      24,
      4,
      24,
      415,
      8,
      24,
      11,
      24,
      12,
      24,
      416,
      1,
      24,
      3,
      24,
      420,
      8,
      24,
      1,
      24,
      3,
      24,
      423,
      8,
      24,
      1,
      24,
      4,
      24,
      426,
      8,
      24,
      11,
      24,
      12,
      24,
      427,
      1,
      24,
      1,
      24,
      3,
      24,
      432,
      8,
      24,
      1,
      24,
      4,
      24,
      435,
      8,
      24,
      11,
      24,
      12,
      24,
      436,
      1,
      24,
      3,
      24,
      440,
      8,
      24,
      1,
      25,
      1,
      25,
      3,
      25,
      444,
      8,
      25,
      1,
      25,
      4,
      25,
      447,
      8,
      25,
      11,
      25,
      12,
      25,
      448,
      1,
      26,
      4,
      26,
      452,
      8,
      26,
      11,
      26,
      12,
      26,
      453,
      1,
      26,
      1,
      26,
      5,
      26,
      458,
      8,
      26,
      10,
      26,
      12,
      26,
      461,
      9,
      26,
      1,
      26,
      1,
      26,
      3,
      26,
      465,
      8,
      26,
      1,
      26,
      1,
      26,
      4,
      26,
      469,
      8,
      26,
      11,
      26,
      12,
      26,
      470,
      1,
      26,
      1,
      26,
      3,
      26,
      475,
      8,
      26,
      1,
      26,
      4,
      26,
      478,
      8,
      26,
      11,
      26,
      12,
      26,
      479,
      1,
      26,
      1,
      26,
      3,
      26,
      484,
      8,
      26,
      3,
      26,
      486,
      8,
      26,
      1,
      27,
      1,
      27,
      3,
      27,
      490,
      8,
      27,
      1,
      27,
      4,
      27,
      493,
      8,
      27,
      11,
      27,
      12,
      27,
      494,
      1,
      27,
      3,
      27,
      498,
      8,
      27,
      1,
      28,
      1,
      28,
      5,
      28,
      502,
      8,
      28,
      10,
      28,
      12,
      28,
      505,
      9,
      28,
      1,
      28,
      1,
      28,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      30,
      1,
      30,
      1,
      30,
      1,
      30,
      1,
      30,
      1,
      30,
      1,
      30,
      1,
      31,
      1,
      31,
      1,
      31,
      1,
      31,
      1,
      32,
      1,
      32,
      1,
      32,
      1,
      32,
      1,
      33,
      1,
      33,
      1,
      33,
      1,
      33,
      1,
      33,
      1,
      33,
      1,
      33,
      1,
      34,
      1,
      34,
      1,
      34,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      37,
      1,
      37,
      1,
      37,
      1,
      37,
      1,
      37,
      1,
      38,
      1,
      38,
      1,
      38,
      1,
      38,
      1,
      38,
      1,
      39,
      1,
      39,
      1,
      39,
      1,
      39,
      1,
      39,
      1,
      39,
      1,
      39,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      41,
      1,
      41,
      1,
      41,
      1,
      41,
      1,
      41,
      1,
      41,
      1,
      42,
      1,
      42,
      1,
      42,
      1,
      42,
      1,
      42,
      1,
      42,
      1,
      43,
      1,
      43,
      1,
      43,
      1,
      43,
      1,
      44,
      1,
      44,
      1,
      44,
      1,
      44,
      1,
      44,
      1,
      44,
      1,
      44,
      1,
      45,
      1,
      45,
      1,
      45,
      1,
      45,
      1,
      45,
      1,
      45,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      47,
      1,
      47,
      1,
      47,
      1,
      47,
      1,
      47,
      1,
      47,
      1,
      47,
      1,
      47,
      1,
      48,
      1,
      48,
      1,
      48,
      1,
      48,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      50,
      1,
      50,
      1,
      50,
      1,
      50,
      1,
      50,
      1,
      50,
      1,
      50,
      1,
      51,
      1,
      51,
      1,
      51,
      1,
      51,
      1,
      51,
      1,
      51,
      1,
      51,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      53,
      1,
      53,
      1,
      53,
      1,
      53,
      1,
      53,
      1,
      53,
      1,
      53,
      1,
      54,
      1,
      54,
      1,
      54,
      1,
      54,
      1,
      55,
      1,
      55,
      1,
      55,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      57,
      1,
      57,
      1,
      57,
      1,
      57,
      1,
      57,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      1,
      61,
      1,
      61,
      1,
      61,
      1,
      61,
      1,
      62,
      1,
      62,
      1,
      62,
      1,
      62,
      1,
      62,
      1,
      63,
      1,
      63,
      1,
      63,
      1,
      63,
      1,
      63,
      1,
      63,
      1,
      64,
      1,
      64,
      1,
      64,
      1,
      64,
      1,
      65,
      1,
      65,
      1,
      65,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      67,
      1,
      67,
      1,
      67,
      1,
      67,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      70,
      1,
      70,
      1,
      70,
      1,
      71,
      1,
      71,
      1,
      71,
      1,
      71,
      1,
      72,
      1,
      72,
      1,
      72,
      1,
      72,
      1,
      72,
      1,
      72,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      74,
      1,
      74,
      1,
      74,
      1,
      74,
      1,
      74,
      1,
      74,
      1,
      75,
      1,
      75,
      1,
      75,
      1,
      75,
      1,
      75,
      1,
      75,
      1,
      75,
      1,
      76,
      1,
      76,
      1,
      76,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      78,
      1,
      78,
      1,
      78,
      1,
      78,
      1,
      79,
      1,
      79,
      1,
      79,
      1,
      79,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      81,
      1,
      81,
      1,
      81,
      1,
      81,
      1,
      81,
      1,
      82,
      1,
      82,
      1,
      82,
      1,
      82,
      1,
      82,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      84,
      1,
      84,
      1,
      84,
      1,
      84,
      1,
      84,
      1,
      85,
      1,
      85,
      1,
      85,
      1,
      85,
      1,
      85,
      1,
      86,
      1,
      86,
      1,
      86,
      1,
      86,
      1,
      86,
      1,
      87,
      1,
      87,
      1,
      87,
      1,
      87,
      1,
      87,
      1,
      87,
      1,
      87,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      91,
      1,
      91,
      1,
      91,
      1,
      91,
      1,
      91,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      93,
      1,
      93,
      1,
      93,
      1,
      93,
      1,
      94,
      1,
      94,
      1,
      94,
      1,
      94,
      1,
      94,
      1,
      94,
      1,
      94,
      1,
      95,
      1,
      95,
      1,
      95,
      1,
      95,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      97,
      1,
      97,
      1,
      97,
      1,
      97,
      1,
      97,
      1,
      97,
      1,
      97,
      1,
      98,
      1,
      98,
      1,
      98,
      1,
      99,
      1,
      99,
      1,
      99,
      1,
      100,
      1,
      100,
      1,
      100,
      1,
      100,
      1,
      100,
      1,
      100,
      1,
      101,
      1,
      101,
      1,
      101,
      1,
      101,
      1,
      101,
      1,
      101,
      1,
      101,
      1,
      101,
      1,
      102,
      1,
      102,
      1,
      102,
      1,
      102,
      1,
      103,
      1,
      103,
      1,
      103,
      1,
      103,
      1,
      103,
      1,
      104,
      1,
      104,
      1,
      104,
      1,
      104,
      1,
      104,
      1,
      104,
      1,
      105,
      1,
      105,
      1,
      105,
      1,
      105,
      1,
      105,
      1,
      105,
      1,
      105,
      1,
      106,
      1,
      106,
      1,
      106,
      1,
      106,
      1,
      106,
      1,
      107,
      1,
      107,
      1,
      107,
      1,
      107,
      1,
      108,
      1,
      108,
      1,
      108,
      1,
      108,
      1,
      108,
      1,
      108,
      1,
      108,
      1,
      109,
      1,
      109,
      1,
      109,
      1,
      109,
      1,
      109,
      1,
      110,
      1,
      110,
      1,
      110,
      1,
      110,
      1,
      110,
      1,
      110,
      1,
      111,
      1,
      111,
      1,
      111,
      1,
      111,
      1,
      111,
      1,
      111,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      113,
      1,
      113,
      1,
      113,
      1,
      113,
      1,
      113,
      1,
      113,
      1,
      113,
      1,
      114,
      1,
      114,
      1,
      114,
      1,
      114,
      1,
      114,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      117,
      1,
      117,
      1,
      117,
      1,
      117,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      124,
      1,
      124,
      1,
      124,
      1,
      124,
      1,
      124,
      1,
      124,
      1,
      125,
      1,
      125,
      1,
      125,
      1,
      125,
      1,
      125,
      1,
      125,
      1,
      125,
      1,
      126,
      1,
      126,
      1,
      126,
      1,
      126,
      1,
      127,
      1,
      127,
      1,
      127,
      1,
      127,
      1,
      127,
      1,
      128,
      1,
      128,
      1,
      128,
      1,
      129,
      1,
      129,
      1,
      129,
      1,
      129,
      1,
      129,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      131,
      1,
      131,
      1,
      131,
      1,
      131,
      1,
      131,
      1,
      131,
      1,
      131,
      1,
      132,
      1,
      132,
      1,
      132,
      1,
      132,
      1,
      132,
      1,
      132,
      1,
      133,
      1,
      133,
      1,
      133,
      1,
      133,
      1,
      133,
      1,
      133,
      1,
      134,
      1,
      134,
      1,
      134,
      1,
      134,
      1,
      134,
      1,
      135,
      1,
      135,
      1,
      135,
      1,
      135,
      1,
      135,
      1,
      136,
      1,
      136,
      1,
      136,
      1,
      136,
      1,
      136,
      1,
      136,
      1,
      137,
      1,
      137,
      1,
      137,
      1,
      137,
      1,
      137,
      1,
      137,
      1,
      138,
      1,
      138,
      1,
      138,
      1,
      138,
      1,
      138,
      1,
      138,
      1,
      138,
      1,
      139,
      1,
      139,
      1,
      139,
      1,
      139,
      1,
      139,
      1,
      139,
      1,
      140,
      1,
      140,
      1,
      140,
      1,
      140,
      1,
      141,
      1,
      141,
      1,
      141,
      1,
      141,
      5,
      141,
      1137,
      8,
      141,
      10,
      141,
      12,
      141,
      1140,
      9,
      141,
      1,
      141,
      3,
      141,
      1143,
      8,
      141,
      1,
      142,
      1,
      142,
      5,
      142,
      1147,
      8,
      142,
      10,
      142,
      12,
      142,
      1150,
      9,
      142,
      1,
      142,
      3,
      142,
      1153,
      8,
      142,
      1,
      142,
      1,
      142,
      1,
      142,
      5,
      142,
      1158,
      8,
      142,
      10,
      142,
      12,
      142,
      1161,
      9,
      142,
      1,
      142,
      3,
      142,
      1164,
      8,
      142,
      1,
      142,
      1,
      142,
      3,
      142,
      1168,
      8,
      142,
      3,
      142,
      1170,
      8,
      142,
      1,
      143,
      1,
      143,
      1,
      144,
      1,
      144,
      3,
      144,
      1176,
      8,
      144,
      1,
      144,
      1,
      144,
      1,
      144,
      1,
      144,
      1,
      145,
      3,
      145,
      1183,
      8,
      145,
      1,
      145,
      1,
      145,
      1,
      146,
      1,
      146,
      1,
      146,
      1,
      146,
      1,
      146,
      1,
      147,
      4,
      147,
      1193,
      8,
      147,
      11,
      147,
      12,
      147,
      1194,
      1,
      147,
      1,
      147,
      1,
      148,
      4,
      148,
      1200,
      8,
      148,
      11,
      148,
      12,
      148,
      1201,
      1,
      148,
      1,
      148,
      1,
      149,
      3,
      149,
      1207,
      8,
      149,
      1,
      149,
      1,
      149,
      1,
      149,
      1,
      149,
      1,
      149,
      1,
      150,
      1,
      150,
      1,
      151,
      1,
      151,
      5,
      151,
      1218,
      8,
      151,
      10,
      151,
      12,
      151,
      1221,
      9,
      151,
      1,
      151,
      3,
      151,
      1224,
      8,
      151,
      1,
      151,
      1,
      151,
      1,
      151,
      5,
      151,
      1229,
      8,
      151,
      10,
      151,
      12,
      151,
      1232,
      9,
      151,
      1,
      151,
      3,
      151,
      1235,
      8,
      151,
      1,
      151,
      1,
      151,
      3,
      151,
      1239,
      8,
      151,
      3,
      151,
      1241,
      8,
      151,
      1,
      151,
      1,
      151,
      1,
      152,
      1,
      152,
      3,
      152,
      1247,
      8,
      152,
      1,
      152,
      1,
      152,
      1,
      152,
      1,
      152,
      1,
      153,
      3,
      153,
      1254,
      8,
      153,
      1,
      153,
      1,
      153,
      1,
      153,
      1,
      153,
      1,
      153,
      1,
      154,
      1,
      154,
      1,
      154,
      1,
      154,
      1,
      154,
      1,
      155,
      4,
      155,
      1267,
      8,
      155,
      11,
      155,
      12,
      155,
      1268,
      1,
      155,
      1,
      155,
      1,
      156,
      1,
      156,
      1,
      156,
      1,
      156,
      1,
      156,
      1,
      157,
      1,
      157,
      1,
      158,
      1,
      158,
      1,
      158,
      1,
      158,
      1,
      158,
      1,
      159,
      3,
      159,
      1286,
      8,
      159,
      1,
      159,
      1,
      159,
      1,
      159,
      1,
      159,
      1,
      159,
      1,
      160,
      1,
      160,
      5,
      160,
      1295,
      8,
      160,
      10,
      160,
      12,
      160,
      1298,
      9,
      160,
      1,
      160,
      1,
      160,
      1,
      161,
      1,
      161,
      1,
      161,
      1,
      161,
      1,
      161,
      4,
      161,
      1307,
      8,
      161,
      11,
      161,
      12,
      161,
      1308,
      1,
      161,
      3,
      161,
      1312,
      8,
      161,
      1,
      162,
      4,
      162,
      1315,
      8,
      162,
      11,
      162,
      12,
      162,
      1316,
      1,
      162,
      1,
      162,
      0,
      0,
      163,
      4,
      1,
      6,
      2,
      8,
      3,
      10,
      4,
      12,
      5,
      14,
      6,
      16,
      7,
      18,
      8,
      20,
      9,
      22,
      10,
      24,
      11,
      26,
      12,
      28,
      13,
      30,
      14,
      32,
      15,
      34,
      16,
      36,
      17,
      38,
      18,
      40,
      19,
      42,
      20,
      44,
      21,
      46,
      22,
      48,
      23,
      50,
      24,
      52,
      25,
      54,
      0,
      56,
      26,
      58,
      0,
      60,
      27,
      62,
      28,
      64,
      29,
      66,
      30,
      68,
      31,
      70,
      32,
      72,
      33,
      74,
      34,
      76,
      35,
      78,
      36,
      80,
      37,
      82,
      38,
      84,
      39,
      86,
      40,
      88,
      41,
      90,
      42,
      92,
      43,
      94,
      44,
      96,
      45,
      98,
      46,
      100,
      47,
      102,
      48,
      104,
      49,
      106,
      50,
      108,
      51,
      110,
      52,
      112,
      53,
      114,
      54,
      116,
      55,
      118,
      56,
      120,
      57,
      122,
      58,
      124,
      59,
      126,
      60,
      128,
      61,
      130,
      62,
      132,
      63,
      134,
      64,
      136,
      65,
      138,
      66,
      140,
      67,
      142,
      68,
      144,
      69,
      146,
      70,
      148,
      71,
      150,
      72,
      152,
      73,
      154,
      74,
      156,
      75,
      158,
      76,
      160,
      77,
      162,
      78,
      164,
      79,
      166,
      80,
      168,
      81,
      170,
      82,
      172,
      83,
      174,
      84,
      176,
      85,
      178,
      86,
      180,
      87,
      182,
      88,
      184,
      89,
      186,
      90,
      188,
      91,
      190,
      92,
      192,
      93,
      194,
      94,
      196,
      95,
      198,
      96,
      200,
      97,
      202,
      98,
      204,
      99,
      206,
      100,
      208,
      101,
      210,
      102,
      212,
      103,
      214,
      104,
      216,
      105,
      218,
      106,
      220,
      107,
      222,
      108,
      224,
      109,
      226,
      110,
      228,
      111,
      230,
      112,
      232,
      113,
      234,
      114,
      236,
      115,
      238,
      116,
      240,
      117,
      242,
      118,
      244,
      119,
      246,
      120,
      248,
      121,
      250,
      122,
      252,
      123,
      254,
      124,
      256,
      125,
      258,
      126,
      260,
      127,
      262,
      128,
      264,
      129,
      266,
      130,
      268,
      131,
      270,
      132,
      272,
      133,
      274,
      134,
      276,
      135,
      278,
      136,
      280,
      137,
      282,
      138,
      284,
      139,
      286,
      140,
      288,
      141,
      290,
      0,
      292,
      142,
      294,
      143,
      296,
      144,
      298,
      145,
      300,
      146,
      302,
      0,
      304,
      147,
      306,
      0,
      308,
      148,
      310,
      0,
      312,
      0,
      314,
      149,
      316,
      150,
      318,
      151,
      320,
      0,
      322,
      0,
      324,
      152,
      326,
      153,
      328,
      154,
      4,
      0,
      1,
      2,
      3,
      38,
      1,
      0,
      48,
      57,
      2,
      0,
      72,
      72,
      104,
      104,
      3,
      0,
      48,
      57,
      65,
      70,
      97,
      102,
      2,
      0,
      79,
      79,
      111,
      111,
      1,
      0,
      48,
      55,
      2,
      0,
      69,
      69,
      101,
      101,
      2,
      0,
      43,
      43,
      45,
      45,
      2,
      0,
      68,
      68,
      100,
      100,
      3,
      0,
      10,
      10,
      13,
      13,
      34,
      34,
      2,
      0,
      65,
      65,
      97,
      97,
      2,
      0,
      66,
      66,
      98,
      98,
      2,
      0,
      83,
      83,
      115,
      115,
      2,
      0,
      76,
      76,
      108,
      108,
      2,
      0,
      85,
      85,
      117,
      117,
      2,
      0,
      84,
      84,
      116,
      116,
      2,
      0,
      67,
      67,
      99,
      99,
      2,
      0,
      78,
      78,
      110,
      110,
      2,
      0,
      89,
      89,
      121,
      121,
      2,
      0,
      80,
      80,
      112,
      112,
      2,
      0,
      73,
      73,
      105,
      105,
      2,
      0,
      82,
      82,
      114,
      114,
      2,
      0,
      77,
      77,
      109,
      109,
      2,
      0,
      70,
      70,
      102,
      102,
      2,
      0,
      71,
      71,
      103,
      103,
      2,
      0,
      81,
      81,
      113,
      113,
      2,
      0,
      86,
      86,
      118,
      118,
      2,
      0,
      88,
      88,
      120,
      120,
      2,
      0,
      75,
      75,
      107,
      107,
      2,
      0,
      87,
      87,
      119,
      119,
      2,
      0,
      65,
      90,
      97,
      122,
      4,
      0,
      46,
      46,
      48,
      57,
      65,
      90,
      97,
      122,
      4,
      0,
      65,
      69,
      71,
      90,
      97,
      101,
      103,
      122,
      6,
      0,
      46,
      46,
      48,
      57,
      65,
      77,
      79,
      90,
      97,
      109,
      111,
      122,
      2,
      0,
      33,
      33,
      35,
      38,
      3,
      0,
      9,
      9,
      26,
      26,
      32,
      32,
      2,
      0,
      10,
      10,
      13,
      13,
      5,
      0,
      9,
      10,
      13,
      13,
      32,
      32,
      44,
      44,
      58,
      58,
      4,
      0,
      10,
      10,
      13,
      13,
      44,
      44,
      58,
      58,
      1374,
      0,
      4,
      1,
      0,
      0,
      0,
      0,
      6,
      1,
      0,
      0,
      0,
      0,
      8,
      1,
      0,
      0,
      0,
      0,
      10,
      1,
      0,
      0,
      0,
      0,
      12,
      1,
      0,
      0,
      0,
      0,
      14,
      1,
      0,
      0,
      0,
      0,
      16,
      1,
      0,
      0,
      0,
      0,
      18,
      1,
      0,
      0,
      0,
      0,
      20,
      1,
      0,
      0,
      0,
      0,
      22,
      1,
      0,
      0,
      0,
      0,
      24,
      1,
      0,
      0,
      0,
      0,
      26,
      1,
      0,
      0,
      0,
      0,
      28,
      1,
      0,
      0,
      0,
      0,
      30,
      1,
      0,
      0,
      0,
      0,
      32,
      1,
      0,
      0,
      0,
      0,
      34,
      1,
      0,
      0,
      0,
      0,
      36,
      1,
      0,
      0,
      0,
      0,
      38,
      1,
      0,
      0,
      0,
      0,
      40,
      1,
      0,
      0,
      0,
      0,
      42,
      1,
      0,
      0,
      0,
      0,
      44,
      1,
      0,
      0,
      0,
      0,
      46,
      1,
      0,
      0,
      0,
      0,
      48,
      1,
      0,
      0,
      0,
      0,
      50,
      1,
      0,
      0,
      0,
      0,
      52,
      1,
      0,
      0,
      0,
      0,
      56,
      1,
      0,
      0,
      0,
      0,
      60,
      1,
      0,
      0,
      0,
      0,
      62,
      1,
      0,
      0,
      0,
      0,
      64,
      1,
      0,
      0,
      0,
      0,
      66,
      1,
      0,
      0,
      0,
      0,
      68,
      1,
      0,
      0,
      0,
      0,
      70,
      1,
      0,
      0,
      0,
      0,
      72,
      1,
      0,
      0,
      0,
      0,
      74,
      1,
      0,
      0,
      0,
      0,
      76,
      1,
      0,
      0,
      0,
      0,
      78,
      1,
      0,
      0,
      0,
      0,
      80,
      1,
      0,
      0,
      0,
      0,
      82,
      1,
      0,
      0,
      0,
      0,
      84,
      1,
      0,
      0,
      0,
      0,
      86,
      1,
      0,
      0,
      0,
      0,
      88,
      1,
      0,
      0,
      0,
      0,
      90,
      1,
      0,
      0,
      0,
      0,
      92,
      1,
      0,
      0,
      0,
      0,
      94,
      1,
      0,
      0,
      0,
      0,
      96,
      1,
      0,
      0,
      0,
      0,
      98,
      1,
      0,
      0,
      0,
      0,
      100,
      1,
      0,
      0,
      0,
      0,
      102,
      1,
      0,
      0,
      0,
      0,
      104,
      1,
      0,
      0,
      0,
      0,
      106,
      1,
      0,
      0,
      0,
      0,
      108,
      1,
      0,
      0,
      0,
      0,
      110,
      1,
      0,
      0,
      0,
      0,
      112,
      1,
      0,
      0,
      0,
      0,
      114,
      1,
      0,
      0,
      0,
      0,
      116,
      1,
      0,
      0,
      0,
      0,
      118,
      1,
      0,
      0,
      0,
      0,
      120,
      1,
      0,
      0,
      0,
      0,
      122,
      1,
      0,
      0,
      0,
      0,
      124,
      1,
      0,
      0,
      0,
      0,
      126,
      1,
      0,
      0,
      0,
      0,
      128,
      1,
      0,
      0,
      0,
      0,
      130,
      1,
      0,
      0,
      0,
      0,
      132,
      1,
      0,
      0,
      0,
      0,
      134,
      1,
      0,
      0,
      0,
      0,
      136,
      1,
      0,
      0,
      0,
      0,
      138,
      1,
      0,
      0,
      0,
      0,
      140,
      1,
      0,
      0,
      0,
      0,
      142,
      1,
      0,
      0,
      0,
      0,
      144,
      1,
      0,
      0,
      0,
      0,
      146,
      1,
      0,
      0,
      0,
      0,
      148,
      1,
      0,
      0,
      0,
      0,
      150,
      1,
      0,
      0,
      0,
      0,
      152,
      1,
      0,
      0,
      0,
      0,
      154,
      1,
      0,
      0,
      0,
      0,
      156,
      1,
      0,
      0,
      0,
      0,
      158,
      1,
      0,
      0,
      0,
      0,
      160,
      1,
      0,
      0,
      0,
      0,
      162,
      1,
      0,
      0,
      0,
      0,
      164,
      1,
      0,
      0,
      0,
      0,
      166,
      1,
      0,
      0,
      0,
      0,
      168,
      1,
      0,
      0,
      0,
      0,
      170,
      1,
      0,
      0,
      0,
      0,
      172,
      1,
      0,
      0,
      0,
      0,
      174,
      1,
      0,
      0,
      0,
      0,
      176,
      1,
      0,
      0,
      0,
      0,
      178,
      1,
      0,
      0,
      0,
      0,
      180,
      1,
      0,
      0,
      0,
      0,
      182,
      1,
      0,
      0,
      0,
      0,
      184,
      1,
      0,
      0,
      0,
      0,
      186,
      1,
      0,
      0,
      0,
      0,
      188,
      1,
      0,
      0,
      0,
      0,
      190,
      1,
      0,
      0,
      0,
      0,
      192,
      1,
      0,
      0,
      0,
      0,
      194,
      1,
      0,
      0,
      0,
      0,
      196,
      1,
      0,
      0,
      0,
      0,
      198,
      1,
      0,
      0,
      0,
      0,
      200,
      1,
      0,
      0,
      0,
      0,
      202,
      1,
      0,
      0,
      0,
      0,
      204,
      1,
      0,
      0,
      0,
      0,
      206,
      1,
      0,
      0,
      0,
      0,
      208,
      1,
      0,
      0,
      0,
      0,
      210,
      1,
      0,
      0,
      0,
      0,
      212,
      1,
      0,
      0,
      0,
      0,
      214,
      1,
      0,
      0,
      0,
      0,
      216,
      1,
      0,
      0,
      0,
      0,
      218,
      1,
      0,
      0,
      0,
      0,
      220,
      1,
      0,
      0,
      0,
      0,
      222,
      1,
      0,
      0,
      0,
      0,
      224,
      1,
      0,
      0,
      0,
      0,
      226,
      1,
      0,
      0,
      0,
      0,
      228,
      1,
      0,
      0,
      0,
      0,
      230,
      1,
      0,
      0,
      0,
      0,
      232,
      1,
      0,
      0,
      0,
      0,
      234,
      1,
      0,
      0,
      0,
      0,
      236,
      1,
      0,
      0,
      0,
      0,
      238,
      1,
      0,
      0,
      0,
      0,
      240,
      1,
      0,
      0,
      0,
      0,
      242,
      1,
      0,
      0,
      0,
      0,
      244,
      1,
      0,
      0,
      0,
      0,
      246,
      1,
      0,
      0,
      0,
      0,
      248,
      1,
      0,
      0,
      0,
      0,
      250,
      1,
      0,
      0,
      0,
      0,
      252,
      1,
      0,
      0,
      0,
      0,
      254,
      1,
      0,
      0,
      0,
      0,
      256,
      1,
      0,
      0,
      0,
      0,
      258,
      1,
      0,
      0,
      0,
      0,
      260,
      1,
      0,
      0,
      0,
      0,
      262,
      1,
      0,
      0,
      0,
      0,
      264,
      1,
      0,
      0,
      0,
      0,
      266,
      1,
      0,
      0,
      0,
      0,
      268,
      1,
      0,
      0,
      0,
      0,
      270,
      1,
      0,
      0,
      0,
      0,
      272,
      1,
      0,
      0,
      0,
      0,
      274,
      1,
      0,
      0,
      0,
      0,
      276,
      1,
      0,
      0,
      0,
      0,
      278,
      1,
      0,
      0,
      0,
      0,
      280,
      1,
      0,
      0,
      0,
      0,
      282,
      1,
      0,
      0,
      0,
      0,
      284,
      1,
      0,
      0,
      0,
      0,
      286,
      1,
      0,
      0,
      0,
      0,
      288,
      1,
      0,
      0,
      0,
      0,
      292,
      1,
      0,
      0,
      0,
      0,
      294,
      1,
      0,
      0,
      0,
      0,
      296,
      1,
      0,
      0,
      0,
      0,
      298,
      1,
      0,
      0,
      0,
      1,
      300,
      1,
      0,
      0,
      0,
      1,
      302,
      1,
      0,
      0,
      0,
      2,
      304,
      1,
      0,
      0,
      0,
      2,
      306,
      1,
      0,
      0,
      0,
      2,
      308,
      1,
      0,
      0,
      0,
      2,
      310,
      1,
      0,
      0,
      0,
      2,
      312,
      1,
      0,
      0,
      0,
      2,
      314,
      1,
      0,
      0,
      0,
      2,
      316,
      1,
      0,
      0,
      0,
      3,
      318,
      1,
      0,
      0,
      0,
      3,
      320,
      1,
      0,
      0,
      0,
      3,
      322,
      1,
      0,
      0,
      0,
      3,
      324,
      1,
      0,
      0,
      0,
      3,
      326,
      1,
      0,
      0,
      0,
      3,
      328,
      1,
      0,
      0,
      0,
      4,
      330,
      1,
      0,
      0,
      0,
      6,
      332,
      1,
      0,
      0,
      0,
      8,
      334,
      1,
      0,
      0,
      0,
      10,
      336,
      1,
      0,
      0,
      0,
      12,
      338,
      1,
      0,
      0,
      0,
      14,
      340,
      1,
      0,
      0,
      0,
      16,
      342,
      1,
      0,
      0,
      0,
      18,
      344,
      1,
      0,
      0,
      0,
      20,
      346,
      1,
      0,
      0,
      0,
      22,
      348,
      1,
      0,
      0,
      0,
      24,
      350,
      1,
      0,
      0,
      0,
      26,
      352,
      1,
      0,
      0,
      0,
      28,
      354,
      1,
      0,
      0,
      0,
      30,
      356,
      1,
      0,
      0,
      0,
      32,
      359,
      1,
      0,
      0,
      0,
      34,
      362,
      1,
      0,
      0,
      0,
      36,
      364,
      1,
      0,
      0,
      0,
      38,
      366,
      1,
      0,
      0,
      0,
      40,
      369,
      1,
      0,
      0,
      0,
      42,
      371,
      1,
      0,
      0,
      0,
      44,
      373,
      1,
      0,
      0,
      0,
      46,
      376,
      1,
      0,
      0,
      0,
      48,
      380,
      1,
      0,
      0,
      0,
      50,
      387,
      1,
      0,
      0,
      0,
      52,
      439,
      1,
      0,
      0,
      0,
      54,
      441,
      1,
      0,
      0,
      0,
      56,
      485,
      1,
      0,
      0,
      0,
      58,
      487,
      1,
      0,
      0,
      0,
      60,
      499,
      1,
      0,
      0,
      0,
      62,
      508,
      1,
      0,
      0,
      0,
      64,
      517,
      1,
      0,
      0,
      0,
      66,
      524,
      1,
      0,
      0,
      0,
      68,
      528,
      1,
      0,
      0,
      0,
      70,
      532,
      1,
      0,
      0,
      0,
      72,
      539,
      1,
      0,
      0,
      0,
      74,
      542,
      1,
      0,
      0,
      0,
      76,
      547,
      1,
      0,
      0,
      0,
      78,
      554,
      1,
      0,
      0,
      0,
      80,
      559,
      1,
      0,
      0,
      0,
      82,
      564,
      1,
      0,
      0,
      0,
      84,
      571,
      1,
      0,
      0,
      0,
      86,
      577,
      1,
      0,
      0,
      0,
      88,
      583,
      1,
      0,
      0,
      0,
      90,
      589,
      1,
      0,
      0,
      0,
      92,
      593,
      1,
      0,
      0,
      0,
      94,
      600,
      1,
      0,
      0,
      0,
      96,
      606,
      1,
      0,
      0,
      0,
      98,
      613,
      1,
      0,
      0,
      0,
      100,
      621,
      1,
      0,
      0,
      0,
      102,
      625,
      1,
      0,
      0,
      0,
      104,
      632,
      1,
      0,
      0,
      0,
      106,
      639,
      1,
      0,
      0,
      0,
      108,
      646,
      1,
      0,
      0,
      0,
      110,
      653,
      1,
      0,
      0,
      0,
      112,
      660,
      1,
      0,
      0,
      0,
      114,
      664,
      1,
      0,
      0,
      0,
      116,
      667,
      1,
      0,
      0,
      0,
      118,
      674,
      1,
      0,
      0,
      0,
      120,
      679,
      1,
      0,
      0,
      0,
      122,
      686,
      1,
      0,
      0,
      0,
      124,
      690,
      1,
      0,
      0,
      0,
      126,
      696,
      1,
      0,
      0,
      0,
      128,
      700,
      1,
      0,
      0,
      0,
      130,
      705,
      1,
      0,
      0,
      0,
      132,
      711,
      1,
      0,
      0,
      0,
      134,
      715,
      1,
      0,
      0,
      0,
      136,
      718,
      1,
      0,
      0,
      0,
      138,
      727,
      1,
      0,
      0,
      0,
      140,
      731,
      1,
      0,
      0,
      0,
      142,
      737,
      1,
      0,
      0,
      0,
      144,
      742,
      1,
      0,
      0,
      0,
      146,
      745,
      1,
      0,
      0,
      0,
      148,
      749,
      1,
      0,
      0,
      0,
      150,
      755,
      1,
      0,
      0,
      0,
      152,
      762,
      1,
      0,
      0,
      0,
      154,
      768,
      1,
      0,
      0,
      0,
      156,
      775,
      1,
      0,
      0,
      0,
      158,
      778,
      1,
      0,
      0,
      0,
      160,
      786,
      1,
      0,
      0,
      0,
      162,
      790,
      1,
      0,
      0,
      0,
      164,
      794,
      1,
      0,
      0,
      0,
      166,
      798,
      1,
      0,
      0,
      0,
      168,
      803,
      1,
      0,
      0,
      0,
      170,
      808,
      1,
      0,
      0,
      0,
      172,
      815,
      1,
      0,
      0,
      0,
      174,
      820,
      1,
      0,
      0,
      0,
      176,
      825,
      1,
      0,
      0,
      0,
      178,
      830,
      1,
      0,
      0,
      0,
      180,
      837,
      1,
      0,
      0,
      0,
      182,
      842,
      1,
      0,
      0,
      0,
      184,
      847,
      1,
      0,
      0,
      0,
      186,
      851,
      1,
      0,
      0,
      0,
      188,
      856,
      1,
      0,
      0,
      0,
      190,
      863,
      1,
      0,
      0,
      0,
      192,
      867,
      1,
      0,
      0,
      0,
      194,
      874,
      1,
      0,
      0,
      0,
      196,
      878,
      1,
      0,
      0,
      0,
      198,
      883,
      1,
      0,
      0,
      0,
      200,
      890,
      1,
      0,
      0,
      0,
      202,
      893,
      1,
      0,
      0,
      0,
      204,
      896,
      1,
      0,
      0,
      0,
      206,
      902,
      1,
      0,
      0,
      0,
      208,
      910,
      1,
      0,
      0,
      0,
      210,
      914,
      1,
      0,
      0,
      0,
      212,
      919,
      1,
      0,
      0,
      0,
      214,
      925,
      1,
      0,
      0,
      0,
      216,
      932,
      1,
      0,
      0,
      0,
      218,
      937,
      1,
      0,
      0,
      0,
      220,
      941,
      1,
      0,
      0,
      0,
      222,
      948,
      1,
      0,
      0,
      0,
      224,
      953,
      1,
      0,
      0,
      0,
      226,
      959,
      1,
      0,
      0,
      0,
      228,
      965,
      1,
      0,
      0,
      0,
      230,
      972,
      1,
      0,
      0,
      0,
      232,
      979,
      1,
      0,
      0,
      0,
      234,
      984,
      1,
      0,
      0,
      0,
      236,
      991,
      1,
      0,
      0,
      0,
      238,
      996,
      1,
      0,
      0,
      0,
      240,
      1e3,
      1,
      0,
      0,
      0,
      242,
      1007,
      1,
      0,
      0,
      0,
      244,
      1014,
      1,
      0,
      0,
      0,
      246,
      1021,
      1,
      0,
      0,
      0,
      248,
      1028,
      1,
      0,
      0,
      0,
      250,
      1033,
      1,
      0,
      0,
      0,
      252,
      1038,
      1,
      0,
      0,
      0,
      254,
      1044,
      1,
      0,
      0,
      0,
      256,
      1051,
      1,
      0,
      0,
      0,
      258,
      1055,
      1,
      0,
      0,
      0,
      260,
      1060,
      1,
      0,
      0,
      0,
      262,
      1063,
      1,
      0,
      0,
      0,
      264,
      1068,
      1,
      0,
      0,
      0,
      266,
      1074,
      1,
      0,
      0,
      0,
      268,
      1081,
      1,
      0,
      0,
      0,
      270,
      1087,
      1,
      0,
      0,
      0,
      272,
      1093,
      1,
      0,
      0,
      0,
      274,
      1098,
      1,
      0,
      0,
      0,
      276,
      1103,
      1,
      0,
      0,
      0,
      278,
      1109,
      1,
      0,
      0,
      0,
      280,
      1115,
      1,
      0,
      0,
      0,
      282,
      1122,
      1,
      0,
      0,
      0,
      284,
      1128,
      1,
      0,
      0,
      0,
      286,
      1132,
      1,
      0,
      0,
      0,
      288,
      1169,
      1,
      0,
      0,
      0,
      290,
      1171,
      1,
      0,
      0,
      0,
      292,
      1173,
      1,
      0,
      0,
      0,
      294,
      1182,
      1,
      0,
      0,
      0,
      296,
      1186,
      1,
      0,
      0,
      0,
      298,
      1192,
      1,
      0,
      0,
      0,
      300,
      1199,
      1,
      0,
      0,
      0,
      302,
      1206,
      1,
      0,
      0,
      0,
      304,
      1213,
      1,
      0,
      0,
      0,
      306,
      1240,
      1,
      0,
      0,
      0,
      308,
      1244,
      1,
      0,
      0,
      0,
      310,
      1253,
      1,
      0,
      0,
      0,
      312,
      1260,
      1,
      0,
      0,
      0,
      314,
      1266,
      1,
      0,
      0,
      0,
      316,
      1272,
      1,
      0,
      0,
      0,
      318,
      1277,
      1,
      0,
      0,
      0,
      320,
      1279,
      1,
      0,
      0,
      0,
      322,
      1285,
      1,
      0,
      0,
      0,
      324,
      1292,
      1,
      0,
      0,
      0,
      326,
      1311,
      1,
      0,
      0,
      0,
      328,
      1314,
      1,
      0,
      0,
      0,
      330,
      331,
      5,
      58,
      0,
      0,
      331,
      5,
      1,
      0,
      0,
      0,
      332,
      333,
      5,
      40,
      0,
      0,
      333,
      7,
      1,
      0,
      0,
      0,
      334,
      335,
      5,
      41,
      0,
      0,
      335,
      9,
      1,
      0,
      0,
      0,
      336,
      337,
      5,
      35,
      0,
      0,
      337,
      11,
      1,
      0,
      0,
      0,
      338,
      339,
      5,
      47,
      0,
      0,
      339,
      13,
      1,
      0,
      0,
      0,
      340,
      341,
      5,
      92,
      0,
      0,
      341,
      15,
      1,
      0,
      0,
      0,
      342,
      343,
      5,
      94,
      0,
      0,
      343,
      17,
      1,
      0,
      0,
      0,
      344,
      345,
      5,
      45,
      0,
      0,
      345,
      19,
      1,
      0,
      0,
      0,
      346,
      347,
      5,
      43,
      0,
      0,
      347,
      21,
      1,
      0,
      0,
      0,
      348,
      349,
      5,
      42,
      0,
      0,
      349,
      23,
      1,
      0,
      0,
      0,
      350,
      351,
      5,
      44,
      0,
      0,
      351,
      25,
      1,
      0,
      0,
      0,
      352,
      353,
      5,
      59,
      0,
      0,
      353,
      27,
      1,
      0,
      0,
      0,
      354,
      355,
      5,
      60,
      0,
      0,
      355,
      29,
      1,
      0,
      0,
      0,
      356,
      357,
      5,
      60,
      0,
      0,
      357,
      358,
      5,
      61,
      0,
      0,
      358,
      31,
      1,
      0,
      0,
      0,
      359,
      360,
      5,
      60,
      0,
      0,
      360,
      361,
      5,
      62,
      0,
      0,
      361,
      33,
      1,
      0,
      0,
      0,
      362,
      363,
      5,
      61,
      0,
      0,
      363,
      35,
      1,
      0,
      0,
      0,
      364,
      365,
      5,
      62,
      0,
      0,
      365,
      37,
      1,
      0,
      0,
      0,
      366,
      367,
      5,
      62,
      0,
      0,
      367,
      368,
      5,
      61,
      0,
      0,
      368,
      39,
      1,
      0,
      0,
      0,
      369,
      370,
      5,
      38,
      0,
      0,
      370,
      41,
      1,
      0,
      0,
      0,
      371,
      372,
      5,
      37,
      0,
      0,
      372,
      43,
      1,
      0,
      0,
      0,
      373,
      374,
      5,
      46,
      0,
      0,
      374,
      45,
      1,
      0,
      0,
      0,
      375,
      377,
      7,
      0,
      0,
      0,
      376,
      375,
      1,
      0,
      0,
      0,
      377,
      378,
      1,
      0,
      0,
      0,
      378,
      376,
      1,
      0,
      0,
      0,
      378,
      379,
      1,
      0,
      0,
      0,
      379,
      47,
      1,
      0,
      0,
      0,
      380,
      381,
      5,
      38,
      0,
      0,
      381,
      383,
      7,
      1,
      0,
      0,
      382,
      384,
      7,
      2,
      0,
      0,
      383,
      382,
      1,
      0,
      0,
      0,
      384,
      385,
      1,
      0,
      0,
      0,
      385,
      383,
      1,
      0,
      0,
      0,
      385,
      386,
      1,
      0,
      0,
      0,
      386,
      49,
      1,
      0,
      0,
      0,
      387,
      388,
      5,
      38,
      0,
      0,
      388,
      390,
      7,
      3,
      0,
      0,
      389,
      391,
      7,
      4,
      0,
      0,
      390,
      389,
      1,
      0,
      0,
      0,
      391,
      392,
      1,
      0,
      0,
      0,
      392,
      390,
      1,
      0,
      0,
      0,
      392,
      393,
      1,
      0,
      0,
      0,
      393,
      51,
      1,
      0,
      0,
      0,
      394,
      396,
      7,
      0,
      0,
      0,
      395,
      394,
      1,
      0,
      0,
      0,
      396,
      397,
      1,
      0,
      0,
      0,
      397,
      395,
      1,
      0,
      0,
      0,
      397,
      398,
      1,
      0,
      0,
      0,
      398,
      399,
      1,
      0,
      0,
      0,
      399,
      403,
      5,
      46,
      0,
      0,
      400,
      402,
      7,
      0,
      0,
      0,
      401,
      400,
      1,
      0,
      0,
      0,
      402,
      405,
      1,
      0,
      0,
      0,
      403,
      401,
      1,
      0,
      0,
      0,
      403,
      404,
      1,
      0,
      0,
      0,
      404,
      407,
      1,
      0,
      0,
      0,
      405,
      403,
      1,
      0,
      0,
      0,
      406,
      408,
      3,
      54,
      25,
      0,
      407,
      406,
      1,
      0,
      0,
      0,
      407,
      408,
      1,
      0,
      0,
      0,
      408,
      410,
      1,
      0,
      0,
      0,
      409,
      411,
      5,
      33,
      0,
      0,
      410,
      409,
      1,
      0,
      0,
      0,
      410,
      411,
      1,
      0,
      0,
      0,
      411,
      440,
      1,
      0,
      0,
      0,
      412,
      414,
      5,
      46,
      0,
      0,
      413,
      415,
      7,
      0,
      0,
      0,
      414,
      413,
      1,
      0,
      0,
      0,
      415,
      416,
      1,
      0,
      0,
      0,
      416,
      414,
      1,
      0,
      0,
      0,
      416,
      417,
      1,
      0,
      0,
      0,
      417,
      419,
      1,
      0,
      0,
      0,
      418,
      420,
      3,
      54,
      25,
      0,
      419,
      418,
      1,
      0,
      0,
      0,
      419,
      420,
      1,
      0,
      0,
      0,
      420,
      422,
      1,
      0,
      0,
      0,
      421,
      423,
      5,
      33,
      0,
      0,
      422,
      421,
      1,
      0,
      0,
      0,
      422,
      423,
      1,
      0,
      0,
      0,
      423,
      440,
      1,
      0,
      0,
      0,
      424,
      426,
      7,
      0,
      0,
      0,
      425,
      424,
      1,
      0,
      0,
      0,
      426,
      427,
      1,
      0,
      0,
      0,
      427,
      425,
      1,
      0,
      0,
      0,
      427,
      428,
      1,
      0,
      0,
      0,
      428,
      429,
      1,
      0,
      0,
      0,
      429,
      431,
      3,
      54,
      25,
      0,
      430,
      432,
      5,
      33,
      0,
      0,
      431,
      430,
      1,
      0,
      0,
      0,
      431,
      432,
      1,
      0,
      0,
      0,
      432,
      440,
      1,
      0,
      0,
      0,
      433,
      435,
      7,
      0,
      0,
      0,
      434,
      433,
      1,
      0,
      0,
      0,
      435,
      436,
      1,
      0,
      0,
      0,
      436,
      434,
      1,
      0,
      0,
      0,
      436,
      437,
      1,
      0,
      0,
      0,
      437,
      438,
      1,
      0,
      0,
      0,
      438,
      440,
      5,
      33,
      0,
      0,
      439,
      395,
      1,
      0,
      0,
      0,
      439,
      412,
      1,
      0,
      0,
      0,
      439,
      425,
      1,
      0,
      0,
      0,
      439,
      434,
      1,
      0,
      0,
      0,
      440,
      53,
      1,
      0,
      0,
      0,
      441,
      443,
      7,
      5,
      0,
      0,
      442,
      444,
      7,
      6,
      0,
      0,
      443,
      442,
      1,
      0,
      0,
      0,
      443,
      444,
      1,
      0,
      0,
      0,
      444,
      446,
      1,
      0,
      0,
      0,
      445,
      447,
      7,
      0,
      0,
      0,
      446,
      445,
      1,
      0,
      0,
      0,
      447,
      448,
      1,
      0,
      0,
      0,
      448,
      446,
      1,
      0,
      0,
      0,
      448,
      449,
      1,
      0,
      0,
      0,
      449,
      55,
      1,
      0,
      0,
      0,
      450,
      452,
      7,
      0,
      0,
      0,
      451,
      450,
      1,
      0,
      0,
      0,
      452,
      453,
      1,
      0,
      0,
      0,
      453,
      451,
      1,
      0,
      0,
      0,
      453,
      454,
      1,
      0,
      0,
      0,
      454,
      455,
      1,
      0,
      0,
      0,
      455,
      459,
      5,
      46,
      0,
      0,
      456,
      458,
      7,
      0,
      0,
      0,
      457,
      456,
      1,
      0,
      0,
      0,
      458,
      461,
      1,
      0,
      0,
      0,
      459,
      457,
      1,
      0,
      0,
      0,
      459,
      460,
      1,
      0,
      0,
      0,
      460,
      464,
      1,
      0,
      0,
      0,
      461,
      459,
      1,
      0,
      0,
      0,
      462,
      465,
      3,
      58,
      27,
      0,
      463,
      465,
      5,
      35,
      0,
      0,
      464,
      462,
      1,
      0,
      0,
      0,
      464,
      463,
      1,
      0,
      0,
      0,
      465,
      486,
      1,
      0,
      0,
      0,
      466,
      468,
      5,
      46,
      0,
      0,
      467,
      469,
      7,
      0,
      0,
      0,
      468,
      467,
      1,
      0,
      0,
      0,
      469,
      470,
      1,
      0,
      0,
      0,
      470,
      468,
      1,
      0,
      0,
      0,
      470,
      471,
      1,
      0,
      0,
      0,
      471,
      474,
      1,
      0,
      0,
      0,
      472,
      475,
      3,
      58,
      27,
      0,
      473,
      475,
      5,
      35,
      0,
      0,
      474,
      472,
      1,
      0,
      0,
      0,
      474,
      473,
      1,
      0,
      0,
      0,
      475,
      486,
      1,
      0,
      0,
      0,
      476,
      478,
      7,
      0,
      0,
      0,
      477,
      476,
      1,
      0,
      0,
      0,
      478,
      479,
      1,
      0,
      0,
      0,
      479,
      477,
      1,
      0,
      0,
      0,
      479,
      480,
      1,
      0,
      0,
      0,
      480,
      483,
      1,
      0,
      0,
      0,
      481,
      484,
      3,
      58,
      27,
      0,
      482,
      484,
      5,
      35,
      0,
      0,
      483,
      481,
      1,
      0,
      0,
      0,
      483,
      482,
      1,
      0,
      0,
      0,
      484,
      486,
      1,
      0,
      0,
      0,
      485,
      451,
      1,
      0,
      0,
      0,
      485,
      466,
      1,
      0,
      0,
      0,
      485,
      477,
      1,
      0,
      0,
      0,
      486,
      57,
      1,
      0,
      0,
      0,
      487,
      489,
      7,
      7,
      0,
      0,
      488,
      490,
      7,
      6,
      0,
      0,
      489,
      488,
      1,
      0,
      0,
      0,
      489,
      490,
      1,
      0,
      0,
      0,
      490,
      492,
      1,
      0,
      0,
      0,
      491,
      493,
      7,
      0,
      0,
      0,
      492,
      491,
      1,
      0,
      0,
      0,
      493,
      494,
      1,
      0,
      0,
      0,
      494,
      492,
      1,
      0,
      0,
      0,
      494,
      495,
      1,
      0,
      0,
      0,
      495,
      497,
      1,
      0,
      0,
      0,
      496,
      498,
      5,
      35,
      0,
      0,
      497,
      496,
      1,
      0,
      0,
      0,
      497,
      498,
      1,
      0,
      0,
      0,
      498,
      59,
      1,
      0,
      0,
      0,
      499,
      503,
      5,
      34,
      0,
      0,
      500,
      502,
      8,
      8,
      0,
      0,
      501,
      500,
      1,
      0,
      0,
      0,
      502,
      505,
      1,
      0,
      0,
      0,
      503,
      501,
      1,
      0,
      0,
      0,
      503,
      504,
      1,
      0,
      0,
      0,
      504,
      506,
      1,
      0,
      0,
      0,
      505,
      503,
      1,
      0,
      0,
      0,
      506,
      507,
      5,
      34,
      0,
      0,
      507,
      61,
      1,
      0,
      0,
      0,
      508,
      509,
      7,
      9,
      0,
      0,
      509,
      510,
      7,
      10,
      0,
      0,
      510,
      511,
      7,
      11,
      0,
      0,
      511,
      512,
      7,
      3,
      0,
      0,
      512,
      513,
      7,
      12,
      0,
      0,
      513,
      514,
      7,
      13,
      0,
      0,
      514,
      515,
      7,
      14,
      0,
      0,
      515,
      516,
      7,
      5,
      0,
      0,
      516,
      63,
      1,
      0,
      0,
      0,
      517,
      518,
      7,
      9,
      0,
      0,
      518,
      519,
      7,
      15,
      0,
      0,
      519,
      520,
      7,
      15,
      0,
      0,
      520,
      521,
      7,
      5,
      0,
      0,
      521,
      522,
      7,
      11,
      0,
      0,
      522,
      523,
      7,
      11,
      0,
      0,
      523,
      65,
      1,
      0,
      0,
      0,
      524,
      525,
      7,
      9,
      0,
      0,
      525,
      526,
      7,
      16,
      0,
      0,
      526,
      527,
      7,
      7,
      0,
      0,
      527,
      67,
      1,
      0,
      0,
      0,
      528,
      529,
      7,
      9,
      0,
      0,
      529,
      530,
      7,
      16,
      0,
      0,
      530,
      531,
      7,
      17,
      0,
      0,
      531,
      69,
      1,
      0,
      0,
      0,
      532,
      533,
      7,
      9,
      0,
      0,
      533,
      534,
      7,
      18,
      0,
      0,
      534,
      535,
      7,
      18,
      0,
      0,
      535,
      536,
      7,
      5,
      0,
      0,
      536,
      537,
      7,
      16,
      0,
      0,
      537,
      538,
      7,
      7,
      0,
      0,
      538,
      71,
      1,
      0,
      0,
      0,
      539,
      540,
      7,
      9,
      0,
      0,
      540,
      541,
      7,
      11,
      0,
      0,
      541,
      73,
      1,
      0,
      0,
      0,
      542,
      543,
      7,
      10,
      0,
      0,
      543,
      544,
      7,
      9,
      0,
      0,
      544,
      545,
      7,
      11,
      0,
      0,
      545,
      546,
      7,
      5,
      0,
      0,
      546,
      75,
      1,
      0,
      0,
      0,
      547,
      548,
      7,
      10,
      0,
      0,
      548,
      549,
      7,
      19,
      0,
      0,
      549,
      550,
      7,
      16,
      0,
      0,
      550,
      551,
      7,
      9,
      0,
      0,
      551,
      552,
      7,
      20,
      0,
      0,
      552,
      553,
      7,
      17,
      0,
      0,
      553,
      77,
      1,
      0,
      0,
      0,
      554,
      555,
      7,
      15,
      0,
      0,
      555,
      556,
      7,
      9,
      0,
      0,
      556,
      557,
      7,
      12,
      0,
      0,
      557,
      558,
      7,
      12,
      0,
      0,
      558,
      79,
      1,
      0,
      0,
      0,
      559,
      560,
      7,
      15,
      0,
      0,
      560,
      561,
      7,
      9,
      0,
      0,
      561,
      562,
      7,
      11,
      0,
      0,
      562,
      563,
      7,
      5,
      0,
      0,
      563,
      81,
      1,
      0,
      0,
      0,
      564,
      565,
      7,
      15,
      0,
      0,
      565,
      566,
      7,
      19,
      0,
      0,
      566,
      567,
      7,
      20,
      0,
      0,
      567,
      568,
      7,
      15,
      0,
      0,
      568,
      569,
      7,
      12,
      0,
      0,
      569,
      570,
      7,
      5,
      0,
      0,
      570,
      83,
      1,
      0,
      0,
      0,
      571,
      572,
      7,
      15,
      0,
      0,
      572,
      573,
      7,
      12,
      0,
      0,
      573,
      574,
      7,
      5,
      0,
      0,
      574,
      575,
      7,
      9,
      0,
      0,
      575,
      576,
      7,
      20,
      0,
      0,
      576,
      85,
      1,
      0,
      0,
      0,
      577,
      578,
      7,
      15,
      0,
      0,
      578,
      579,
      7,
      12,
      0,
      0,
      579,
      580,
      7,
      3,
      0,
      0,
      580,
      581,
      7,
      11,
      0,
      0,
      581,
      582,
      7,
      5,
      0,
      0,
      582,
      87,
      1,
      0,
      0,
      0,
      583,
      584,
      7,
      15,
      0,
      0,
      584,
      585,
      7,
      3,
      0,
      0,
      585,
      586,
      7,
      12,
      0,
      0,
      586,
      587,
      7,
      3,
      0,
      0,
      587,
      588,
      7,
      20,
      0,
      0,
      588,
      89,
      1,
      0,
      0,
      0,
      589,
      590,
      7,
      15,
      0,
      0,
      590,
      591,
      7,
      3,
      0,
      0,
      591,
      592,
      7,
      21,
      0,
      0,
      592,
      91,
      1,
      0,
      0,
      0,
      593,
      594,
      7,
      15,
      0,
      0,
      594,
      595,
      7,
      3,
      0,
      0,
      595,
      596,
      7,
      21,
      0,
      0,
      596,
      597,
      7,
      21,
      0,
      0,
      597,
      598,
      7,
      3,
      0,
      0,
      598,
      599,
      7,
      16,
      0,
      0,
      599,
      93,
      1,
      0,
      0,
      0,
      600,
      601,
      7,
      15,
      0,
      0,
      601,
      602,
      7,
      3,
      0,
      0,
      602,
      603,
      7,
      16,
      0,
      0,
      603,
      604,
      7,
      11,
      0,
      0,
      604,
      605,
      7,
      14,
      0,
      0,
      605,
      95,
      1,
      0,
      0,
      0,
      606,
      607,
      7,
      7,
      0,
      0,
      607,
      608,
      7,
      9,
      0,
      0,
      608,
      609,
      7,
      14,
      0,
      0,
      609,
      610,
      7,
      9,
      0,
      0,
      610,
      611,
      1,
      0,
      0,
      0,
      611,
      612,
      6,
      46,
      0,
      0,
      612,
      97,
      1,
      0,
      0,
      0,
      613,
      614,
      7,
      7,
      0,
      0,
      614,
      615,
      7,
      5,
      0,
      0,
      615,
      616,
      7,
      15,
      0,
      0,
      616,
      617,
      7,
      12,
      0,
      0,
      617,
      618,
      7,
      9,
      0,
      0,
      618,
      619,
      7,
      20,
      0,
      0,
      619,
      620,
      7,
      5,
      0,
      0,
      620,
      99,
      1,
      0,
      0,
      0,
      621,
      622,
      7,
      7,
      0,
      0,
      622,
      623,
      7,
      5,
      0,
      0,
      623,
      624,
      7,
      22,
      0,
      0,
      624,
      101,
      1,
      0,
      0,
      0,
      625,
      626,
      7,
      7,
      0,
      0,
      626,
      627,
      7,
      5,
      0,
      0,
      627,
      628,
      7,
      22,
      0,
      0,
      628,
      629,
      7,
      7,
      0,
      0,
      629,
      630,
      7,
      10,
      0,
      0,
      630,
      631,
      7,
      12,
      0,
      0,
      631,
      103,
      1,
      0,
      0,
      0,
      632,
      633,
      7,
      7,
      0,
      0,
      633,
      634,
      7,
      5,
      0,
      0,
      634,
      635,
      7,
      22,
      0,
      0,
      635,
      636,
      7,
      19,
      0,
      0,
      636,
      637,
      7,
      16,
      0,
      0,
      637,
      638,
      7,
      14,
      0,
      0,
      638,
      105,
      1,
      0,
      0,
      0,
      639,
      640,
      7,
      7,
      0,
      0,
      640,
      641,
      7,
      5,
      0,
      0,
      641,
      642,
      7,
      22,
      0,
      0,
      642,
      643,
      7,
      12,
      0,
      0,
      643,
      644,
      7,
      16,
      0,
      0,
      644,
      645,
      7,
      23,
      0,
      0,
      645,
      107,
      1,
      0,
      0,
      0,
      646,
      647,
      7,
      7,
      0,
      0,
      647,
      648,
      7,
      5,
      0,
      0,
      648,
      649,
      7,
      22,
      0,
      0,
      649,
      650,
      7,
      11,
      0,
      0,
      650,
      651,
      7,
      16,
      0,
      0,
      651,
      652,
      7,
      23,
      0,
      0,
      652,
      109,
      1,
      0,
      0,
      0,
      653,
      654,
      7,
      7,
      0,
      0,
      654,
      655,
      7,
      5,
      0,
      0,
      655,
      656,
      7,
      22,
      0,
      0,
      656,
      657,
      7,
      11,
      0,
      0,
      657,
      658,
      7,
      14,
      0,
      0,
      658,
      659,
      7,
      20,
      0,
      0,
      659,
      111,
      1,
      0,
      0,
      0,
      660,
      661,
      7,
      7,
      0,
      0,
      661,
      662,
      7,
      19,
      0,
      0,
      662,
      663,
      7,
      21,
      0,
      0,
      663,
      113,
      1,
      0,
      0,
      0,
      664,
      665,
      7,
      7,
      0,
      0,
      665,
      666,
      7,
      3,
      0,
      0,
      666,
      115,
      1,
      0,
      0,
      0,
      667,
      668,
      7,
      7,
      0,
      0,
      668,
      669,
      7,
      3,
      0,
      0,
      669,
      670,
      7,
      13,
      0,
      0,
      670,
      671,
      7,
      10,
      0,
      0,
      671,
      672,
      7,
      12,
      0,
      0,
      672,
      673,
      7,
      5,
      0,
      0,
      673,
      117,
      1,
      0,
      0,
      0,
      674,
      675,
      7,
      5,
      0,
      0,
      675,
      676,
      7,
      12,
      0,
      0,
      676,
      677,
      7,
      11,
      0,
      0,
      677,
      678,
      7,
      5,
      0,
      0,
      678,
      119,
      1,
      0,
      0,
      0,
      679,
      680,
      7,
      5,
      0,
      0,
      680,
      681,
      7,
      12,
      0,
      0,
      681,
      682,
      7,
      11,
      0,
      0,
      682,
      683,
      7,
      5,
      0,
      0,
      683,
      684,
      7,
      19,
      0,
      0,
      684,
      685,
      7,
      22,
      0,
      0,
      685,
      121,
      1,
      0,
      0,
      0,
      686,
      687,
      7,
      5,
      0,
      0,
      687,
      688,
      7,
      24,
      0,
      0,
      688,
      689,
      7,
      25,
      0,
      0,
      689,
      123,
      1,
      0,
      0,
      0,
      690,
      691,
      7,
      5,
      0,
      0,
      691,
      692,
      7,
      20,
      0,
      0,
      692,
      693,
      7,
      20,
      0,
      0,
      693,
      694,
      7,
      3,
      0,
      0,
      694,
      695,
      7,
      20,
      0,
      0,
      695,
      125,
      1,
      0,
      0,
      0,
      696,
      697,
      7,
      5,
      0,
      0,
      697,
      698,
      7,
      16,
      0,
      0,
      698,
      699,
      7,
      7,
      0,
      0,
      699,
      127,
      1,
      0,
      0,
      0,
      700,
      701,
      7,
      5,
      0,
      0,
      701,
      702,
      7,
      26,
      0,
      0,
      702,
      703,
      7,
      19,
      0,
      0,
      703,
      704,
      7,
      14,
      0,
      0,
      704,
      129,
      1,
      0,
      0,
      0,
      705,
      706,
      7,
      22,
      0,
      0,
      706,
      707,
      7,
      19,
      0,
      0,
      707,
      708,
      7,
      5,
      0,
      0,
      708,
      709,
      7,
      12,
      0,
      0,
      709,
      710,
      7,
      7,
      0,
      0,
      710,
      131,
      1,
      0,
      0,
      0,
      711,
      712,
      7,
      22,
      0,
      0,
      712,
      713,
      7,
      3,
      0,
      0,
      713,
      714,
      7,
      20,
      0,
      0,
      714,
      133,
      1,
      0,
      0,
      0,
      715,
      716,
      7,
      22,
      0,
      0,
      716,
      717,
      7,
      16,
      0,
      0,
      717,
      135,
      1,
      0,
      0,
      0,
      718,
      719,
      7,
      22,
      0,
      0,
      719,
      720,
      7,
      13,
      0,
      0,
      720,
      721,
      7,
      16,
      0,
      0,
      721,
      722,
      7,
      15,
      0,
      0,
      722,
      723,
      7,
      14,
      0,
      0,
      723,
      724,
      7,
      19,
      0,
      0,
      724,
      725,
      7,
      3,
      0,
      0,
      725,
      726,
      7,
      16,
      0,
      0,
      726,
      137,
      1,
      0,
      0,
      0,
      727,
      728,
      7,
      23,
      0,
      0,
      728,
      729,
      7,
      5,
      0,
      0,
      729,
      730,
      7,
      14,
      0,
      0,
      730,
      139,
      1,
      0,
      0,
      0,
      731,
      732,
      7,
      23,
      0,
      0,
      732,
      733,
      7,
      3,
      0,
      0,
      733,
      734,
      7,
      11,
      0,
      0,
      734,
      735,
      7,
      13,
      0,
      0,
      735,
      736,
      7,
      10,
      0,
      0,
      736,
      141,
      1,
      0,
      0,
      0,
      737,
      738,
      7,
      23,
      0,
      0,
      738,
      739,
      7,
      3,
      0,
      0,
      739,
      740,
      7,
      14,
      0,
      0,
      740,
      741,
      7,
      3,
      0,
      0,
      741,
      143,
      1,
      0,
      0,
      0,
      742,
      743,
      7,
      19,
      0,
      0,
      743,
      744,
      7,
      22,
      0,
      0,
      744,
      145,
      1,
      0,
      0,
      0,
      745,
      746,
      7,
      19,
      0,
      0,
      746,
      747,
      7,
      21,
      0,
      0,
      747,
      748,
      7,
      18,
      0,
      0,
      748,
      147,
      1,
      0,
      0,
      0,
      749,
      750,
      7,
      19,
      0,
      0,
      750,
      751,
      7,
      16,
      0,
      0,
      751,
      752,
      7,
      18,
      0,
      0,
      752,
      753,
      7,
      13,
      0,
      0,
      753,
      754,
      7,
      14,
      0,
      0,
      754,
      149,
      1,
      0,
      0,
      0,
      755,
      756,
      7,
      19,
      0,
      0,
      756,
      757,
      7,
      16,
      0,
      0,
      757,
      758,
      7,
      18,
      0,
      0,
      758,
      759,
      7,
      13,
      0,
      0,
      759,
      760,
      7,
      14,
      0,
      0,
      760,
      761,
      5,
      36,
      0,
      0,
      761,
      151,
      1,
      0,
      0,
      0,
      762,
      763,
      7,
      19,
      0,
      0,
      763,
      764,
      7,
      3,
      0,
      0,
      764,
      765,
      7,
      15,
      0,
      0,
      765,
      766,
      7,
      14,
      0,
      0,
      766,
      767,
      7,
      12,
      0,
      0,
      767,
      153,
      1,
      0,
      0,
      0,
      768,
      769,
      7,
      19,
      0,
      0,
      769,
      770,
      7,
      3,
      0,
      0,
      770,
      771,
      7,
      15,
      0,
      0,
      771,
      772,
      7,
      14,
      0,
      0,
      772,
      773,
      7,
      12,
      0,
      0,
      773,
      774,
      5,
      36,
      0,
      0,
      774,
      155,
      1,
      0,
      0,
      0,
      775,
      776,
      7,
      19,
      0,
      0,
      776,
      777,
      7,
      11,
      0,
      0,
      777,
      157,
      1,
      0,
      0,
      0,
      778,
      779,
      7,
      19,
      0,
      0,
      779,
      780,
      7,
      16,
      0,
      0,
      780,
      781,
      7,
      14,
      0,
      0,
      781,
      782,
      7,
      5,
      0,
      0,
      782,
      783,
      7,
      23,
      0,
      0,
      783,
      784,
      7,
      5,
      0,
      0,
      784,
      785,
      7,
      20,
      0,
      0,
      785,
      159,
      1,
      0,
      0,
      0,
      786,
      787,
      7,
      27,
      0,
      0,
      787,
      788,
      7,
      5,
      0,
      0,
      788,
      789,
      7,
      17,
      0,
      0,
      789,
      161,
      1,
      0,
      0,
      0,
      790,
      791,
      7,
      12,
      0,
      0,
      791,
      792,
      7,
      5,
      0,
      0,
      792,
      793,
      7,
      16,
      0,
      0,
      793,
      163,
      1,
      0,
      0,
      0,
      794,
      795,
      7,
      12,
      0,
      0,
      795,
      796,
      7,
      5,
      0,
      0,
      796,
      797,
      7,
      14,
      0,
      0,
      797,
      165,
      1,
      0,
      0,
      0,
      798,
      799,
      7,
      12,
      0,
      0,
      799,
      800,
      7,
      19,
      0,
      0,
      800,
      801,
      7,
      16,
      0,
      0,
      801,
      802,
      7,
      5,
      0,
      0,
      802,
      167,
      1,
      0,
      0,
      0,
      803,
      804,
      7,
      12,
      0,
      0,
      804,
      805,
      7,
      19,
      0,
      0,
      805,
      806,
      7,
      11,
      0,
      0,
      806,
      807,
      7,
      14,
      0,
      0,
      807,
      169,
      1,
      0,
      0,
      0,
      808,
      809,
      7,
      12,
      0,
      0,
      809,
      810,
      7,
      3,
      0,
      0,
      810,
      811,
      7,
      15,
      0,
      0,
      811,
      812,
      7,
      9,
      0,
      0,
      812,
      813,
      7,
      14,
      0,
      0,
      813,
      814,
      7,
      5,
      0,
      0,
      814,
      171,
      1,
      0,
      0,
      0,
      815,
      816,
      7,
      12,
      0,
      0,
      816,
      817,
      7,
      3,
      0,
      0,
      817,
      818,
      7,
      15,
      0,
      0,
      818,
      819,
      7,
      27,
      0,
      0,
      819,
      173,
      1,
      0,
      0,
      0,
      820,
      821,
      7,
      12,
      0,
      0,
      821,
      822,
      7,
      3,
      0,
      0,
      822,
      823,
      7,
      16,
      0,
      0,
      823,
      824,
      7,
      23,
      0,
      0,
      824,
      175,
      1,
      0,
      0,
      0,
      825,
      826,
      7,
      12,
      0,
      0,
      826,
      827,
      7,
      3,
      0,
      0,
      827,
      828,
      7,
      3,
      0,
      0,
      828,
      829,
      7,
      18,
      0,
      0,
      829,
      177,
      1,
      0,
      0,
      0,
      830,
      831,
      7,
      12,
      0,
      0,
      831,
      832,
      7,
      18,
      0,
      0,
      832,
      833,
      7,
      20,
      0,
      0,
      833,
      834,
      7,
      19,
      0,
      0,
      834,
      835,
      7,
      16,
      0,
      0,
      835,
      836,
      7,
      14,
      0,
      0,
      836,
      179,
      1,
      0,
      0,
      0,
      837,
      838,
      7,
      12,
      0,
      0,
      838,
      839,
      7,
      11,
      0,
      0,
      839,
      840,
      7,
      5,
      0,
      0,
      840,
      841,
      7,
      14,
      0,
      0,
      841,
      181,
      1,
      0,
      0,
      0,
      842,
      843,
      7,
      21,
      0,
      0,
      843,
      844,
      7,
      19,
      0,
      0,
      844,
      845,
      7,
      7,
      0,
      0,
      845,
      846,
      5,
      36,
      0,
      0,
      846,
      183,
      1,
      0,
      0,
      0,
      847,
      848,
      7,
      21,
      0,
      0,
      848,
      849,
      7,
      3,
      0,
      0,
      849,
      850,
      7,
      7,
      0,
      0,
      850,
      185,
      1,
      0,
      0,
      0,
      851,
      852,
      7,
      16,
      0,
      0,
      852,
      853,
      7,
      9,
      0,
      0,
      853,
      854,
      7,
      21,
      0,
      0,
      854,
      855,
      7,
      5,
      0,
      0,
      855,
      187,
      1,
      0,
      0,
      0,
      856,
      857,
      7,
      16,
      0,
      0,
      857,
      858,
      7,
      5,
      0,
      0,
      858,
      859,
      7,
      26,
      0,
      0,
      859,
      860,
      7,
      14,
      0,
      0,
      860,
      861,
      1,
      0,
      0,
      0,
      861,
      862,
      6,
      92,
      1,
      0,
      862,
      189,
      1,
      0,
      0,
      0,
      863,
      864,
      7,
      16,
      0,
      0,
      864,
      865,
      7,
      3,
      0,
      0,
      865,
      866,
      7,
      14,
      0,
      0,
      866,
      191,
      1,
      0,
      0,
      0,
      867,
      868,
      7,
      3,
      0,
      0,
      868,
      869,
      7,
      18,
      0,
      0,
      869,
      870,
      7,
      14,
      0,
      0,
      870,
      871,
      7,
      19,
      0,
      0,
      871,
      872,
      7,
      3,
      0,
      0,
      872,
      873,
      7,
      16,
      0,
      0,
      873,
      193,
      1,
      0,
      0,
      0,
      874,
      875,
      7,
      3,
      0,
      0,
      875,
      876,
      7,
      22,
      0,
      0,
      876,
      877,
      7,
      22,
      0,
      0,
      877,
      195,
      1,
      0,
      0,
      0,
      878,
      879,
      7,
      3,
      0,
      0,
      879,
      880,
      7,
      18,
      0,
      0,
      880,
      881,
      7,
      5,
      0,
      0,
      881,
      882,
      7,
      16,
      0,
      0,
      882,
      197,
      1,
      0,
      0,
      0,
      883,
      884,
      7,
      3,
      0,
      0,
      884,
      885,
      7,
      13,
      0,
      0,
      885,
      886,
      7,
      14,
      0,
      0,
      886,
      887,
      7,
      18,
      0,
      0,
      887,
      888,
      7,
      13,
      0,
      0,
      888,
      889,
      7,
      14,
      0,
      0,
      889,
      199,
      1,
      0,
      0,
      0,
      890,
      891,
      7,
      3,
      0,
      0,
      891,
      892,
      7,
      20,
      0,
      0,
      892,
      201,
      1,
      0,
      0,
      0,
      893,
      894,
      7,
      3,
      0,
      0,
      894,
      895,
      7,
      16,
      0,
      0,
      895,
      203,
      1,
      0,
      0,
      0,
      896,
      897,
      7,
      18,
      0,
      0,
      897,
      898,
      7,
      9,
      0,
      0,
      898,
      899,
      7,
      19,
      0,
      0,
      899,
      900,
      7,
      16,
      0,
      0,
      900,
      901,
      7,
      14,
      0,
      0,
      901,
      205,
      1,
      0,
      0,
      0,
      902,
      903,
      7,
      18,
      0,
      0,
      903,
      904,
      7,
      9,
      0,
      0,
      904,
      905,
      7,
      12,
      0,
      0,
      905,
      906,
      7,
      5,
      0,
      0,
      906,
      907,
      7,
      14,
      0,
      0,
      907,
      908,
      7,
      14,
      0,
      0,
      908,
      909,
      7,
      5,
      0,
      0,
      909,
      207,
      1,
      0,
      0,
      0,
      910,
      911,
      7,
      18,
      0,
      0,
      911,
      912,
      7,
      5,
      0,
      0,
      912,
      913,
      7,
      16,
      0,
      0,
      913,
      209,
      1,
      0,
      0,
      0,
      914,
      915,
      7,
      18,
      0,
      0,
      915,
      916,
      7,
      12,
      0,
      0,
      916,
      917,
      7,
      9,
      0,
      0,
      917,
      918,
      7,
      17,
      0,
      0,
      918,
      211,
      1,
      0,
      0,
      0,
      919,
      920,
      7,
      18,
      0,
      0,
      920,
      921,
      7,
      20,
      0,
      0,
      921,
      922,
      7,
      19,
      0,
      0,
      922,
      923,
      7,
      16,
      0,
      0,
      923,
      924,
      7,
      14,
      0,
      0,
      924,
      213,
      1,
      0,
      0,
      0,
      925,
      926,
      7,
      18,
      0,
      0,
      926,
      927,
      7,
      20,
      0,
      0,
      927,
      928,
      7,
      5,
      0,
      0,
      928,
      929,
      7,
      11,
      0,
      0,
      929,
      930,
      7,
      5,
      0,
      0,
      930,
      931,
      7,
      14,
      0,
      0,
      931,
      215,
      1,
      0,
      0,
      0,
      932,
      933,
      7,
      18,
      0,
      0,
      933,
      934,
      7,
      11,
      0,
      0,
      934,
      935,
      7,
      5,
      0,
      0,
      935,
      936,
      7,
      14,
      0,
      0,
      936,
      217,
      1,
      0,
      0,
      0,
      937,
      938,
      7,
      18,
      0,
      0,
      938,
      939,
      7,
      13,
      0,
      0,
      939,
      940,
      7,
      14,
      0,
      0,
      940,
      219,
      1,
      0,
      0,
      0,
      941,
      942,
      7,
      20,
      0,
      0,
      942,
      943,
      7,
      9,
      0,
      0,
      943,
      944,
      7,
      16,
      0,
      0,
      944,
      945,
      7,
      7,
      0,
      0,
      945,
      946,
      7,
      3,
      0,
      0,
      946,
      947,
      7,
      21,
      0,
      0,
      947,
      221,
      1,
      0,
      0,
      0,
      948,
      949,
      7,
      20,
      0,
      0,
      949,
      950,
      7,
      5,
      0,
      0,
      950,
      951,
      7,
      9,
      0,
      0,
      951,
      952,
      7,
      7,
      0,
      0,
      952,
      223,
      1,
      0,
      0,
      0,
      953,
      954,
      7,
      20,
      0,
      0,
      954,
      955,
      7,
      5,
      0,
      0,
      955,
      956,
      7,
      7,
      0,
      0,
      956,
      957,
      7,
      19,
      0,
      0,
      957,
      958,
      7,
      21,
      0,
      0,
      958,
      225,
      1,
      0,
      0,
      0,
      959,
      960,
      7,
      20,
      0,
      0,
      960,
      961,
      7,
      5,
      0,
      0,
      961,
      962,
      7,
      21,
      0,
      0,
      962,
      963,
      1,
      0,
      0,
      0,
      963,
      964,
      6,
      111,
      2,
      0,
      964,
      227,
      1,
      0,
      0,
      0,
      965,
      966,
      7,
      20,
      0,
      0,
      966,
      967,
      7,
      5,
      0,
      0,
      967,
      968,
      7,
      11,
      0,
      0,
      968,
      969,
      7,
      13,
      0,
      0,
      969,
      970,
      7,
      21,
      0,
      0,
      970,
      971,
      7,
      5,
      0,
      0,
      971,
      229,
      1,
      0,
      0,
      0,
      972,
      973,
      7,
      20,
      0,
      0,
      973,
      974,
      7,
      5,
      0,
      0,
      974,
      975,
      7,
      14,
      0,
      0,
      975,
      976,
      7,
      13,
      0,
      0,
      976,
      977,
      7,
      20,
      0,
      0,
      977,
      978,
      7,
      16,
      0,
      0,
      978,
      231,
      1,
      0,
      0,
      0,
      979,
      980,
      7,
      20,
      0,
      0,
      980,
      981,
      7,
      11,
      0,
      0,
      981,
      982,
      7,
      5,
      0,
      0,
      982,
      983,
      7,
      14,
      0,
      0,
      983,
      233,
      1,
      0,
      0,
      0,
      984,
      985,
      7,
      11,
      0,
      0,
      985,
      986,
      7,
      15,
      0,
      0,
      986,
      987,
      7,
      20,
      0,
      0,
      987,
      988,
      7,
      5,
      0,
      0,
      988,
      989,
      7,
      5,
      0,
      0,
      989,
      990,
      7,
      16,
      0,
      0,
      990,
      235,
      1,
      0,
      0,
      0,
      991,
      992,
      7,
      11,
      0,
      0,
      992,
      993,
      7,
      5,
      0,
      0,
      993,
      994,
      7,
      5,
      0,
      0,
      994,
      995,
      7,
      27,
      0,
      0,
      995,
      237,
      1,
      0,
      0,
      0,
      996,
      997,
      7,
      11,
      0,
      0,
      997,
      998,
      7,
      5,
      0,
      0,
      998,
      999,
      7,
      23,
      0,
      0,
      999,
      239,
      1,
      0,
      0,
      0,
      1e3,
      1001,
      7,
      11,
      0,
      0,
      1001,
      1002,
      7,
      5,
      0,
      0,
      1002,
      1003,
      7,
      12,
      0,
      0,
      1003,
      1004,
      7,
      5,
      0,
      0,
      1004,
      1005,
      7,
      15,
      0,
      0,
      1005,
      1006,
      7,
      14,
      0,
      0,
      1006,
      241,
      1,
      0,
      0,
      0,
      1007,
      1008,
      7,
      11,
      0,
      0,
      1008,
      1009,
      7,
      1,
      0,
      0,
      1009,
      1010,
      7,
      9,
      0,
      0,
      1010,
      1011,
      7,
      20,
      0,
      0,
      1011,
      1012,
      7,
      5,
      0,
      0,
      1012,
      1013,
      7,
      7,
      0,
      0,
      1013,
      243,
      1,
      0,
      0,
      0,
      1014,
      1015,
      7,
      11,
      0,
      0,
      1015,
      1016,
      7,
      19,
      0,
      0,
      1016,
      1017,
      7,
      16,
      0,
      0,
      1017,
      1018,
      7,
      23,
      0,
      0,
      1018,
      1019,
      7,
      12,
      0,
      0,
      1019,
      1020,
      7,
      5,
      0,
      0,
      1020,
      245,
      1,
      0,
      0,
      0,
      1021,
      1022,
      7,
      11,
      0,
      0,
      1022,
      1023,
      7,
      14,
      0,
      0,
      1023,
      1024,
      7,
      9,
      0,
      0,
      1024,
      1025,
      7,
      14,
      0,
      0,
      1025,
      1026,
      7,
      19,
      0,
      0,
      1026,
      1027,
      7,
      15,
      0,
      0,
      1027,
      247,
      1,
      0,
      0,
      0,
      1028,
      1029,
      7,
      11,
      0,
      0,
      1029,
      1030,
      7,
      14,
      0,
      0,
      1030,
      1031,
      7,
      5,
      0,
      0,
      1031,
      1032,
      7,
      18,
      0,
      0,
      1032,
      249,
      1,
      0,
      0,
      0,
      1033,
      1034,
      7,
      11,
      0,
      0,
      1034,
      1035,
      7,
      14,
      0,
      0,
      1035,
      1036,
      7,
      3,
      0,
      0,
      1036,
      1037,
      7,
      18,
      0,
      0,
      1037,
      251,
      1,
      0,
      0,
      0,
      1038,
      1039,
      7,
      11,
      0,
      0,
      1039,
      1040,
      7,
      14,
      0,
      0,
      1040,
      1041,
      7,
      20,
      0,
      0,
      1041,
      1042,
      7,
      19,
      0,
      0,
      1042,
      1043,
      7,
      23,
      0,
      0,
      1043,
      253,
      1,
      0,
      0,
      0,
      1044,
      1045,
      7,
      11,
      0,
      0,
      1045,
      1046,
      7,
      14,
      0,
      0,
      1046,
      1047,
      7,
      20,
      0,
      0,
      1047,
      1048,
      7,
      19,
      0,
      0,
      1048,
      1049,
      7,
      16,
      0,
      0,
      1049,
      1050,
      7,
      23,
      0,
      0,
      1050,
      255,
      1,
      0,
      0,
      0,
      1051,
      1052,
      7,
      11,
      0,
      0,
      1052,
      1053,
      7,
      13,
      0,
      0,
      1053,
      1054,
      7,
      10,
      0,
      0,
      1054,
      257,
      1,
      0,
      0,
      0,
      1055,
      1056,
      7,
      14,
      0,
      0,
      1056,
      1057,
      7,
      1,
      0,
      0,
      1057,
      1058,
      7,
      5,
      0,
      0,
      1058,
      1059,
      7,
      16,
      0,
      0,
      1059,
      259,
      1,
      0,
      0,
      0,
      1060,
      1061,
      7,
      14,
      0,
      0,
      1061,
      1062,
      7,
      3,
      0,
      0,
      1062,
      261,
      1,
      0,
      0,
      0,
      1063,
      1064,
      7,
      14,
      0,
      0,
      1064,
      1065,
      7,
      17,
      0,
      0,
      1065,
      1066,
      7,
      18,
      0,
      0,
      1066,
      1067,
      7,
      5,
      0,
      0,
      1067,
      263,
      1,
      0,
      0,
      0,
      1068,
      1069,
      7,
      14,
      0,
      0,
      1069,
      1070,
      7,
      19,
      0,
      0,
      1070,
      1071,
      7,
      21,
      0,
      0,
      1071,
      1072,
      7,
      5,
      0,
      0,
      1072,
      1073,
      7,
      20,
      0,
      0,
      1073,
      265,
      1,
      0,
      0,
      0,
      1074,
      1075,
      7,
      13,
      0,
      0,
      1075,
      1076,
      7,
      16,
      0,
      0,
      1076,
      1077,
      7,
      12,
      0,
      0,
      1077,
      1078,
      7,
      3,
      0,
      0,
      1078,
      1079,
      7,
      15,
      0,
      0,
      1079,
      1080,
      7,
      27,
      0,
      0,
      1080,
      267,
      1,
      0,
      0,
      0,
      1081,
      1082,
      7,
      13,
      0,
      0,
      1082,
      1083,
      7,
      16,
      0,
      0,
      1083,
      1084,
      7,
      14,
      0,
      0,
      1084,
      1085,
      7,
      19,
      0,
      0,
      1085,
      1086,
      7,
      12,
      0,
      0,
      1086,
      269,
      1,
      0,
      0,
      0,
      1087,
      1088,
      7,
      13,
      0,
      0,
      1088,
      1089,
      7,
      11,
      0,
      0,
      1089,
      1090,
      7,
      19,
      0,
      0,
      1090,
      1091,
      7,
      16,
      0,
      0,
      1091,
      1092,
      7,
      23,
      0,
      0,
      1092,
      271,
      1,
      0,
      0,
      0,
      1093,
      1094,
      7,
      25,
      0,
      0,
      1094,
      1095,
      7,
      19,
      0,
      0,
      1095,
      1096,
      7,
      5,
      0,
      0,
      1096,
      1097,
      7,
      28,
      0,
      0,
      1097,
      273,
      1,
      0,
      0,
      0,
      1098,
      1099,
      7,
      28,
      0,
      0,
      1099,
      1100,
      7,
      5,
      0,
      0,
      1100,
      1101,
      7,
      16,
      0,
      0,
      1101,
      1102,
      7,
      7,
      0,
      0,
      1102,
      275,
      1,
      0,
      0,
      0,
      1103,
      1104,
      7,
      28,
      0,
      0,
      1104,
      1105,
      7,
      1,
      0,
      0,
      1105,
      1106,
      7,
      19,
      0,
      0,
      1106,
      1107,
      7,
      12,
      0,
      0,
      1107,
      1108,
      7,
      5,
      0,
      0,
      1108,
      277,
      1,
      0,
      0,
      0,
      1109,
      1110,
      7,
      28,
      0,
      0,
      1110,
      1111,
      7,
      19,
      0,
      0,
      1111,
      1112,
      7,
      7,
      0,
      0,
      1112,
      1113,
      7,
      14,
      0,
      0,
      1113,
      1114,
      7,
      1,
      0,
      0,
      1114,
      279,
      1,
      0,
      0,
      0,
      1115,
      1116,
      7,
      28,
      0,
      0,
      1116,
      1117,
      7,
      19,
      0,
      0,
      1117,
      1118,
      7,
      16,
      0,
      0,
      1118,
      1119,
      7,
      7,
      0,
      0,
      1119,
      1120,
      7,
      3,
      0,
      0,
      1120,
      1121,
      7,
      28,
      0,
      0,
      1121,
      281,
      1,
      0,
      0,
      0,
      1122,
      1123,
      7,
      28,
      0,
      0,
      1123,
      1124,
      7,
      20,
      0,
      0,
      1124,
      1125,
      7,
      19,
      0,
      0,
      1125,
      1126,
      7,
      14,
      0,
      0,
      1126,
      1127,
      7,
      5,
      0,
      0,
      1127,
      283,
      1,
      0,
      0,
      0,
      1128,
      1129,
      7,
      26,
      0,
      0,
      1129,
      1130,
      7,
      3,
      0,
      0,
      1130,
      1131,
      7,
      20,
      0,
      0,
      1131,
      285,
      1,
      0,
      0,
      0,
      1132,
      1133,
      7,
      22,
      0,
      0,
      1133,
      1134,
      7,
      16,
      0,
      0,
      1134,
      1138,
      7,
      29,
      0,
      0,
      1135,
      1137,
      7,
      30,
      0,
      0,
      1136,
      1135,
      1,
      0,
      0,
      0,
      1137,
      1140,
      1,
      0,
      0,
      0,
      1138,
      1136,
      1,
      0,
      0,
      0,
      1138,
      1139,
      1,
      0,
      0,
      0,
      1139,
      1142,
      1,
      0,
      0,
      0,
      1140,
      1138,
      1,
      0,
      0,
      0,
      1141,
      1143,
      3,
      290,
      143,
      0,
      1142,
      1141,
      1,
      0,
      0,
      0,
      1142,
      1143,
      1,
      0,
      0,
      0,
      1143,
      287,
      1,
      0,
      0,
      0,
      1144,
      1148,
      7,
      31,
      0,
      0,
      1145,
      1147,
      7,
      30,
      0,
      0,
      1146,
      1145,
      1,
      0,
      0,
      0,
      1147,
      1150,
      1,
      0,
      0,
      0,
      1148,
      1146,
      1,
      0,
      0,
      0,
      1148,
      1149,
      1,
      0,
      0,
      0,
      1149,
      1152,
      1,
      0,
      0,
      0,
      1150,
      1148,
      1,
      0,
      0,
      0,
      1151,
      1153,
      3,
      290,
      143,
      0,
      1152,
      1151,
      1,
      0,
      0,
      0,
      1152,
      1153,
      1,
      0,
      0,
      0,
      1153,
      1170,
      1,
      0,
      0,
      0,
      1154,
      1155,
      7,
      22,
      0,
      0,
      1155,
      1159,
      7,
      32,
      0,
      0,
      1156,
      1158,
      7,
      30,
      0,
      0,
      1157,
      1156,
      1,
      0,
      0,
      0,
      1158,
      1161,
      1,
      0,
      0,
      0,
      1159,
      1157,
      1,
      0,
      0,
      0,
      1159,
      1160,
      1,
      0,
      0,
      0,
      1160,
      1163,
      1,
      0,
      0,
      0,
      1161,
      1159,
      1,
      0,
      0,
      0,
      1162,
      1164,
      3,
      290,
      143,
      0,
      1163,
      1162,
      1,
      0,
      0,
      0,
      1163,
      1164,
      1,
      0,
      0,
      0,
      1164,
      1170,
      1,
      0,
      0,
      0,
      1165,
      1167,
      7,
      22,
      0,
      0,
      1166,
      1168,
      3,
      290,
      143,
      0,
      1167,
      1166,
      1,
      0,
      0,
      0,
      1167,
      1168,
      1,
      0,
      0,
      0,
      1168,
      1170,
      1,
      0,
      0,
      0,
      1169,
      1144,
      1,
      0,
      0,
      0,
      1169,
      1154,
      1,
      0,
      0,
      0,
      1169,
      1165,
      1,
      0,
      0,
      0,
      1170,
      289,
      1,
      0,
      0,
      0,
      1171,
      1172,
      7,
      33,
      0,
      0,
      1172,
      291,
      1,
      0,
      0,
      0,
      1173,
      1175,
      5,
      95,
      0,
      0,
      1174,
      1176,
      5,
      13,
      0,
      0,
      1175,
      1174,
      1,
      0,
      0,
      0,
      1175,
      1176,
      1,
      0,
      0,
      0,
      1176,
      1177,
      1,
      0,
      0,
      0,
      1177,
      1178,
      5,
      10,
      0,
      0,
      1178,
      1179,
      1,
      0,
      0,
      0,
      1179,
      1180,
      6,
      144,
      3,
      0,
      1180,
      293,
      1,
      0,
      0,
      0,
      1181,
      1183,
      5,
      13,
      0,
      0,
      1182,
      1181,
      1,
      0,
      0,
      0,
      1182,
      1183,
      1,
      0,
      0,
      0,
      1183,
      1184,
      1,
      0,
      0,
      0,
      1184,
      1185,
      5,
      10,
      0,
      0,
      1185,
      295,
      1,
      0,
      0,
      0,
      1186,
      1187,
      5,
      39,
      0,
      0,
      1187,
      1188,
      1,
      0,
      0,
      0,
      1188,
      1189,
      6,
      146,
      3,
      0,
      1189,
      1190,
      6,
      146,
      2,
      0,
      1190,
      297,
      1,
      0,
      0,
      0,
      1191,
      1193,
      7,
      34,
      0,
      0,
      1192,
      1191,
      1,
      0,
      0,
      0,
      1193,
      1194,
      1,
      0,
      0,
      0,
      1194,
      1192,
      1,
      0,
      0,
      0,
      1194,
      1195,
      1,
      0,
      0,
      0,
      1195,
      1196,
      1,
      0,
      0,
      0,
      1196,
      1197,
      6,
      147,
      3,
      0,
      1197,
      299,
      1,
      0,
      0,
      0,
      1198,
      1200,
      8,
      35,
      0,
      0,
      1199,
      1198,
      1,
      0,
      0,
      0,
      1200,
      1201,
      1,
      0,
      0,
      0,
      1201,
      1199,
      1,
      0,
      0,
      0,
      1201,
      1202,
      1,
      0,
      0,
      0,
      1202,
      1203,
      1,
      0,
      0,
      0,
      1203,
      1204,
      6,
      148,
      4,
      0,
      1204,
      301,
      1,
      0,
      0,
      0,
      1205,
      1207,
      5,
      13,
      0,
      0,
      1206,
      1205,
      1,
      0,
      0,
      0,
      1206,
      1207,
      1,
      0,
      0,
      0,
      1207,
      1208,
      1,
      0,
      0,
      0,
      1208,
      1209,
      5,
      10,
      0,
      0,
      1209,
      1210,
      1,
      0,
      0,
      0,
      1210,
      1211,
      6,
      149,
      5,
      0,
      1211,
      1212,
      6,
      149,
      6,
      0,
      1212,
      303,
      1,
      0,
      0,
      0,
      1213,
      1214,
      5,
      44,
      0,
      0,
      1214,
      305,
      1,
      0,
      0,
      0,
      1215,
      1219,
      7,
      31,
      0,
      0,
      1216,
      1218,
      7,
      30,
      0,
      0,
      1217,
      1216,
      1,
      0,
      0,
      0,
      1218,
      1221,
      1,
      0,
      0,
      0,
      1219,
      1217,
      1,
      0,
      0,
      0,
      1219,
      1220,
      1,
      0,
      0,
      0,
      1220,
      1223,
      1,
      0,
      0,
      0,
      1221,
      1219,
      1,
      0,
      0,
      0,
      1222,
      1224,
      3,
      290,
      143,
      0,
      1223,
      1222,
      1,
      0,
      0,
      0,
      1223,
      1224,
      1,
      0,
      0,
      0,
      1224,
      1241,
      1,
      0,
      0,
      0,
      1225,
      1226,
      7,
      22,
      0,
      0,
      1226,
      1230,
      7,
      32,
      0,
      0,
      1227,
      1229,
      7,
      30,
      0,
      0,
      1228,
      1227,
      1,
      0,
      0,
      0,
      1229,
      1232,
      1,
      0,
      0,
      0,
      1230,
      1228,
      1,
      0,
      0,
      0,
      1230,
      1231,
      1,
      0,
      0,
      0,
      1231,
      1234,
      1,
      0,
      0,
      0,
      1232,
      1230,
      1,
      0,
      0,
      0,
      1233,
      1235,
      3,
      290,
      143,
      0,
      1234,
      1233,
      1,
      0,
      0,
      0,
      1234,
      1235,
      1,
      0,
      0,
      0,
      1235,
      1241,
      1,
      0,
      0,
      0,
      1236,
      1238,
      7,
      22,
      0,
      0,
      1237,
      1239,
      3,
      290,
      143,
      0,
      1238,
      1237,
      1,
      0,
      0,
      0,
      1238,
      1239,
      1,
      0,
      0,
      0,
      1239,
      1241,
      1,
      0,
      0,
      0,
      1240,
      1215,
      1,
      0,
      0,
      0,
      1240,
      1225,
      1,
      0,
      0,
      0,
      1240,
      1236,
      1,
      0,
      0,
      0,
      1241,
      1242,
      1,
      0,
      0,
      0,
      1242,
      1243,
      6,
      151,
      7,
      0,
      1243,
      307,
      1,
      0,
      0,
      0,
      1244,
      1246,
      5,
      95,
      0,
      0,
      1245,
      1247,
      5,
      13,
      0,
      0,
      1246,
      1245,
      1,
      0,
      0,
      0,
      1246,
      1247,
      1,
      0,
      0,
      0,
      1247,
      1248,
      1,
      0,
      0,
      0,
      1248,
      1249,
      5,
      10,
      0,
      0,
      1249,
      1250,
      1,
      0,
      0,
      0,
      1250,
      1251,
      6,
      152,
      3,
      0,
      1251,
      309,
      1,
      0,
      0,
      0,
      1252,
      1254,
      5,
      13,
      0,
      0,
      1253,
      1252,
      1,
      0,
      0,
      0,
      1253,
      1254,
      1,
      0,
      0,
      0,
      1254,
      1255,
      1,
      0,
      0,
      0,
      1255,
      1256,
      5,
      10,
      0,
      0,
      1256,
      1257,
      1,
      0,
      0,
      0,
      1257,
      1258,
      6,
      153,
      5,
      0,
      1258,
      1259,
      6,
      153,
      6,
      0,
      1259,
      311,
      1,
      0,
      0,
      0,
      1260,
      1261,
      5,
      58,
      0,
      0,
      1261,
      1262,
      1,
      0,
      0,
      0,
      1262,
      1263,
      6,
      154,
      8,
      0,
      1263,
      1264,
      6,
      154,
      6,
      0,
      1264,
      313,
      1,
      0,
      0,
      0,
      1265,
      1267,
      7,
      34,
      0,
      0,
      1266,
      1265,
      1,
      0,
      0,
      0,
      1267,
      1268,
      1,
      0,
      0,
      0,
      1268,
      1266,
      1,
      0,
      0,
      0,
      1268,
      1269,
      1,
      0,
      0,
      0,
      1269,
      1270,
      1,
      0,
      0,
      0,
      1270,
      1271,
      6,
      155,
      3,
      0,
      1271,
      315,
      1,
      0,
      0,
      0,
      1272,
      1273,
      5,
      39,
      0,
      0,
      1273,
      1274,
      1,
      0,
      0,
      0,
      1274,
      1275,
      6,
      156,
      3,
      0,
      1275,
      1276,
      6,
      156,
      9,
      0,
      1276,
      317,
      1,
      0,
      0,
      0,
      1277,
      1278,
      5,
      44,
      0,
      0,
      1278,
      319,
      1,
      0,
      0,
      0,
      1279,
      1280,
      5,
      58,
      0,
      0,
      1280,
      1281,
      1,
      0,
      0,
      0,
      1281,
      1282,
      6,
      158,
      8,
      0,
      1282,
      1283,
      6,
      158,
      6,
      0,
      1283,
      321,
      1,
      0,
      0,
      0,
      1284,
      1286,
      5,
      13,
      0,
      0,
      1285,
      1284,
      1,
      0,
      0,
      0,
      1285,
      1286,
      1,
      0,
      0,
      0,
      1286,
      1287,
      1,
      0,
      0,
      0,
      1287,
      1288,
      5,
      10,
      0,
      0,
      1288,
      1289,
      1,
      0,
      0,
      0,
      1289,
      1290,
      6,
      159,
      5,
      0,
      1290,
      1291,
      6,
      159,
      6,
      0,
      1291,
      323,
      1,
      0,
      0,
      0,
      1292,
      1296,
      5,
      34,
      0,
      0,
      1293,
      1295,
      8,
      8,
      0,
      0,
      1294,
      1293,
      1,
      0,
      0,
      0,
      1295,
      1298,
      1,
      0,
      0,
      0,
      1296,
      1294,
      1,
      0,
      0,
      0,
      1296,
      1297,
      1,
      0,
      0,
      0,
      1297,
      1299,
      1,
      0,
      0,
      0,
      1298,
      1296,
      1,
      0,
      0,
      0,
      1299,
      1300,
      5,
      34,
      0,
      0,
      1300,
      325,
      1,
      0,
      0,
      0,
      1301,
      1312,
      8,
      36,
      0,
      0,
      1302,
      1303,
      8,
      36,
      0,
      0,
      1303,
      1312,
      8,
      36,
      0,
      0,
      1304,
      1306,
      8,
      36,
      0,
      0,
      1305,
      1307,
      8,
      37,
      0,
      0,
      1306,
      1305,
      1,
      0,
      0,
      0,
      1307,
      1308,
      1,
      0,
      0,
      0,
      1308,
      1306,
      1,
      0,
      0,
      0,
      1308,
      1309,
      1,
      0,
      0,
      0,
      1309,
      1310,
      1,
      0,
      0,
      0,
      1310,
      1312,
      8,
      36,
      0,
      0,
      1311,
      1301,
      1,
      0,
      0,
      0,
      1311,
      1302,
      1,
      0,
      0,
      0,
      1311,
      1304,
      1,
      0,
      0,
      0,
      1312,
      327,
      1,
      0,
      0,
      0,
      1313,
      1315,
      7,
      34,
      0,
      0,
      1314,
      1313,
      1,
      0,
      0,
      0,
      1315,
      1316,
      1,
      0,
      0,
      0,
      1316,
      1314,
      1,
      0,
      0,
      0,
      1316,
      1317,
      1,
      0,
      0,
      0,
      1317,
      1318,
      1,
      0,
      0,
      0,
      1318,
      1319,
      6,
      162,
      3,
      0,
      1319,
      329,
      1,
      0,
      0,
      0,
      59,
      0,
      1,
      2,
      3,
      378,
      385,
      392,
      397,
      403,
      407,
      410,
      416,
      419,
      422,
      427,
      431,
      436,
      439,
      443,
      448,
      453,
      459,
      464,
      470,
      474,
      479,
      483,
      485,
      489,
      494,
      497,
      503,
      1138,
      1142,
      1148,
      1152,
      1159,
      1163,
      1167,
      1169,
      1175,
      1182,
      1194,
      1201,
      1206,
      1219,
      1223,
      1230,
      1234,
      1238,
      1240,
      1246,
      1253,
      1268,
      1285,
      1296,
      1308,
      1311,
      1316,
      10,
      5,
      3,
      0,
      5,
      2,
      0,
      5,
      1,
      0,
      6,
      0,
      0,
      0,
      1,
      0,
      7,
      143,
      0,
      4,
      0,
      0,
      7,
      141,
      0,
      7,
      1,
      0,
      2,
      1,
      0
    ];
    static __ATN;
    static get _ATN() {
      if (!_QBasicLexer.__ATN) {
        _QBasicLexer.__ATN = new ATNDeserializer().deserialize(_QBasicLexer._serializedATN);
      }
      return _QBasicLexer.__ATN;
    }
    static vocabulary = new Vocabulary(_QBasicLexer.literalNames, _QBasicLexer.symbolicNames, []);
    get vocabulary() {
      return _QBasicLexer.vocabulary;
    }
    static decisionsToDFA = _QBasicLexer._ATN.decisionToState.map((ds, index) => new DFA(ds, index));
  };

  // build/QBasicParser.ts
  var QBasicParser = class _QBasicParser extends Parser {
    static COLON = 1;
    static LEFT_PAREN = 2;
    static RIGHT_PAREN = 3;
    static NUMBER = 4;
    static DIVIDE = 5;
    static INTEGER_DIVIDE = 6;
    static EXP = 7;
    static MINUS = 8;
    static PLUS = 9;
    static TIMES = 10;
    static COMMA = 11;
    static SEMICOLON = 12;
    static LT = 13;
    static LE = 14;
    static NE = 15;
    static EQ = 16;
    static GT = 17;
    static GE = 18;
    static AMP = 19;
    static PERCENT = 20;
    static DOT = 21;
    static DIGITS = 22;
    static HEX = 23;
    static OCTAL = 24;
    static PROBABLY_SINGLE_PRECISION_NUMBER = 25;
    static DOUBLE_PRECISION_NUMBER = 26;
    static STRING_LITERAL = 27;
    static ABSOLUTE = 28;
    static ACCESS = 29;
    static AND = 30;
    static ANY = 31;
    static APPEND = 32;
    static AS = 33;
    static BASE = 34;
    static BINARY = 35;
    static CALL = 36;
    static CASE = 37;
    static CIRCLE = 38;
    static CLEAR = 39;
    static CLOSE = 40;
    static COLOR = 41;
    static COM = 42;
    static COMMON = 43;
    static CONST = 44;
    static DATA = 45;
    static DECLARE = 46;
    static DEF = 47;
    static DEFDBL = 48;
    static DEFINT = 49;
    static DEFLNG = 50;
    static DEFSNG = 51;
    static DEFSTR = 52;
    static DIM = 53;
    static DO = 54;
    static DOUBLE = 55;
    static ELSE = 56;
    static ELSEIF = 57;
    static EQV = 58;
    static ERROR = 59;
    static END = 60;
    static EXIT = 61;
    static FIELD = 62;
    static FOR = 63;
    static FN = 64;
    static FUNCTION = 65;
    static GET = 66;
    static GOSUB = 67;
    static GOTO = 68;
    static IF = 69;
    static IMP = 70;
    static INPUT = 71;
    static INPUT_STRING = 72;
    static IOCTL = 73;
    static IOCTL_STRING = 74;
    static IS = 75;
    static INTEGER = 76;
    static KEY = 77;
    static LEN = 78;
    static LET = 79;
    static LINE = 80;
    static LIST = 81;
    static LOCATE = 82;
    static LOCK = 83;
    static LONG = 84;
    static LOOP = 85;
    static LPRINT = 86;
    static LSET = 87;
    static MID_STRING = 88;
    static MOD = 89;
    static NAME = 90;
    static NEXT = 91;
    static NOT = 92;
    static OPTION = 93;
    static OFF = 94;
    static OPEN = 95;
    static OUTPUT = 96;
    static OR = 97;
    static ON = 98;
    static PAINT = 99;
    static PALETTE = 100;
    static PEN = 101;
    static PLAY = 102;
    static PRINT = 103;
    static PRESET = 104;
    static PSET = 105;
    static PUT = 106;
    static RANDOM = 107;
    static READ = 108;
    static REDIM = 109;
    static REM = 110;
    static RESUME = 111;
    static RETURN = 112;
    static RSET = 113;
    static SCREEN = 114;
    static SEEK = 115;
    static SEG = 116;
    static SELECT = 117;
    static SHARED = 118;
    static SINGLE = 119;
    static STATIC = 120;
    static STEP = 121;
    static STOP = 122;
    static STRIG = 123;
    static STRING = 124;
    static SUB = 125;
    static THEN = 126;
    static TO = 127;
    static TYPE = 128;
    static TIMER = 129;
    static UNLOCK = 130;
    static UNTIL = 131;
    static USING = 132;
    static VIEW = 133;
    static WEND = 134;
    static WHILE = 135;
    static WIDTH = 136;
    static WINDOW = 137;
    static WRITE = 138;
    static XOR = 139;
    static FNID = 140;
    static ID = 141;
    static CONTINUED_LINE = 142;
    static NL = 143;
    static COMMENT = 144;
    static WS = 145;
    static COMMENT_TEXT = 146;
    static NEXT_WITH_MANDATORY_ID = 147;
    static NEXT_CONTINUED_LINE = 148;
    static NEXT_WS = 149;
    static NEXT_COMMENT = 150;
    static DATA_COMMA = 151;
    static DATA_QUOTED = 152;
    static DATA_UNQUOTED = 153;
    static DATA_WS = 154;
    static RULE_program = 0;
    static RULE_block = 1;
    static RULE_label = 2;
    static RULE_line_number = 3;
    static RULE_text_label = 4;
    static RULE_statement = 5;
    static RULE_declare_statement = 6;
    static RULE_declare_parameter_list = 7;
    static RULE_declare_parameter = 8;
    static RULE_def_fn_statement = 9;
    static RULE_def_fn_parameter_list = 10;
    static RULE_def_fn_parameter = 11;
    static RULE_function_statement = 12;
    static RULE_parameter_list = 13;
    static RULE_parameter = 14;
    static RULE_array_declaration = 15;
    static RULE_end_function_statement = 16;
    static RULE_if_block_statement = 17;
    static RULE_elseif_block_statement = 18;
    static RULE_else_block_statement = 19;
    static RULE_end_if_statement = 20;
    static RULE_then_block = 21;
    static RULE_else_block = 22;
    static RULE_option_statement = 23;
    static RULE_sub_statement = 24;
    static RULE_end_sub_statement = 25;
    static RULE_type_statement = 26;
    static RULE_type_element = 27;
    static RULE_assignment_statement = 28;
    static RULE_call_statement = 29;
    static RULE_call_argument_list = 30;
    static RULE_call_argument = 31;
    static RULE_call_absolute_statement = 32;
    static RULE_call_absolute_argument_list = 33;
    static RULE_error_statement = 34;
    static RULE_event_control_statement = 35;
    static RULE_circle_statement = 36;
    static RULE_clear_statement = 37;
    static RULE_close_statement = 38;
    static RULE_color_statement = 39;
    static RULE_const_statement = 40;
    static RULE_const_assignment = 41;
    static RULE_const_expr = 42;
    static RULE_data_statement = 43;
    static RULE_data_item = 44;
    static RULE_def_seg_statement = 45;
    static RULE_deftype_statement = 46;
    static RULE_letter_range = 47;
    static RULE_dim_statement = 48;
    static RULE_dim_variable = 49;
    static RULE_dim_array_bounds = 50;
    static RULE_dim_subscript = 51;
    static RULE_do_loop_statement = 52;
    static RULE_do_condition = 53;
    static RULE_end_statement = 54;
    static RULE_exit_statement = 55;
    static RULE_field_statement = 56;
    static RULE_field_assignment = 57;
    static RULE_for_next_statement = 58;
    static RULE_get_graphics_statement = 59;
    static RULE_get_io_statement = 60;
    static RULE_gosub_statement = 61;
    static RULE_goto_statement = 62;
    static RULE_target = 63;
    static RULE_if_inline_statement = 64;
    static RULE_if_inline_action = 65;
    static RULE_input_statement = 66;
    static RULE_ioctl_statement = 67;
    static RULE_key_statement = 68;
    static RULE_line_statement = 69;
    static RULE_box_style = 70;
    static RULE_line_input_statement = 71;
    static RULE_locate_statement = 72;
    static RULE_lock_statement = 73;
    static RULE_lprint_statement = 74;
    static RULE_lprint_using_statement = 75;
    static RULE_lset_statement = 76;
    static RULE_mid_statement = 77;
    static RULE_name_statement = 78;
    static RULE_on_error_statement = 79;
    static RULE_on_event_gosub_statement = 80;
    static RULE_on_expr_gosub_statement = 81;
    static RULE_target_list = 82;
    static RULE_on_expr_goto_statement = 83;
    static RULE_open_legacy_statement = 84;
    static RULE_open_statement = 85;
    static RULE_open_mode = 86;
    static RULE_open_access = 87;
    static RULE_open_lock = 88;
    static RULE_paint_statement = 89;
    static RULE_palette_statement = 90;
    static RULE_play_statement = 91;
    static RULE_preset_statement = 92;
    static RULE_print_statement = 93;
    static RULE_print_using_statement = 94;
    static RULE_pset_statement = 95;
    static RULE_put_graphics_statement = 96;
    static RULE_put_io_statement = 97;
    static RULE_read_statement = 98;
    static RULE_rem_statement = 99;
    static RULE_resume_statement = 100;
    static RULE_return_statement = 101;
    static RULE_rset_statement = 102;
    static RULE_select_case_statement = 103;
    static RULE_before_first_case = 104;
    static RULE_case_block = 105;
    static RULE_case_statement = 106;
    static RULE_case_expr = 107;
    static RULE_end_select_statement = 108;
    static RULE_scope_statement = 109;
    static RULE_block_name = 110;
    static RULE_scope_variable = 111;
    static RULE_screen_statement = 112;
    static RULE_seek_statement = 113;
    static RULE_stop_statement = 114;
    static RULE_unlock_statement = 115;
    static RULE_view_statement = 116;
    static RULE_view_print_statement = 117;
    static RULE_while_wend_statement = 118;
    static RULE_width_statement = 119;
    static RULE_window_statement = 120;
    static RULE_write_statement = 121;
    static RULE_expr = 122;
    static RULE_builtin_function = 123;
    static RULE_args_or_indices = 124;
    static RULE_variable_or_function_call = 125;
    static RULE_type_name = 126;
    static RULE_type_name_for_parameter = 127;
    static RULE_type_name_for_declare_parameter = 128;
    static RULE_type_name_for_def_fn_parameter = 129;
    static RULE_type_name_for_type_element = 130;
    static RULE_file_number = 131;
    static RULE_fixed_string = 132;
    static RULE_untyped_id = 133;
    static RULE_untyped_fnid = 134;
    static RULE_literal = 135;
    static literalNames = [
      null,
      null,
      "'('",
      "')'",
      "'#'",
      "'/'",
      "'\\'",
      "'^'",
      "'-'",
      "'+'",
      "'*'",
      null,
      "';'",
      "'<'",
      "'<='",
      "'<>'",
      "'='",
      "'>'",
      "'>='",
      "'&'",
      "'%'",
      "'.'"
    ];
    static symbolicNames = [
      null,
      "COLON",
      "LEFT_PAREN",
      "RIGHT_PAREN",
      "NUMBER",
      "DIVIDE",
      "INTEGER_DIVIDE",
      "EXP",
      "MINUS",
      "PLUS",
      "TIMES",
      "COMMA",
      "SEMICOLON",
      "LT",
      "LE",
      "NE",
      "EQ",
      "GT",
      "GE",
      "AMP",
      "PERCENT",
      "DOT",
      "DIGITS",
      "HEX",
      "OCTAL",
      "PROBABLY_SINGLE_PRECISION_NUMBER",
      "DOUBLE_PRECISION_NUMBER",
      "STRING_LITERAL",
      "ABSOLUTE",
      "ACCESS",
      "AND",
      "ANY",
      "APPEND",
      "AS",
      "BASE",
      "BINARY",
      "CALL",
      "CASE",
      "CIRCLE",
      "CLEAR",
      "CLOSE",
      "COLOR",
      "COM",
      "COMMON",
      "CONST",
      "DATA",
      "DECLARE",
      "DEF",
      "DEFDBL",
      "DEFINT",
      "DEFLNG",
      "DEFSNG",
      "DEFSTR",
      "DIM",
      "DO",
      "DOUBLE",
      "ELSE",
      "ELSEIF",
      "EQV",
      "ERROR",
      "END",
      "EXIT",
      "FIELD",
      "FOR",
      "FN",
      "FUNCTION",
      "GET",
      "GOSUB",
      "GOTO",
      "IF",
      "IMP",
      "INPUT",
      "INPUT_STRING",
      "IOCTL",
      "IOCTL_STRING",
      "IS",
      "INTEGER",
      "KEY",
      "LEN",
      "LET",
      "LINE",
      "LIST",
      "LOCATE",
      "LOCK",
      "LONG",
      "LOOP",
      "LPRINT",
      "LSET",
      "MID_STRING",
      "MOD",
      "NAME",
      "NEXT",
      "NOT",
      "OPTION",
      "OFF",
      "OPEN",
      "OUTPUT",
      "OR",
      "ON",
      "PAINT",
      "PALETTE",
      "PEN",
      "PLAY",
      "PRINT",
      "PRESET",
      "PSET",
      "PUT",
      "RANDOM",
      "READ",
      "REDIM",
      "REM",
      "RESUME",
      "RETURN",
      "RSET",
      "SCREEN",
      "SEEK",
      "SEG",
      "SELECT",
      "SHARED",
      "SINGLE",
      "STATIC",
      "STEP",
      "STOP",
      "STRIG",
      "STRING",
      "SUB",
      "THEN",
      "TO",
      "TYPE",
      "TIMER",
      "UNLOCK",
      "UNTIL",
      "USING",
      "VIEW",
      "WEND",
      "WHILE",
      "WIDTH",
      "WINDOW",
      "WRITE",
      "XOR",
      "FNID",
      "ID",
      "CONTINUED_LINE",
      "NL",
      "COMMENT",
      "WS",
      "COMMENT_TEXT",
      "NEXT_WITH_MANDATORY_ID",
      "NEXT_CONTINUED_LINE",
      "NEXT_WS",
      "NEXT_COMMENT",
      "DATA_COMMA",
      "DATA_QUOTED",
      "DATA_UNQUOTED",
      "DATA_WS"
    ];
    static ruleNames = [
      "program",
      "block",
      "label",
      "line_number",
      "text_label",
      "statement",
      "declare_statement",
      "declare_parameter_list",
      "declare_parameter",
      "def_fn_statement",
      "def_fn_parameter_list",
      "def_fn_parameter",
      "function_statement",
      "parameter_list",
      "parameter",
      "array_declaration",
      "end_function_statement",
      "if_block_statement",
      "elseif_block_statement",
      "else_block_statement",
      "end_if_statement",
      "then_block",
      "else_block",
      "option_statement",
      "sub_statement",
      "end_sub_statement",
      "type_statement",
      "type_element",
      "assignment_statement",
      "call_statement",
      "call_argument_list",
      "call_argument",
      "call_absolute_statement",
      "call_absolute_argument_list",
      "error_statement",
      "event_control_statement",
      "circle_statement",
      "clear_statement",
      "close_statement",
      "color_statement",
      "const_statement",
      "const_assignment",
      "const_expr",
      "data_statement",
      "data_item",
      "def_seg_statement",
      "deftype_statement",
      "letter_range",
      "dim_statement",
      "dim_variable",
      "dim_array_bounds",
      "dim_subscript",
      "do_loop_statement",
      "do_condition",
      "end_statement",
      "exit_statement",
      "field_statement",
      "field_assignment",
      "for_next_statement",
      "get_graphics_statement",
      "get_io_statement",
      "gosub_statement",
      "goto_statement",
      "target",
      "if_inline_statement",
      "if_inline_action",
      "input_statement",
      "ioctl_statement",
      "key_statement",
      "line_statement",
      "box_style",
      "line_input_statement",
      "locate_statement",
      "lock_statement",
      "lprint_statement",
      "lprint_using_statement",
      "lset_statement",
      "mid_statement",
      "name_statement",
      "on_error_statement",
      "on_event_gosub_statement",
      "on_expr_gosub_statement",
      "target_list",
      "on_expr_goto_statement",
      "open_legacy_statement",
      "open_statement",
      "open_mode",
      "open_access",
      "open_lock",
      "paint_statement",
      "palette_statement",
      "play_statement",
      "preset_statement",
      "print_statement",
      "print_using_statement",
      "pset_statement",
      "put_graphics_statement",
      "put_io_statement",
      "read_statement",
      "rem_statement",
      "resume_statement",
      "return_statement",
      "rset_statement",
      "select_case_statement",
      "before_first_case",
      "case_block",
      "case_statement",
      "case_expr",
      "end_select_statement",
      "scope_statement",
      "block_name",
      "scope_variable",
      "screen_statement",
      "seek_statement",
      "stop_statement",
      "unlock_statement",
      "view_statement",
      "view_print_statement",
      "while_wend_statement",
      "width_statement",
      "window_statement",
      "write_statement",
      "expr",
      "builtin_function",
      "args_or_indices",
      "variable_or_function_call",
      "type_name",
      "type_name_for_parameter",
      "type_name_for_declare_parameter",
      "type_name_for_def_fn_parameter",
      "type_name_for_type_element",
      "file_number",
      "fixed_string",
      "untyped_id",
      "untyped_fnid",
      "literal"
    ];
    get grammarFileName() {
      return "QBasicParser.g4";
    }
    get literalNames() {
      return _QBasicParser.literalNames;
    }
    get symbolicNames() {
      return _QBasicParser.symbolicNames;
    }
    get ruleNames() {
      return _QBasicParser.ruleNames;
    }
    get serializedATN() {
      return _QBasicParser._serializedATN;
    }
    createFailedPredicateException(predicate, message) {
      return new FailedPredicateException(this, predicate, message);
    }
    constructor(input) {
      super(input);
      this.interpreter = new ParserATNSimulator(this, _QBasicParser._ATN, _QBasicParser.decisionsToDFA, new PredictionContextCache());
    }
    program() {
      let localContext = new ProgramContext(this.context, this.state);
      this.enterRule(localContext, 0, _QBasicParser.RULE_program);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 300;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 1 || _la === 22 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & 4018667517) !== 0 || (_la - 68 & ~31) === 0 && (1 << _la - 68 & 3395082795) !== 0 || (_la - 100 & ~31) === 0 && (1 << _la - 100 & 1926692735) !== 0 || (_la - 133 & ~31) === 0 && (1 << _la - 133 & 1469) !== 0) {
            {
              {
                this.state = 273;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 0, this.context)) {
                  case 1:
                    {
                      this.state = 272;
                      this.label();
                    }
                    break;
                }
                this.state = 283;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 1, this.context)) {
                  case 1:
                    {
                      this.state = 275;
                      this.statement();
                    }
                    break;
                  case 2:
                    {
                      this.state = 276;
                      this.declare_statement();
                    }
                    break;
                  case 3:
                    {
                      this.state = 277;
                      this.def_fn_statement();
                    }
                    break;
                  case 4:
                    {
                      this.state = 278;
                      this.function_statement();
                    }
                    break;
                  case 5:
                    {
                      this.state = 279;
                      this.if_block_statement();
                    }
                    break;
                  case 6:
                    {
                      this.state = 280;
                      this.option_statement();
                    }
                    break;
                  case 7:
                    {
                      this.state = 281;
                      this.sub_statement();
                    }
                    break;
                  case 8:
                    {
                      this.state = 282;
                      this.type_statement();
                    }
                    break;
                }
                this.state = 293;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while (_la === 1 || _la === 46 || _la === 47 || _la === 93 || _la === 128) {
                  {
                    this.state = 291;
                    this.errorHandler.sync(this);
                    switch (this.tokenStream.LA(1)) {
                      case _QBasicParser.COLON:
                        {
                          this.state = 285;
                          this.match(_QBasicParser.COLON);
                          this.state = 286;
                          this.statement();
                        }
                        break;
                      case _QBasicParser.DECLARE:
                        {
                          this.state = 287;
                          this.declare_statement();
                        }
                        break;
                      case _QBasicParser.DEF:
                        {
                          this.state = 288;
                          this.def_fn_statement();
                        }
                        break;
                      case _QBasicParser.OPTION:
                        {
                          this.state = 289;
                          this.option_statement();
                        }
                        break;
                      case _QBasicParser.TYPE:
                        {
                          this.state = 290;
                          this.type_statement();
                        }
                        break;
                      default:
                        throw new NoViableAltException(this);
                    }
                  }
                  this.state = 295;
                  this.errorHandler.sync(this);
                  _la = this.tokenStream.LA(1);
                }
                this.state = 296;
                this.match(_QBasicParser.NL);
              }
            }
            this.state = 302;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
          this.state = 303;
          this.match(_QBasicParser.EOF);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    block() {
      let localContext = new BlockContext(this.context, this.state);
      this.enterRule(localContext, 2, _QBasicParser.RULE_block);
      let _la;
      try {
        let alternative;
        this.state = 356;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 14, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 309;
              this.errorHandler.sync(this);
              alternative = this.interpreter.adaptivePredict(this.tokenStream, 5, this.context);
              while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
                if (alternative === 1) {
                  {
                    {
                      this.state = 305;
                      this.match(_QBasicParser.COLON);
                      this.state = 306;
                      this.statement();
                    }
                  }
                }
                this.state = 311;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 5, this.context);
              }
              this.state = 312;
              this.match(_QBasicParser.COLON);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 317;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 1) {
                {
                  {
                    this.state = 313;
                    this.match(_QBasicParser.COLON);
                    this.state = 314;
                    this.statement();
                  }
                }
                this.state = 319;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
              this.state = 320;
              this.match(_QBasicParser.NL);
              this.state = 339;
              this.errorHandler.sync(this);
              alternative = this.interpreter.adaptivePredict(this.tokenStream, 10, this.context);
              while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
                if (alternative === 1) {
                  {
                    {
                      this.state = 322;
                      this.errorHandler.sync(this);
                      switch (this.interpreter.adaptivePredict(this.tokenStream, 7, this.context)) {
                        case 1:
                          {
                            this.state = 321;
                            this.label();
                          }
                          break;
                      }
                      this.state = 326;
                      this.errorHandler.sync(this);
                      switch (this.interpreter.adaptivePredict(this.tokenStream, 8, this.context)) {
                        case 1:
                          {
                            this.state = 324;
                            this.statement();
                          }
                          break;
                        case 2:
                          {
                            this.state = 325;
                            this.if_block_statement();
                          }
                          break;
                      }
                      this.state = 332;
                      this.errorHandler.sync(this);
                      _la = this.tokenStream.LA(1);
                      while (_la === 1) {
                        {
                          {
                            this.state = 328;
                            this.match(_QBasicParser.COLON);
                            this.state = 329;
                            this.statement();
                          }
                        }
                        this.state = 334;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                      }
                      this.state = 335;
                      this.match(_QBasicParser.NL);
                    }
                  }
                }
                this.state = 341;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 10, this.context);
              }
              this.state = 343;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 11, this.context)) {
                case 1:
                  {
                    this.state = 342;
                    this.label();
                  }
                  break;
              }
              this.state = 347;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 12, this.context)) {
                case 1:
                  {
                    this.state = 345;
                    this.statement();
                  }
                  break;
                case 2:
                  {
                    this.state = 346;
                    this.if_block_statement();
                  }
                  break;
              }
              this.state = 353;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 1) {
                {
                  {
                    this.state = 349;
                    this.match(_QBasicParser.COLON);
                    this.state = 350;
                    this.statement();
                  }
                }
                this.state = 355;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    label() {
      let localContext = new LabelContext(this.context, this.state);
      this.enterRule(localContext, 4, _QBasicParser.RULE_label);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 362;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.DIGITS:
              {
                this.state = 358;
                this.line_number();
              }
              break;
            case _QBasicParser.FNID:
            case _QBasicParser.ID:
              {
                this.state = 359;
                this.text_label();
                this.state = 360;
                this.match(_QBasicParser.COLON);
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    line_number() {
      let localContext = new Line_numberContext(this.context, this.state);
      this.enterRule(localContext, 6, _QBasicParser.RULE_line_number);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 364;
          this.match(_QBasicParser.DIGITS);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    text_label() {
      let localContext = new Text_labelContext(this.context, this.state);
      this.enterRule(localContext, 8, _QBasicParser.RULE_text_label);
      try {
        this.state = 368;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.ID:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 366;
              this.untyped_id();
            }
            break;
          case _QBasicParser.FNID:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 367;
              this.untyped_fnid();
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    statement() {
      let localContext = new StatementContext(this.context, this.state);
      this.enterRule(localContext, 10, _QBasicParser.RULE_statement);
      try {
        this.state = 439;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 17, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 370;
              this.assignment_statement();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 371;
              this.call_statement();
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 372;
              this.call_absolute_statement();
            }
            break;
          case 4:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 373;
              this.circle_statement();
            }
            break;
          case 5:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 374;
              this.clear_statement();
            }
            break;
          case 6:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 375;
              this.close_statement();
            }
            break;
          case 7:
            this.enterOuterAlt(localContext, 7);
            {
              this.state = 376;
              this.color_statement();
            }
            break;
          case 8:
            this.enterOuterAlt(localContext, 8);
            {
              this.state = 377;
              this.const_statement();
            }
            break;
          case 9:
            this.enterOuterAlt(localContext, 9);
            {
              this.state = 378;
              this.data_statement();
            }
            break;
          case 10:
            this.enterOuterAlt(localContext, 10);
            {
              this.state = 379;
              this.def_seg_statement();
            }
            break;
          case 11:
            this.enterOuterAlt(localContext, 11);
            {
              this.state = 380;
              this.deftype_statement();
            }
            break;
          case 12:
            this.enterOuterAlt(localContext, 12);
            {
              this.state = 381;
              this.dim_statement();
            }
            break;
          case 13:
            this.enterOuterAlt(localContext, 13);
            {
              this.state = 382;
              this.do_loop_statement();
            }
            break;
          case 14:
            this.enterOuterAlt(localContext, 14);
            {
              this.state = 383;
              this.error_statement();
            }
            break;
          case 15:
            this.enterOuterAlt(localContext, 15);
            {
              this.state = 384;
              this.event_control_statement();
            }
            break;
          case 16:
            this.enterOuterAlt(localContext, 16);
            {
              this.state = 385;
              this.end_statement();
            }
            break;
          case 17:
            this.enterOuterAlt(localContext, 17);
            {
              this.state = 386;
              this.exit_statement();
            }
            break;
          case 18:
            this.enterOuterAlt(localContext, 18);
            {
              this.state = 387;
              this.field_statement();
            }
            break;
          case 19:
            this.enterOuterAlt(localContext, 19);
            {
              this.state = 388;
              this.for_next_statement();
            }
            break;
          case 20:
            this.enterOuterAlt(localContext, 20);
            {
              this.state = 389;
              this.get_graphics_statement();
            }
            break;
          case 21:
            this.enterOuterAlt(localContext, 21);
            {
              this.state = 390;
              this.get_io_statement();
            }
            break;
          case 22:
            this.enterOuterAlt(localContext, 22);
            {
              this.state = 391;
              this.gosub_statement();
            }
            break;
          case 23:
            this.enterOuterAlt(localContext, 23);
            {
              this.state = 392;
              this.goto_statement();
            }
            break;
          case 24:
            this.enterOuterAlt(localContext, 24);
            {
              this.state = 393;
              this.if_inline_statement();
            }
            break;
          case 25:
            this.enterOuterAlt(localContext, 25);
            {
              this.state = 394;
              this.input_statement();
            }
            break;
          case 26:
            this.enterOuterAlt(localContext, 26);
            {
              this.state = 395;
              this.ioctl_statement();
            }
            break;
          case 27:
            this.enterOuterAlt(localContext, 27);
            {
              this.state = 396;
              this.key_statement();
            }
            break;
          case 28:
            this.enterOuterAlt(localContext, 28);
            {
              this.state = 397;
              this.line_statement();
            }
            break;
          case 29:
            this.enterOuterAlt(localContext, 29);
            {
              this.state = 398;
              this.line_input_statement();
            }
            break;
          case 30:
            this.enterOuterAlt(localContext, 30);
            {
              this.state = 399;
              this.locate_statement();
            }
            break;
          case 31:
            this.enterOuterAlt(localContext, 31);
            {
              this.state = 400;
              this.lock_statement();
            }
            break;
          case 32:
            this.enterOuterAlt(localContext, 32);
            {
              this.state = 401;
              this.lprint_statement();
            }
            break;
          case 33:
            this.enterOuterAlt(localContext, 33);
            {
              this.state = 402;
              this.lprint_using_statement();
            }
            break;
          case 34:
            this.enterOuterAlt(localContext, 34);
            {
              this.state = 403;
              this.lset_statement();
            }
            break;
          case 35:
            this.enterOuterAlt(localContext, 35);
            {
              this.state = 404;
              this.mid_statement();
            }
            break;
          case 36:
            this.enterOuterAlt(localContext, 36);
            {
              this.state = 405;
              this.name_statement();
            }
            break;
          case 37:
            this.enterOuterAlt(localContext, 37);
            {
              this.state = 406;
              this.on_error_statement();
            }
            break;
          case 38:
            this.enterOuterAlt(localContext, 38);
            {
              this.state = 407;
              this.on_event_gosub_statement();
            }
            break;
          case 39:
            this.enterOuterAlt(localContext, 39);
            {
              this.state = 408;
              this.on_expr_gosub_statement();
            }
            break;
          case 40:
            this.enterOuterAlt(localContext, 40);
            {
              this.state = 409;
              this.on_expr_goto_statement();
            }
            break;
          case 41:
            this.enterOuterAlt(localContext, 41);
            {
              this.state = 410;
              this.open_statement();
            }
            break;
          case 42:
            this.enterOuterAlt(localContext, 42);
            {
              this.state = 411;
              this.open_legacy_statement();
            }
            break;
          case 43:
            this.enterOuterAlt(localContext, 43);
            {
              this.state = 412;
              this.paint_statement();
            }
            break;
          case 44:
            this.enterOuterAlt(localContext, 44);
            {
              this.state = 413;
              this.palette_statement();
            }
            break;
          case 45:
            this.enterOuterAlt(localContext, 45);
            {
              this.state = 414;
              this.play_statement();
            }
            break;
          case 46:
            this.enterOuterAlt(localContext, 46);
            {
              this.state = 415;
              this.preset_statement();
            }
            break;
          case 47:
            this.enterOuterAlt(localContext, 47);
            {
              this.state = 416;
              this.print_statement();
            }
            break;
          case 48:
            this.enterOuterAlt(localContext, 48);
            {
              this.state = 417;
              this.print_using_statement();
            }
            break;
          case 49:
            this.enterOuterAlt(localContext, 49);
            {
              this.state = 418;
              this.pset_statement();
            }
            break;
          case 50:
            this.enterOuterAlt(localContext, 50);
            {
              this.state = 419;
              this.put_graphics_statement();
            }
            break;
          case 51:
            this.enterOuterAlt(localContext, 51);
            {
              this.state = 420;
              this.put_io_statement();
            }
            break;
          case 52:
            this.enterOuterAlt(localContext, 52);
            {
              this.state = 421;
              this.read_statement();
            }
            break;
          case 53:
            this.enterOuterAlt(localContext, 53);
            {
              this.state = 422;
              this.rem_statement();
            }
            break;
          case 54:
            this.enterOuterAlt(localContext, 54);
            {
              this.state = 423;
              this.resume_statement();
            }
            break;
          case 55:
            this.enterOuterAlt(localContext, 55);
            {
              this.state = 424;
              this.return_statement();
            }
            break;
          case 56:
            this.enterOuterAlt(localContext, 56);
            {
              this.state = 425;
              this.rset_statement();
            }
            break;
          case 57:
            this.enterOuterAlt(localContext, 57);
            {
              this.state = 426;
              this.scope_statement();
            }
            break;
          case 58:
            this.enterOuterAlt(localContext, 58);
            {
              this.state = 427;
              this.screen_statement();
            }
            break;
          case 59:
            this.enterOuterAlt(localContext, 59);
            {
              this.state = 428;
              this.seek_statement();
            }
            break;
          case 60:
            this.enterOuterAlt(localContext, 60);
            {
              this.state = 429;
              this.select_case_statement();
            }
            break;
          case 61:
            this.enterOuterAlt(localContext, 61);
            {
              this.state = 430;
              this.stop_statement();
            }
            break;
          case 62:
            this.enterOuterAlt(localContext, 62);
            {
              this.state = 431;
              this.unlock_statement();
            }
            break;
          case 63:
            this.enterOuterAlt(localContext, 63);
            {
              this.state = 432;
              this.view_statement();
            }
            break;
          case 64:
            this.enterOuterAlt(localContext, 64);
            {
              this.state = 433;
              this.view_print_statement();
            }
            break;
          case 65:
            this.enterOuterAlt(localContext, 65);
            {
              this.state = 434;
              this.while_wend_statement();
            }
            break;
          case 66:
            this.enterOuterAlt(localContext, 66);
            {
              this.state = 435;
              this.width_statement();
            }
            break;
          case 67:
            this.enterOuterAlt(localContext, 67);
            {
              this.state = 436;
              this.window_statement();
            }
            break;
          case 68:
            this.enterOuterAlt(localContext, 68);
            {
              this.state = 437;
              this.write_statement();
            }
            break;
          case 69:
            this.enterOuterAlt(localContext, 69);
            {
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    declare_statement() {
      let localContext = new Declare_statementContext(this.context, this.state);
      this.enterRule(localContext, 12, _QBasicParser.RULE_declare_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 441;
          this.match(_QBasicParser.DECLARE);
          this.state = 446;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.SUB:
              {
                this.state = 442;
                this.match(_QBasicParser.SUB);
                this.state = 443;
                this.untyped_id();
              }
              break;
            case _QBasicParser.FUNCTION:
              {
                this.state = 444;
                this.match(_QBasicParser.FUNCTION);
                this.state = 445;
                this.match(_QBasicParser.ID);
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
          this.state = 453;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 2) {
            {
              this.state = 448;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 450;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 141) {
                {
                  this.state = 449;
                  this.declare_parameter_list();
                }
              }
              this.state = 452;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    declare_parameter_list() {
      let localContext = new Declare_parameter_listContext(this.context, this.state);
      this.enterRule(localContext, 14, _QBasicParser.RULE_declare_parameter_list);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 455;
          this.declare_parameter();
          this.state = 460;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 456;
                this.match(_QBasicParser.COMMA);
                this.state = 457;
                this.declare_parameter();
              }
            }
            this.state = 462;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    declare_parameter() {
      let localContext = new Declare_parameterContext(this.context, this.state);
      this.enterRule(localContext, 16, _QBasicParser.RULE_declare_parameter);
      let _la;
      try {
        this.state = 474;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 24, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 463;
              this.untyped_id();
              this.state = 465;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 464;
                  this.array_declaration();
                }
              }
              this.state = 467;
              this.match(_QBasicParser.AS);
              this.state = 468;
              this.type_name_for_declare_parameter();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 470;
              this.match(_QBasicParser.ID);
              this.state = 472;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 471;
                  this.array_declaration();
                }
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    def_fn_statement() {
      let localContext = new Def_fn_statementContext(this.context, this.state);
      this.enterRule(localContext, 18, _QBasicParser.RULE_def_fn_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 476;
          this.match(_QBasicParser.DEF);
          this.state = 480;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.FNID:
              {
                this.state = 477;
                this.match(_QBasicParser.FNID);
              }
              break;
            case _QBasicParser.FN:
              {
                this.state = 478;
                this.match(_QBasicParser.FN);
                this.state = 479;
                this.match(_QBasicParser.ID);
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
          this.state = 487;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 2) {
            {
              this.state = 482;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 484;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 141) {
                {
                  this.state = 483;
                  this.def_fn_parameter_list();
                }
              }
              this.state = 486;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
          }
          this.state = 495;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.EQ:
              {
                this.state = 489;
                this.match(_QBasicParser.EQ);
                this.state = 490;
                this.expr(0);
              }
              break;
            case _QBasicParser.COLON:
            case _QBasicParser.NL:
              {
                this.state = 491;
                this.block();
                this.state = 492;
                this.match(_QBasicParser.END);
                this.state = 493;
                this.match(_QBasicParser.DEF);
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    def_fn_parameter_list() {
      let localContext = new Def_fn_parameter_listContext(this.context, this.state);
      this.enterRule(localContext, 20, _QBasicParser.RULE_def_fn_parameter_list);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 497;
          this.def_fn_parameter();
          this.state = 502;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 498;
                this.match(_QBasicParser.COMMA);
                this.state = 499;
                this.def_fn_parameter();
              }
            }
            this.state = 504;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    def_fn_parameter() {
      let localContext = new Def_fn_parameterContext(this.context, this.state);
      this.enterRule(localContext, 22, _QBasicParser.RULE_def_fn_parameter);
      try {
        this.state = 510;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 30, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 505;
              this.untyped_id();
              this.state = 506;
              this.match(_QBasicParser.AS);
              this.state = 507;
              this.type_name_for_def_fn_parameter();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 509;
              this.match(_QBasicParser.ID);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    function_statement() {
      let localContext = new Function_statementContext(this.context, this.state);
      this.enterRule(localContext, 24, _QBasicParser.RULE_function_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 512;
          this.match(_QBasicParser.FUNCTION);
          this.state = 513;
          this.match(_QBasicParser.ID);
          this.state = 519;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 2) {
            {
              this.state = 514;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 516;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 141) {
                {
                  this.state = 515;
                  this.parameter_list();
                }
              }
              this.state = 518;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
          }
          this.state = 522;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 120) {
            {
              this.state = 521;
              this.match(_QBasicParser.STATIC);
            }
          }
          this.state = 524;
          this.block();
          this.state = 525;
          this.end_function_statement();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    parameter_list() {
      let localContext = new Parameter_listContext(this.context, this.state);
      this.enterRule(localContext, 26, _QBasicParser.RULE_parameter_list);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 527;
          this.parameter();
          this.state = 532;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 528;
                this.match(_QBasicParser.COMMA);
                this.state = 529;
                this.parameter();
              }
            }
            this.state = 534;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    parameter() {
      let localContext = new ParameterContext(this.context, this.state);
      this.enterRule(localContext, 28, _QBasicParser.RULE_parameter);
      let _la;
      try {
        this.state = 546;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 37, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 535;
              this.untyped_id();
              this.state = 537;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 536;
                  this.array_declaration();
                }
              }
              this.state = 539;
              this.match(_QBasicParser.AS);
              this.state = 540;
              this.type_name_for_parameter();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 542;
              this.match(_QBasicParser.ID);
              this.state = 544;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 543;
                  this.array_declaration();
                }
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    array_declaration() {
      let localContext = new Array_declarationContext(this.context, this.state);
      this.enterRule(localContext, 30, _QBasicParser.RULE_array_declaration);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 548;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 550;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 22) {
            {
              this.state = 549;
              this.match(_QBasicParser.DIGITS);
            }
          }
          this.state = 552;
          this.match(_QBasicParser.RIGHT_PAREN);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    end_function_statement() {
      let localContext = new End_function_statementContext(this.context, this.state);
      this.enterRule(localContext, 32, _QBasicParser.RULE_end_function_statement);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 555;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 22 || _la === 140 || _la === 141) {
            {
              this.state = 554;
              this.label();
            }
          }
          this.state = 557;
          this.match(_QBasicParser.END);
          this.state = 558;
          this.match(_QBasicParser.FUNCTION);
          this.state = 563;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 40, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                {
                  this.state = 559;
                  this.match(_QBasicParser.COLON);
                  this.state = 560;
                  this.statement();
                }
              }
            }
            this.state = 565;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 40, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    if_block_statement() {
      let localContext = new If_block_statementContext(this.context, this.state);
      this.enterRule(localContext, 34, _QBasicParser.RULE_if_block_statement);
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 566;
          this.match(_QBasicParser.IF);
          this.state = 567;
          this.expr(0);
          this.state = 568;
          this.match(_QBasicParser.THEN);
          this.state = 569;
          this.match(_QBasicParser.NL);
          this.state = 570;
          this.then_block();
          this.state = 574;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 41, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                {
                  this.state = 571;
                  this.elseif_block_statement();
                }
              }
            }
            this.state = 576;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 41, this.context);
          }
          this.state = 578;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 42, this.context)) {
            case 1:
              {
                this.state = 577;
                this.else_block_statement();
              }
              break;
          }
          this.state = 580;
          this.end_if_statement();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    elseif_block_statement() {
      let localContext = new Elseif_block_statementContext(this.context, this.state);
      this.enterRule(localContext, 36, _QBasicParser.RULE_elseif_block_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 583;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 22 || _la === 140 || _la === 141) {
            {
              this.state = 582;
              this.label();
            }
          }
          this.state = 585;
          this.match(_QBasicParser.ELSEIF);
          this.state = 586;
          this.expr(0);
          this.state = 587;
          this.match(_QBasicParser.THEN);
          this.state = 588;
          this.else_block();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    else_block_statement() {
      let localContext = new Else_block_statementContext(this.context, this.state);
      this.enterRule(localContext, 38, _QBasicParser.RULE_else_block_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 591;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 22 || _la === 140 || _la === 141) {
            {
              this.state = 590;
              this.label();
            }
          }
          this.state = 593;
          this.match(_QBasicParser.ELSE);
          this.state = 594;
          this.else_block();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    end_if_statement() {
      let localContext = new End_if_statementContext(this.context, this.state);
      this.enterRule(localContext, 40, _QBasicParser.RULE_end_if_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 597;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 22 || _la === 140 || _la === 141) {
            {
              this.state = 596;
              this.label();
            }
          }
          this.state = 599;
          this.match(_QBasicParser.END);
          this.state = 600;
          this.match(_QBasicParser.IF);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    then_block() {
      let localContext = new Then_blockContext(this.context, this.state);
      this.enterRule(localContext, 42, _QBasicParser.RULE_then_block);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 620;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 49, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                {
                  this.state = 603;
                  this.errorHandler.sync(this);
                  switch (this.interpreter.adaptivePredict(this.tokenStream, 46, this.context)) {
                    case 1:
                      {
                        this.state = 602;
                        this.label();
                      }
                      break;
                  }
                  this.state = 607;
                  this.errorHandler.sync(this);
                  switch (this.interpreter.adaptivePredict(this.tokenStream, 47, this.context)) {
                    case 1:
                      {
                        this.state = 605;
                        this.statement();
                      }
                      break;
                    case 2:
                      {
                        this.state = 606;
                        this.if_block_statement();
                      }
                      break;
                  }
                  this.state = 613;
                  this.errorHandler.sync(this);
                  _la = this.tokenStream.LA(1);
                  while (_la === 1) {
                    {
                      {
                        this.state = 609;
                        this.match(_QBasicParser.COLON);
                        this.state = 610;
                        this.statement();
                      }
                    }
                    this.state = 615;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                  }
                  this.state = 616;
                  this.match(_QBasicParser.NL);
                }
              }
            }
            this.state = 622;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 49, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    else_block() {
      let localContext = new Else_blockContext(this.context, this.state);
      this.enterRule(localContext, 44, _QBasicParser.RULE_else_block);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 623;
          this.statement();
          this.state = 628;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 1) {
            {
              {
                this.state = 624;
                this.match(_QBasicParser.COLON);
                this.state = 625;
                this.statement();
              }
            }
            this.state = 630;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
          this.state = 631;
          this.match(_QBasicParser.NL);
          this.state = 650;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 54, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                {
                  this.state = 633;
                  this.errorHandler.sync(this);
                  switch (this.interpreter.adaptivePredict(this.tokenStream, 51, this.context)) {
                    case 1:
                      {
                        this.state = 632;
                        this.label();
                      }
                      break;
                  }
                  this.state = 637;
                  this.errorHandler.sync(this);
                  switch (this.interpreter.adaptivePredict(this.tokenStream, 52, this.context)) {
                    case 1:
                      {
                        this.state = 635;
                        this.statement();
                      }
                      break;
                    case 2:
                      {
                        this.state = 636;
                        this.if_block_statement();
                      }
                      break;
                  }
                  this.state = 643;
                  this.errorHandler.sync(this);
                  _la = this.tokenStream.LA(1);
                  while (_la === 1) {
                    {
                      {
                        this.state = 639;
                        this.match(_QBasicParser.COLON);
                        this.state = 640;
                        this.statement();
                      }
                    }
                    this.state = 645;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                  }
                  this.state = 646;
                  this.match(_QBasicParser.NL);
                }
              }
            }
            this.state = 652;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 54, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    option_statement() {
      let localContext = new Option_statementContext(this.context, this.state);
      this.enterRule(localContext, 46, _QBasicParser.RULE_option_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 653;
          this.match(_QBasicParser.OPTION);
          this.state = 654;
          this.match(_QBasicParser.BASE);
          this.state = 655;
          this.match(_QBasicParser.DIGITS);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    sub_statement() {
      let localContext = new Sub_statementContext(this.context, this.state);
      this.enterRule(localContext, 48, _QBasicParser.RULE_sub_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 657;
          this.match(_QBasicParser.SUB);
          this.state = 658;
          this.untyped_id();
          this.state = 664;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 2) {
            {
              this.state = 659;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 661;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 141) {
                {
                  this.state = 660;
                  this.parameter_list();
                }
              }
              this.state = 663;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
          }
          this.state = 667;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 120) {
            {
              this.state = 666;
              this.match(_QBasicParser.STATIC);
            }
          }
          this.state = 669;
          this.block();
          this.state = 670;
          this.end_sub_statement();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    end_sub_statement() {
      let localContext = new End_sub_statementContext(this.context, this.state);
      this.enterRule(localContext, 50, _QBasicParser.RULE_end_sub_statement);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 673;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 22 || _la === 140 || _la === 141) {
            {
              this.state = 672;
              this.label();
            }
          }
          this.state = 675;
          this.match(_QBasicParser.END);
          this.state = 676;
          this.match(_QBasicParser.SUB);
          this.state = 681;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 59, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                {
                  this.state = 677;
                  this.match(_QBasicParser.COLON);
                  this.state = 678;
                  this.statement();
                }
              }
            }
            this.state = 683;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 59, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    type_statement() {
      let localContext = new Type_statementContext(this.context, this.state);
      this.enterRule(localContext, 52, _QBasicParser.RULE_type_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 684;
          this.match(_QBasicParser.TYPE);
          this.state = 687;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.ID:
              {
                this.state = 685;
                this.untyped_id();
              }
              break;
            case _QBasicParser.FNID:
              {
                this.state = 686;
                this.untyped_fnid();
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
          this.state = 690;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          do {
            {
              {
                this.state = 689;
                _la = this.tokenStream.LA(1);
                if (!(_la === 1 || _la === 143)) {
                  this.errorHandler.recoverInline(this);
                } else {
                  this.errorHandler.reportMatch(this);
                  this.consume();
                }
              }
            }
            this.state = 692;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          } while (_la === 1 || _la === 143);
          this.state = 698;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          do {
            {
              this.state = 698;
              this.errorHandler.sync(this);
              switch (this.tokenStream.LA(1)) {
                case _QBasicParser.REM:
                  {
                    this.state = 694;
                    this.rem_statement();
                    this.state = 695;
                    this.match(_QBasicParser.NL);
                  }
                  break;
                case _QBasicParser.FNID:
                case _QBasicParser.ID:
                  {
                    this.state = 697;
                    this.type_element();
                  }
                  break;
                default:
                  throw new NoViableAltException(this);
              }
            }
            this.state = 700;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          } while ((_la - 110 & ~31) === 0 && (1 << _la - 110 & 3221225473) !== 0);
          this.state = 702;
          this.match(_QBasicParser.END);
          this.state = 703;
          this.match(_QBasicParser.TYPE);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    type_element() {
      let localContext = new Type_elementContext(this.context, this.state);
      this.enterRule(localContext, 54, _QBasicParser.RULE_type_element);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 707;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.ID:
              {
                this.state = 705;
                this.untyped_id();
              }
              break;
            case _QBasicParser.FNID:
              {
                this.state = 706;
                this.untyped_fnid();
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
          this.state = 709;
          this.match(_QBasicParser.AS);
          this.state = 710;
          this.type_name_for_type_element();
          this.state = 712;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          do {
            {
              {
                this.state = 711;
                _la = this.tokenStream.LA(1);
                if (!(_la === 1 || _la === 143)) {
                  this.errorHandler.recoverInline(this);
                } else {
                  this.errorHandler.reportMatch(this);
                  this.consume();
                }
              }
            }
            this.state = 714;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          } while (_la === 1 || _la === 143);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    assignment_statement() {
      let localContext = new Assignment_statementContext(this.context, this.state);
      this.enterRule(localContext, 56, _QBasicParser.RULE_assignment_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 717;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 79) {
            {
              this.state = 716;
              this.match(_QBasicParser.LET);
            }
          }
          this.state = 719;
          this.variable_or_function_call();
          this.state = 720;
          this.match(_QBasicParser.EQ);
          this.state = 721;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    call_statement() {
      let localContext = new Call_statementContext(this.context, this.state);
      this.enterRule(localContext, 58, _QBasicParser.RULE_call_statement);
      let _la;
      try {
        this.state = 735;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.CALL:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 723;
              this.match(_QBasicParser.CALL);
              this.state = 724;
              this.untyped_id();
              this.state = 729;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 725;
                  this.match(_QBasicParser.LEFT_PAREN);
                  this.state = 726;
                  this.call_argument_list();
                  this.state = 727;
                  this.match(_QBasicParser.RIGHT_PAREN);
                }
              }
            }
            break;
          case _QBasicParser.ID:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 731;
              this.untyped_id();
              this.state = 733;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 68, this.context)) {
                case 1:
                  {
                    this.state = 732;
                    this.call_argument_list();
                  }
                  break;
              }
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    call_argument_list() {
      let localContext = new Call_argument_listContext(this.context, this.state);
      this.enterRule(localContext, 60, _QBasicParser.RULE_call_argument_list);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 737;
          this.call_argument();
          this.state = 742;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 738;
                this.match(_QBasicParser.COMMA);
                this.state = 739;
                this.call_argument();
              }
            }
            this.state = 744;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    call_argument() {
      let localContext = new Call_argumentContext(this.context, this.state);
      this.enterRule(localContext, 62, _QBasicParser.RULE_call_argument);
      let _la;
      try {
        this.state = 753;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 72, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 745;
              this.match(_QBasicParser.ID);
              this.state = 746;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 747;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 748;
              this.match(_QBasicParser.ID);
              this.state = 750;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 749;
                  this.args_or_indices();
                }
              }
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 752;
              this.expr(0);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    call_absolute_statement() {
      let localContext = new Call_absolute_statementContext(this.context, this.state);
      this.enterRule(localContext, 64, _QBasicParser.RULE_call_absolute_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 755;
          this.match(_QBasicParser.CALL);
          this.state = 756;
          this.match(_QBasicParser.ABSOLUTE);
          this.state = 757;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 761;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 73, this.context)) {
            case 1:
              {
                this.state = 758;
                this.call_absolute_argument_list();
                this.state = 759;
                this.match(_QBasicParser.COMMA);
              }
              break;
          }
          this.state = 763;
          this.expr(0);
          this.state = 764;
          this.match(_QBasicParser.RIGHT_PAREN);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    call_absolute_argument_list() {
      let localContext = new Call_absolute_argument_listContext(this.context, this.state);
      this.enterRule(localContext, 66, _QBasicParser.RULE_call_absolute_argument_list);
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 766;
          this.expr(0);
          this.state = 771;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 74, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                {
                  this.state = 767;
                  this.match(_QBasicParser.COMMA);
                  this.state = 768;
                  this.expr(0);
                }
              }
            }
            this.state = 773;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 74, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    error_statement() {
      let localContext = new Error_statementContext(this.context, this.state);
      this.enterRule(localContext, 68, _QBasicParser.RULE_error_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 774;
          this.match(_QBasicParser.ERROR);
          this.state = 775;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    event_control_statement() {
      let localContext = new Event_control_statementContext(this.context, this.state);
      this.enterRule(localContext, 70, _QBasicParser.RULE_event_control_statement);
      let _la;
      try {
        this.state = 801;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.COM:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 777;
              this.match(_QBasicParser.COM);
              this.state = 778;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 779;
              this.expr(0);
              this.state = 780;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 781;
              _la = this.tokenStream.LA(1);
              if (!((_la - 94 & ~31) === 0 && (1 << _la - 94 & 268435473) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
            break;
          case _QBasicParser.KEY:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 783;
              this.match(_QBasicParser.KEY);
              this.state = 784;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 785;
              this.expr(0);
              this.state = 786;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 787;
              _la = this.tokenStream.LA(1);
              if (!((_la - 94 & ~31) === 0 && (1 << _la - 94 & 268435473) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
            break;
          case _QBasicParser.PEN:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 789;
              this.match(_QBasicParser.PEN);
              this.state = 790;
              _la = this.tokenStream.LA(1);
              if (!((_la - 94 & ~31) === 0 && (1 << _la - 94 & 268435473) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
            break;
          case _QBasicParser.PLAY:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 791;
              this.match(_QBasicParser.PLAY);
              this.state = 792;
              _la = this.tokenStream.LA(1);
              if (!((_la - 94 & ~31) === 0 && (1 << _la - 94 & 268435473) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
            break;
          case _QBasicParser.STRIG:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 793;
              this.match(_QBasicParser.STRIG);
              this.state = 794;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 795;
              this.expr(0);
              this.state = 796;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 797;
              _la = this.tokenStream.LA(1);
              if (!((_la - 94 & ~31) === 0 && (1 << _la - 94 & 268435473) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
            break;
          case _QBasicParser.TIMER:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 799;
              this.match(_QBasicParser.TIMER);
              this.state = 800;
              _la = this.tokenStream.LA(1);
              if (!((_la - 94 & ~31) === 0 && (1 << _la - 94 & 268435473) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    circle_statement() {
      let localContext = new Circle_statementContext(this.context, this.state);
      this.enterRule(localContext, 72, _QBasicParser.RULE_circle_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 803;
          this.match(_QBasicParser.CIRCLE);
          this.state = 805;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 804;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 807;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 808;
          localContext._x = this.expr(0);
          this.state = 809;
          this.match(_QBasicParser.COMMA);
          this.state = 810;
          localContext._y = this.expr(0);
          this.state = 811;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 812;
          this.match(_QBasicParser.COMMA);
          this.state = 813;
          localContext._radius = this.expr(0);
          this.state = 848;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 84, this.context)) {
            case 1:
              {
                this.state = 814;
                this.match(_QBasicParser.COMMA);
                this.state = 816;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 815;
                    localContext._color = this.expr(0);
                  }
                }
                this.state = 818;
                this.match(_QBasicParser.COMMA);
                this.state = 820;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 819;
                    localContext._start = this.expr(0);
                  }
                }
                this.state = 822;
                this.match(_QBasicParser.COMMA);
                this.state = 824;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 823;
                    localContext._end = this.expr(0);
                  }
                }
                this.state = 826;
                this.match(_QBasicParser.COMMA);
                this.state = 827;
                localContext._aspect = this.expr(0);
              }
              break;
            case 2:
              {
                this.state = 828;
                this.match(_QBasicParser.COMMA);
                this.state = 830;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 829;
                    localContext._color = this.expr(0);
                  }
                }
                this.state = 832;
                this.match(_QBasicParser.COMMA);
                this.state = 834;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 833;
                    localContext._start = this.expr(0);
                  }
                }
                this.state = 836;
                this.match(_QBasicParser.COMMA);
                this.state = 837;
                localContext._end = this.expr(0);
              }
              break;
            case 3:
              {
                this.state = 838;
                this.match(_QBasicParser.COMMA);
                this.state = 840;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 839;
                    localContext._color = this.expr(0);
                  }
                }
                this.state = 842;
                this.match(_QBasicParser.COMMA);
                this.state = 843;
                localContext._start = this.expr(0);
              }
              break;
            case 4:
              {
                this.state = 844;
                this.match(_QBasicParser.COMMA);
                this.state = 846;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 83, this.context)) {
                  case 1:
                    {
                      this.state = 845;
                      localContext._color = this.expr(0);
                    }
                    break;
                }
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    clear_statement() {
      let localContext = new Clear_statementContext(this.context, this.state);
      this.enterRule(localContext, 74, _QBasicParser.RULE_clear_statement);
      let _la;
      try {
        this.state = 870;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 89, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 850;
              this.match(_QBasicParser.CLEAR);
              this.state = 852;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 85, this.context)) {
                case 1:
                  {
                    this.state = 851;
                    this.expr(0);
                  }
                  break;
              }
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 854;
              this.match(_QBasicParser.CLEAR);
              this.state = 856;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                {
                  this.state = 855;
                  this.expr(0);
                }
              }
              this.state = 858;
              this.match(_QBasicParser.COMMA);
              this.state = 859;
              this.expr(0);
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 860;
              this.match(_QBasicParser.CLEAR);
              this.state = 862;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                {
                  this.state = 861;
                  this.expr(0);
                }
              }
              this.state = 864;
              this.match(_QBasicParser.COMMA);
              this.state = 866;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                {
                  this.state = 865;
                  this.expr(0);
                }
              }
              this.state = 868;
              this.match(_QBasicParser.COMMA);
              this.state = 869;
              localContext._stacksize = this.expr(0);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    close_statement() {
      let localContext = new Close_statementContext(this.context, this.state);
      this.enterRule(localContext, 76, _QBasicParser.RULE_close_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 872;
          this.match(_QBasicParser.CLOSE);
          this.state = 877;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 91, this.context)) {
            case 1:
              {
                this.state = 874;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 4) {
                  {
                    this.state = 873;
                    this.match(_QBasicParser.NUMBER);
                  }
                }
                this.state = 876;
                this.expr(0);
              }
              break;
          }
          this.state = 886;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 879;
                this.match(_QBasicParser.COMMA);
                this.state = 881;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 4) {
                  {
                    this.state = 880;
                    this.match(_QBasicParser.NUMBER);
                  }
                }
                this.state = 883;
                this.expr(0);
              }
            }
            this.state = 888;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    color_statement() {
      let localContext = new Color_statementContext(this.context, this.state);
      this.enterRule(localContext, 78, _QBasicParser.RULE_color_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 889;
          this.match(_QBasicParser.COLOR);
          this.state = 907;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 98, this.context)) {
            case 1:
              {
                this.state = 891;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 890;
                    localContext._arg1 = this.expr(0);
                  }
                }
                this.state = 893;
                this.match(_QBasicParser.COMMA);
                this.state = 895;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 894;
                    localContext._arg2 = this.expr(0);
                  }
                }
                this.state = 897;
                this.match(_QBasicParser.COMMA);
                {
                  this.state = 898;
                  localContext._arg3 = this.expr(0);
                }
              }
              break;
            case 2:
              {
                this.state = 900;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 899;
                    localContext._arg1 = this.expr(0);
                  }
                }
                this.state = 902;
                this.match(_QBasicParser.COMMA);
                {
                  this.state = 903;
                  localContext._arg2 = this.expr(0);
                }
              }
              break;
            case 3:
              {
                this.state = 905;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 97, this.context)) {
                  case 1:
                    {
                      this.state = 904;
                      localContext._arg1 = this.expr(0);
                    }
                    break;
                }
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    const_statement() {
      let localContext = new Const_statementContext(this.context, this.state);
      this.enterRule(localContext, 80, _QBasicParser.RULE_const_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 909;
          this.match(_QBasicParser.CONST);
          this.state = 910;
          this.const_assignment();
          this.state = 915;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 911;
                this.match(_QBasicParser.COMMA);
                this.state = 912;
                this.const_assignment();
              }
            }
            this.state = 917;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    const_assignment() {
      let localContext = new Const_assignmentContext(this.context, this.state);
      this.enterRule(localContext, 82, _QBasicParser.RULE_const_assignment);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 918;
          this.match(_QBasicParser.ID);
          this.state = 919;
          this.match(_QBasicParser.EQ);
          this.state = 920;
          this.const_expr();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    const_expr() {
      let localContext = new Const_exprContext(this.context, this.state);
      this.enterRule(localContext, 84, _QBasicParser.RULE_const_expr);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 922;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    data_statement() {
      let localContext = new Data_statementContext(this.context, this.state);
      this.enterRule(localContext, 86, _QBasicParser.RULE_data_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 924;
          this.match(_QBasicParser.DATA);
          this.state = 925;
          this.data_item();
          this.state = 930;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 151) {
            {
              {
                this.state = 926;
                this.match(_QBasicParser.DATA_COMMA);
                this.state = 927;
                this.data_item();
              }
            }
            this.state = 932;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    data_item() {
      let localContext = new Data_itemContext(this.context, this.state);
      this.enterRule(localContext, 88, _QBasicParser.RULE_data_item);
      try {
        this.state = 936;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.DATA_QUOTED:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 933;
              this.match(_QBasicParser.DATA_QUOTED);
            }
            break;
          case _QBasicParser.DATA_UNQUOTED:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 934;
              this.match(_QBasicParser.DATA_UNQUOTED);
            }
            break;
          case _QBasicParser.COLON:
          case _QBasicParser.DIGITS:
          case _QBasicParser.CASE:
          case _QBasicParser.DECLARE:
          case _QBasicParser.DEF:
          case _QBasicParser.ELSE:
          case _QBasicParser.END:
          case _QBasicParser.LOOP:
          case _QBasicParser.NEXT:
          case _QBasicParser.OPTION:
          case _QBasicParser.TYPE:
          case _QBasicParser.WEND:
          case _QBasicParser.FNID:
          case _QBasicParser.ID:
          case _QBasicParser.NL:
          case _QBasicParser.NEXT_WITH_MANDATORY_ID:
          case _QBasicParser.DATA_COMMA:
            this.enterOuterAlt(localContext, 3);
            {
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    def_seg_statement() {
      let localContext = new Def_seg_statementContext(this.context, this.state);
      this.enterRule(localContext, 90, _QBasicParser.RULE_def_seg_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 938;
          this.match(_QBasicParser.DEF);
          this.state = 939;
          this.match(_QBasicParser.SEG);
          this.state = 942;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 16) {
            {
              this.state = 940;
              this.match(_QBasicParser.EQ);
              this.state = 941;
              this.expr(0);
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    deftype_statement() {
      let localContext = new Deftype_statementContext(this.context, this.state);
      this.enterRule(localContext, 92, _QBasicParser.RULE_deftype_statement);
      let _la;
      try {
        this.state = 989;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.DEFINT:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 944;
              this.match(_QBasicParser.DEFINT);
              this.state = 945;
              this.letter_range();
              this.state = 950;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 946;
                    this.match(_QBasicParser.COMMA);
                    this.state = 947;
                    this.letter_range();
                  }
                }
                this.state = 952;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case _QBasicParser.DEFLNG:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 953;
              this.match(_QBasicParser.DEFLNG);
              this.state = 954;
              this.letter_range();
              this.state = 959;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 955;
                    this.match(_QBasicParser.COMMA);
                    this.state = 956;
                    this.letter_range();
                  }
                }
                this.state = 961;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case _QBasicParser.DEFSNG:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 962;
              this.match(_QBasicParser.DEFSNG);
              this.state = 963;
              this.letter_range();
              this.state = 968;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 964;
                    this.match(_QBasicParser.COMMA);
                    this.state = 965;
                    this.letter_range();
                  }
                }
                this.state = 970;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case _QBasicParser.DEFDBL:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 971;
              this.match(_QBasicParser.DEFDBL);
              this.state = 972;
              this.letter_range();
              this.state = 977;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 973;
                    this.match(_QBasicParser.COMMA);
                    this.state = 974;
                    this.letter_range();
                  }
                }
                this.state = 979;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case _QBasicParser.DEFSTR:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 980;
              this.match(_QBasicParser.DEFSTR);
              this.state = 981;
              this.letter_range();
              this.state = 986;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 982;
                    this.match(_QBasicParser.COMMA);
                    this.state = 983;
                    this.letter_range();
                  }
                }
                this.state = 988;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    letter_range() {
      let localContext = new Letter_rangeContext(this.context, this.state);
      this.enterRule(localContext, 94, _QBasicParser.RULE_letter_range);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 991;
          _la = this.tokenStream.LA(1);
          if (!(_la === 140 || _la === 141)) {
            this.errorHandler.recoverInline(this);
          } else {
            this.errorHandler.reportMatch(this);
            this.consume();
          }
          this.state = 994;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 8) {
            {
              this.state = 992;
              this.match(_QBasicParser.MINUS);
              this.state = 993;
              _la = this.tokenStream.LA(1);
              if (!(_la === 140 || _la === 141)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    dim_statement() {
      let localContext = new Dim_statementContext(this.context, this.state);
      this.enterRule(localContext, 96, _QBasicParser.RULE_dim_statement);
      let _la;
      try {
        this.state = 1020;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.DIM:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 996;
              this.match(_QBasicParser.DIM);
              this.state = 998;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 118) {
                {
                  this.state = 997;
                  this.match(_QBasicParser.SHARED);
                }
              }
              this.state = 1e3;
              this.dim_variable();
              this.state = 1005;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1001;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1002;
                    this.dim_variable();
                  }
                }
                this.state = 1007;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case _QBasicParser.REDIM:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1008;
              this.match(_QBasicParser.REDIM);
              this.state = 1010;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 118) {
                {
                  this.state = 1009;
                  this.match(_QBasicParser.SHARED);
                }
              }
              this.state = 1012;
              this.dim_variable();
              this.state = 1017;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1013;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1014;
                    this.dim_variable();
                  }
                }
                this.state = 1019;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    dim_variable() {
      let localContext = new Dim_variableContext(this.context, this.state);
      this.enterRule(localContext, 98, _QBasicParser.RULE_dim_variable);
      let _la;
      try {
        this.state = 1033;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 117, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1022;
              this.untyped_id();
              this.state = 1024;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 1023;
                  this.dim_array_bounds();
                }
              }
              this.state = 1026;
              this.match(_QBasicParser.AS);
              this.state = 1027;
              this.type_name();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1029;
              this.match(_QBasicParser.ID);
              this.state = 1031;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 1030;
                  this.dim_array_bounds();
                }
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    dim_array_bounds() {
      let localContext = new Dim_array_boundsContext(this.context, this.state);
      this.enterRule(localContext, 100, _QBasicParser.RULE_dim_array_bounds);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1035;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1036;
          this.dim_subscript();
          this.state = 1041;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 1037;
                this.match(_QBasicParser.COMMA);
                this.state = 1038;
                this.dim_subscript();
              }
            }
            this.state = 1043;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
          this.state = 1044;
          this.match(_QBasicParser.RIGHT_PAREN);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    dim_subscript() {
      let localContext = new Dim_subscriptContext(this.context, this.state);
      this.enterRule(localContext, 102, _QBasicParser.RULE_dim_subscript);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1049;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 119, this.context)) {
            case 1:
              {
                this.state = 1046;
                localContext._lower = this.expr(0);
                this.state = 1047;
                this.match(_QBasicParser.TO);
              }
              break;
          }
          this.state = 1051;
          localContext._upper = this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    do_loop_statement() {
      let localContext = new Do_loop_statementContext(this.context, this.state);
      this.enterRule(localContext, 104, _QBasicParser.RULE_do_loop_statement);
      try {
        this.state = 1068;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 120, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              {
                this.state = 1053;
                this.match(_QBasicParser.DO);
                this.state = 1054;
                this.do_condition();
              }
              this.state = 1056;
              this.block();
              this.state = 1057;
              this.match(_QBasicParser.LOOP);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1059;
              this.match(_QBasicParser.DO);
              this.state = 1060;
              this.block();
              {
                this.state = 1061;
                this.match(_QBasicParser.LOOP);
                this.state = 1062;
                this.do_condition();
              }
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1064;
              this.match(_QBasicParser.DO);
              this.state = 1065;
              this.block();
              this.state = 1066;
              this.match(_QBasicParser.LOOP);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    do_condition() {
      let localContext = new Do_conditionContext(this.context, this.state);
      this.enterRule(localContext, 106, _QBasicParser.RULE_do_condition);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1074;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.WHILE:
              {
                this.state = 1070;
                this.match(_QBasicParser.WHILE);
                this.state = 1071;
                this.expr(0);
              }
              break;
            case _QBasicParser.UNTIL:
              {
                this.state = 1072;
                this.match(_QBasicParser.UNTIL);
                this.state = 1073;
                this.expr(0);
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    end_statement() {
      let localContext = new End_statementContext(this.context, this.state);
      this.enterRule(localContext, 108, _QBasicParser.RULE_end_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1076;
          this.match(_QBasicParser.END);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    exit_statement() {
      let localContext = new Exit_statementContext(this.context, this.state);
      this.enterRule(localContext, 110, _QBasicParser.RULE_exit_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1078;
          this.match(_QBasicParser.EXIT);
          this.state = 1079;
          _la = this.tokenStream.LA(1);
          if (!((_la - 47 & ~31) === 0 && (1 << _la - 47 & 327809) !== 0 || _la === 125)) {
            this.errorHandler.recoverInline(this);
          } else {
            this.errorHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    field_statement() {
      let localContext = new Field_statementContext(this.context, this.state);
      this.enterRule(localContext, 112, _QBasicParser.RULE_field_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1081;
          this.match(_QBasicParser.FIELD);
          this.state = 1083;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1082;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1085;
          this.expr(0);
          this.state = 1086;
          this.match(_QBasicParser.COMMA);
          this.state = 1087;
          this.field_assignment();
          this.state = 1092;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 1088;
                this.match(_QBasicParser.COMMA);
                this.state = 1089;
                this.field_assignment();
              }
            }
            this.state = 1094;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    field_assignment() {
      let localContext = new Field_assignmentContext(this.context, this.state);
      this.enterRule(localContext, 114, _QBasicParser.RULE_field_assignment);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1095;
          this.expr(0);
          this.state = 1096;
          this.match(_QBasicParser.AS);
          this.state = 1097;
          this.variable_or_function_call();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    for_next_statement() {
      let localContext = new For_next_statementContext(this.context, this.state);
      this.enterRule(localContext, 116, _QBasicParser.RULE_for_next_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1099;
          this.match(_QBasicParser.FOR);
          this.state = 1100;
          this.match(_QBasicParser.ID);
          this.state = 1101;
          this.match(_QBasicParser.EQ);
          this.state = 1102;
          this.expr(0);
          this.state = 1103;
          this.match(_QBasicParser.TO);
          this.state = 1104;
          this.expr(0);
          this.state = 1107;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1105;
              this.match(_QBasicParser.STEP);
              this.state = 1106;
              this.expr(0);
            }
          }
          this.state = 1109;
          this.block();
          this.state = 1116;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.NEXT:
              {
                this.state = 1110;
                this.match(_QBasicParser.NEXT);
                this.state = 1112;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 125, this.context)) {
                  case 1:
                    {
                      this.state = 1111;
                      this.match(_QBasicParser.ID);
                    }
                    break;
                }
              }
              break;
            case _QBasicParser.NEXT_WITH_MANDATORY_ID:
              {
                this.state = 1114;
                this.match(_QBasicParser.NEXT_WITH_MANDATORY_ID);
                this.state = 1115;
                this.match(_QBasicParser.ID);
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    get_graphics_statement() {
      let localContext = new Get_graphics_statementContext(this.context, this.state);
      this.enterRule(localContext, 118, _QBasicParser.RULE_get_graphics_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1118;
          this.match(_QBasicParser.GET);
          this.state = 1120;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1119;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 1122;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1123;
          localContext._x1 = this.expr(0);
          this.state = 1124;
          this.match(_QBasicParser.COMMA);
          this.state = 1125;
          localContext._y1 = this.expr(0);
          this.state = 1126;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1127;
          this.match(_QBasicParser.MINUS);
          this.state = 1129;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1128;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 1131;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1132;
          localContext._x2 = this.expr(0);
          this.state = 1133;
          this.match(_QBasicParser.COMMA);
          this.state = 1134;
          localContext._y2 = this.expr(0);
          this.state = 1135;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1136;
          this.match(_QBasicParser.COMMA);
          this.state = 1137;
          localContext._arrayname = this.variable_or_function_call();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    get_io_statement() {
      let localContext = new Get_io_statementContext(this.context, this.state);
      this.enterRule(localContext, 120, _QBasicParser.RULE_get_io_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1139;
          this.match(_QBasicParser.GET);
          this.state = 1141;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1140;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1143;
          this.expr(0);
          this.state = 1152;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1144;
              this.match(_QBasicParser.COMMA);
              this.state = 1146;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 130, this.context)) {
                case 1:
                  {
                    this.state = 1145;
                    this.expr(0);
                  }
                  break;
              }
              this.state = 1150;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 11) {
                {
                  this.state = 1148;
                  this.match(_QBasicParser.COMMA);
                  this.state = 1149;
                  this.variable_or_function_call();
                }
              }
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    gosub_statement() {
      let localContext = new Gosub_statementContext(this.context, this.state);
      this.enterRule(localContext, 122, _QBasicParser.RULE_gosub_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1154;
          this.match(_QBasicParser.GOSUB);
          this.state = 1155;
          this.target();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    goto_statement() {
      let localContext = new Goto_statementContext(this.context, this.state);
      this.enterRule(localContext, 124, _QBasicParser.RULE_goto_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1157;
          this.match(_QBasicParser.GOTO);
          this.state = 1158;
          this.target();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    target() {
      let localContext = new TargetContext(this.context, this.state);
      this.enterRule(localContext, 126, _QBasicParser.RULE_target);
      try {
        this.state = 1162;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.DIGITS:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1160;
              this.line_number();
            }
            break;
          case _QBasicParser.FNID:
          case _QBasicParser.ID:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1161;
              this.text_label();
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    if_inline_statement() {
      let localContext = new If_inline_statementContext(this.context, this.state);
      this.enterRule(localContext, 128, _QBasicParser.RULE_if_inline_statement);
      try {
        this.state = 1179;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 136, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1164;
              this.match(_QBasicParser.IF);
              this.state = 1165;
              this.expr(0);
              this.state = 1166;
              this.match(_QBasicParser.THEN);
              this.state = 1167;
              this.if_inline_action();
              this.state = 1170;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 134, this.context)) {
                case 1:
                  {
                    this.state = 1168;
                    this.match(_QBasicParser.ELSE);
                    this.state = 1169;
                    this.if_inline_action();
                  }
                  break;
              }
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1172;
              this.match(_QBasicParser.IF);
              this.state = 1173;
              this.expr(0);
              this.state = 1174;
              this.goto_statement();
              this.state = 1177;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 135, this.context)) {
                case 1:
                  {
                    this.state = 1175;
                    this.match(_QBasicParser.ELSE);
                    this.state = 1176;
                    this.if_inline_action();
                  }
                  break;
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    if_inline_action() {
      let localContext = new If_inline_actionContext(this.context, this.state);
      this.enterRule(localContext, 130, _QBasicParser.RULE_if_inline_action);
      try {
        let alternative;
        this.state = 1190;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 138, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1181;
              this.statement();
              this.state = 1186;
              this.errorHandler.sync(this);
              alternative = this.interpreter.adaptivePredict(this.tokenStream, 137, this.context);
              while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
                if (alternative === 1) {
                  {
                    {
                      this.state = 1182;
                      this.match(_QBasicParser.COLON);
                      this.state = 1183;
                      this.statement();
                    }
                  }
                }
                this.state = 1188;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 137, this.context);
              }
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1189;
              this.line_number();
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    input_statement() {
      let localContext = new Input_statementContext(this.context, this.state);
      this.enterRule(localContext, 132, _QBasicParser.RULE_input_statement);
      let _la;
      try {
        this.state = 1219;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 143, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1192;
              this.match(_QBasicParser.INPUT);
              this.state = 1194;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 12) {
                {
                  this.state = 1193;
                  this.match(_QBasicParser.SEMICOLON);
                }
              }
              this.state = 1198;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 27) {
                {
                  this.state = 1196;
                  this.match(_QBasicParser.STRING_LITERAL);
                  this.state = 1197;
                  _la = this.tokenStream.LA(1);
                  if (!(_la === 11 || _la === 12)) {
                    this.errorHandler.recoverInline(this);
                  } else {
                    this.errorHandler.reportMatch(this);
                    this.consume();
                  }
                }
              }
              this.state = 1200;
              this.variable_or_function_call();
              this.state = 1205;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1201;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1202;
                    this.variable_or_function_call();
                  }
                }
                this.state = 1207;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1208;
              this.match(_QBasicParser.INPUT);
              this.state = 1209;
              this.file_number();
              this.state = 1210;
              this.match(_QBasicParser.COMMA);
              this.state = 1211;
              this.variable_or_function_call();
              this.state = 1216;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1212;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1213;
                    this.variable_or_function_call();
                  }
                }
                this.state = 1218;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    ioctl_statement() {
      let localContext = new Ioctl_statementContext(this.context, this.state);
      this.enterRule(localContext, 134, _QBasicParser.RULE_ioctl_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1221;
          this.match(_QBasicParser.IOCTL);
          this.state = 1223;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1222;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1225;
          this.expr(0);
          this.state = 1226;
          this.match(_QBasicParser.COMMA);
          this.state = 1227;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    key_statement() {
      let localContext = new Key_statementContext(this.context, this.state);
      this.enterRule(localContext, 136, _QBasicParser.RULE_key_statement);
      let _la;
      try {
        this.state = 1238;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 145, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1229;
              this.match(_QBasicParser.KEY);
              this.state = 1230;
              this.match(_QBasicParser.LIST);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1231;
              this.match(_QBasicParser.KEY);
              this.state = 1232;
              _la = this.tokenStream.LA(1);
              if (!(_la === 94 || _la === 98)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1233;
              this.match(_QBasicParser.KEY);
              this.state = 1234;
              this.expr(0);
              this.state = 1235;
              this.match(_QBasicParser.COMMA);
              this.state = 1236;
              this.expr(0);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    line_statement() {
      let localContext = new Line_statementContext(this.context, this.state);
      this.enterRule(localContext, 138, _QBasicParser.RULE_line_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1240;
          this.match(_QBasicParser.LINE);
          this.state = 1250;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 2 || _la === 121) {
            {
              this.state = 1242;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 121) {
                {
                  this.state = 1241;
                  this.match(_QBasicParser.STEP);
                }
              }
              this.state = 1244;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1245;
              localContext._x1 = this.expr(0);
              this.state = 1246;
              this.match(_QBasicParser.COMMA);
              this.state = 1247;
              localContext._y1 = this.expr(0);
              this.state = 1248;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
          }
          this.state = 1252;
          this.match(_QBasicParser.MINUS);
          this.state = 1254;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1253;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 1256;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1257;
          localContext._x2 = this.expr(0);
          this.state = 1258;
          this.match(_QBasicParser.COMMA);
          this.state = 1259;
          localContext._y2 = this.expr(0);
          this.state = 1260;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1284;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 154, this.context)) {
            case 1:
              {
                this.state = 1261;
                this.match(_QBasicParser.COMMA);
                this.state = 1263;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1262;
                    localContext._color = this.expr(0);
                  }
                }
                this.state = 1265;
                this.match(_QBasicParser.COMMA);
                this.state = 1267;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 141) {
                  {
                    this.state = 1266;
                    localContext._box = this.box_style();
                  }
                }
                this.state = 1269;
                this.match(_QBasicParser.COMMA);
                this.state = 1270;
                localContext._style = this.expr(0);
              }
              break;
            case 2:
              {
                this.state = 1271;
                this.match(_QBasicParser.COMMA);
                this.state = 1273;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1272;
                    localContext._color = this.expr(0);
                  }
                }
                this.state = 1275;
                this.match(_QBasicParser.COMMA);
                this.state = 1276;
                localContext._box = this.box_style();
              }
              break;
            case 3:
              {
                this.state = 1277;
                this.match(_QBasicParser.COMMA);
                this.state = 1279;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 152, this.context)) {
                  case 1:
                    {
                      this.state = 1278;
                      localContext._color = this.expr(0);
                    }
                    break;
                }
                this.state = 1282;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 11) {
                  {
                    this.state = 1281;
                    this.match(_QBasicParser.COMMA);
                  }
                }
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    box_style() {
      let localContext = new Box_styleContext(this.context, this.state);
      this.enterRule(localContext, 140, _QBasicParser.RULE_box_style);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1286;
          this.match(_QBasicParser.ID);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    line_input_statement() {
      let localContext = new Line_input_statementContext(this.context, this.state);
      this.enterRule(localContext, 142, _QBasicParser.RULE_line_input_statement);
      let _la;
      try {
        this.state = 1304;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 157, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1288;
              this.match(_QBasicParser.LINE);
              this.state = 1289;
              this.match(_QBasicParser.INPUT);
              this.state = 1291;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 12) {
                {
                  this.state = 1290;
                  this.match(_QBasicParser.SEMICOLON);
                }
              }
              this.state = 1295;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 27) {
                {
                  this.state = 1293;
                  this.match(_QBasicParser.STRING_LITERAL);
                  this.state = 1294;
                  _la = this.tokenStream.LA(1);
                  if (!(_la === 11 || _la === 12)) {
                    this.errorHandler.recoverInline(this);
                  } else {
                    this.errorHandler.reportMatch(this);
                    this.consume();
                  }
                }
              }
              this.state = 1297;
              this.variable_or_function_call();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1298;
              this.match(_QBasicParser.LINE);
              this.state = 1299;
              this.match(_QBasicParser.INPUT);
              this.state = 1300;
              this.file_number();
              this.state = 1301;
              this.match(_QBasicParser.COMMA);
              this.state = 1302;
              this.variable_or_function_call();
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    locate_statement() {
      let localContext = new Locate_statementContext(this.context, this.state);
      this.enterRule(localContext, 144, _QBasicParser.RULE_locate_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1306;
          this.match(_QBasicParser.LOCATE);
          this.state = 1352;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 168, this.context)) {
            case 1:
              {
                this.state = 1308;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1307;
                    localContext._row = this.expr(0);
                  }
                }
                this.state = 1310;
                this.match(_QBasicParser.COMMA);
                this.state = 1312;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1311;
                    localContext._column = this.expr(0);
                  }
                }
                this.state = 1314;
                this.match(_QBasicParser.COMMA);
                this.state = 1316;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1315;
                    localContext._cursor = this.expr(0);
                  }
                }
                this.state = 1318;
                this.match(_QBasicParser.COMMA);
                this.state = 1320;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1319;
                    localContext._start = this.expr(0);
                  }
                }
                this.state = 1322;
                this.match(_QBasicParser.COMMA);
                this.state = 1323;
                localContext._stop = this.expr(0);
              }
              break;
            case 2:
              {
                this.state = 1325;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1324;
                    localContext._row = this.expr(0);
                  }
                }
                this.state = 1327;
                this.match(_QBasicParser.COMMA);
                this.state = 1329;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1328;
                    localContext._column = this.expr(0);
                  }
                }
                this.state = 1331;
                this.match(_QBasicParser.COMMA);
                this.state = 1333;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1332;
                    localContext._cursor = this.expr(0);
                  }
                }
                this.state = 1335;
                this.match(_QBasicParser.COMMA);
                this.state = 1336;
                localContext._start = this.expr(0);
              }
              break;
            case 3:
              {
                this.state = 1338;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1337;
                    localContext._row = this.expr(0);
                  }
                }
                this.state = 1340;
                this.match(_QBasicParser.COMMA);
                this.state = 1342;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1341;
                    localContext._column = this.expr(0);
                  }
                }
                this.state = 1344;
                this.match(_QBasicParser.COMMA);
                this.state = 1345;
                localContext._cursor = this.expr(0);
              }
              break;
            case 4:
              {
                this.state = 1347;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1346;
                    localContext._row = this.expr(0);
                  }
                }
                this.state = 1349;
                this.match(_QBasicParser.COMMA);
                this.state = 1350;
                localContext._column = this.expr(0);
              }
              break;
            case 5:
              {
                {
                  this.state = 1351;
                  localContext._row = this.expr(0);
                }
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    lock_statement() {
      let localContext = new Lock_statementContext(this.context, this.state);
      this.enterRule(localContext, 146, _QBasicParser.RULE_lock_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1354;
          this.match(_QBasicParser.LOCK);
          this.state = 1356;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1355;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1358;
          this.expr(0);
          this.state = 1367;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1359;
              this.match(_QBasicParser.COMMA);
              this.state = 1365;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 170, this.context)) {
                case 1:
                  {
                    this.state = 1360;
                    this.expr(0);
                  }
                  break;
                case 2:
                  {
                    this.state = 1361;
                    this.expr(0);
                    this.state = 1362;
                    this.match(_QBasicParser.TO);
                    this.state = 1363;
                    this.expr(0);
                  }
                  break;
              }
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    lprint_statement() {
      let localContext = new Lprint_statementContext(this.context, this.state);
      this.enterRule(localContext, 148, _QBasicParser.RULE_lprint_statement);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1369;
          this.match(_QBasicParser.LPRINT);
          this.state = 1377;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 174, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                this.state = 1375;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 173, this.context)) {
                  case 1:
                    {
                      this.state = 1370;
                      _la = this.tokenStream.LA(1);
                      if (!(_la === 11 || _la === 12)) {
                        this.errorHandler.recoverInline(this);
                      } else {
                        this.errorHandler.reportMatch(this);
                        this.consume();
                      }
                    }
                    break;
                  case 2:
                    {
                      this.state = 1372;
                      this.errorHandler.sync(this);
                      _la = this.tokenStream.LA(1);
                      if (_la === 11 || _la === 12) {
                        {
                          this.state = 1371;
                          _la = this.tokenStream.LA(1);
                          if (!(_la === 11 || _la === 12)) {
                            this.errorHandler.recoverInline(this);
                          } else {
                            this.errorHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      }
                      this.state = 1374;
                      this.expr(0);
                    }
                    break;
                }
              }
            }
            this.state = 1379;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 174, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    lprint_using_statement() {
      let localContext = new Lprint_using_statementContext(this.context, this.state);
      this.enterRule(localContext, 150, _QBasicParser.RULE_lprint_using_statement);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1380;
          this.match(_QBasicParser.LPRINT);
          this.state = 1381;
          this.match(_QBasicParser.USING);
          this.state = 1382;
          this.expr(0);
          this.state = 1383;
          this.match(_QBasicParser.SEMICOLON);
          this.state = 1385;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 175, this.context)) {
            case 1:
              {
                this.state = 1384;
                this.expr(0);
              }
              break;
          }
          this.state = 1394;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 178, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                this.state = 1392;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 177, this.context)) {
                  case 1:
                    {
                      this.state = 1387;
                      _la = this.tokenStream.LA(1);
                      if (!(_la === 11 || _la === 12)) {
                        this.errorHandler.recoverInline(this);
                      } else {
                        this.errorHandler.reportMatch(this);
                        this.consume();
                      }
                    }
                    break;
                  case 2:
                    {
                      this.state = 1389;
                      this.errorHandler.sync(this);
                      _la = this.tokenStream.LA(1);
                      if (_la === 11 || _la === 12) {
                        {
                          this.state = 1388;
                          _la = this.tokenStream.LA(1);
                          if (!(_la === 11 || _la === 12)) {
                            this.errorHandler.recoverInline(this);
                          } else {
                            this.errorHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      }
                      this.state = 1391;
                      this.expr(0);
                    }
                    break;
                }
              }
            }
            this.state = 1396;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 178, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    lset_statement() {
      let localContext = new Lset_statementContext(this.context, this.state);
      this.enterRule(localContext, 152, _QBasicParser.RULE_lset_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1397;
          this.match(_QBasicParser.LSET);
          this.state = 1398;
          this.variable_or_function_call();
          this.state = 1399;
          this.match(_QBasicParser.EQ);
          this.state = 1400;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    mid_statement() {
      let localContext = new Mid_statementContext(this.context, this.state);
      this.enterRule(localContext, 154, _QBasicParser.RULE_mid_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1402;
          this.match(_QBasicParser.MID_STRING);
          this.state = 1403;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1404;
          this.variable_or_function_call();
          this.state = 1405;
          this.match(_QBasicParser.COMMA);
          this.state = 1406;
          this.expr(0);
          this.state = 1409;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1407;
              this.match(_QBasicParser.COMMA);
              this.state = 1408;
              this.expr(0);
            }
          }
          this.state = 1411;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1412;
          this.match(_QBasicParser.EQ);
          this.state = 1413;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    name_statement() {
      let localContext = new Name_statementContext(this.context, this.state);
      this.enterRule(localContext, 156, _QBasicParser.RULE_name_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1415;
          this.match(_QBasicParser.NAME);
          this.state = 1416;
          localContext._oldspec = this.expr(0);
          this.state = 1417;
          this.match(_QBasicParser.AS);
          this.state = 1418;
          localContext._newspec = this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    on_error_statement() {
      let localContext = new On_error_statementContext(this.context, this.state);
      this.enterRule(localContext, 158, _QBasicParser.RULE_on_error_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1420;
          this.match(_QBasicParser.ON);
          this.state = 1421;
          this.match(_QBasicParser.ERROR);
          this.state = 1426;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.GOTO:
              {
                this.state = 1422;
                this.match(_QBasicParser.GOTO);
                this.state = 1423;
                this.target();
              }
              break;
            case _QBasicParser.RESUME:
              {
                this.state = 1424;
                this.match(_QBasicParser.RESUME);
                this.state = 1425;
                this.match(_QBasicParser.NEXT);
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    on_event_gosub_statement() {
      let localContext = new On_event_gosub_statementContext(this.context, this.state);
      this.enterRule(localContext, 160, _QBasicParser.RULE_on_event_gosub_statement);
      try {
        this.state = 1472;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 181, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1428;
              this.match(_QBasicParser.ON);
              this.state = 1429;
              this.match(_QBasicParser.COM);
              this.state = 1430;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1431;
              this.expr(0);
              this.state = 1432;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1433;
              this.match(_QBasicParser.GOSUB);
              this.state = 1434;
              this.target();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1436;
              this.match(_QBasicParser.ON);
              this.state = 1437;
              this.match(_QBasicParser.KEY);
              this.state = 1438;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1439;
              this.expr(0);
              this.state = 1440;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1441;
              this.match(_QBasicParser.GOSUB);
              this.state = 1442;
              this.target();
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1444;
              this.match(_QBasicParser.ON);
              this.state = 1445;
              this.match(_QBasicParser.PEN);
              this.state = 1446;
              this.match(_QBasicParser.GOSUB);
              this.state = 1447;
              this.target();
            }
            break;
          case 4:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 1448;
              this.match(_QBasicParser.ON);
              this.state = 1449;
              this.match(_QBasicParser.PLAY);
              this.state = 1450;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1451;
              this.expr(0);
              this.state = 1452;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1453;
              this.match(_QBasicParser.GOSUB);
              this.state = 1454;
              this.target();
            }
            break;
          case 5:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 1456;
              this.match(_QBasicParser.ON);
              this.state = 1457;
              this.match(_QBasicParser.STRIG);
              this.state = 1458;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1459;
              this.expr(0);
              this.state = 1460;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1461;
              this.match(_QBasicParser.GOSUB);
              this.state = 1462;
              this.target();
            }
            break;
          case 6:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 1464;
              this.match(_QBasicParser.ON);
              this.state = 1465;
              this.match(_QBasicParser.TIMER);
              this.state = 1466;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1467;
              this.expr(0);
              this.state = 1468;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1469;
              this.match(_QBasicParser.GOSUB);
              this.state = 1470;
              this.target();
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    on_expr_gosub_statement() {
      let localContext = new On_expr_gosub_statementContext(this.context, this.state);
      this.enterRule(localContext, 162, _QBasicParser.RULE_on_expr_gosub_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1474;
          this.match(_QBasicParser.ON);
          this.state = 1475;
          this.expr(0);
          this.state = 1476;
          this.match(_QBasicParser.GOSUB);
          this.state = 1477;
          this.target_list();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    target_list() {
      let localContext = new Target_listContext(this.context, this.state);
      this.enterRule(localContext, 164, _QBasicParser.RULE_target_list);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1479;
          this.target();
          this.state = 1484;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 1480;
                this.match(_QBasicParser.COMMA);
                this.state = 1481;
                this.target();
              }
            }
            this.state = 1486;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    on_expr_goto_statement() {
      let localContext = new On_expr_goto_statementContext(this.context, this.state);
      this.enterRule(localContext, 166, _QBasicParser.RULE_on_expr_goto_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1487;
          this.match(_QBasicParser.ON);
          this.state = 1488;
          this.expr(0);
          this.state = 1489;
          this.match(_QBasicParser.GOTO);
          this.state = 1490;
          this.target_list();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    open_legacy_statement() {
      let localContext = new Open_legacy_statementContext(this.context, this.state);
      this.enterRule(localContext, 168, _QBasicParser.RULE_open_legacy_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1492;
          this.match(_QBasicParser.OPEN);
          this.state = 1493;
          localContext._openmode = this.expr(0);
          this.state = 1494;
          this.match(_QBasicParser.COMMA);
          this.state = 1496;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1495;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1498;
          localContext._filenum = this.expr(0);
          this.state = 1499;
          this.match(_QBasicParser.COMMA);
          this.state = 1500;
          localContext._file = this.expr(0);
          this.state = 1503;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1501;
              this.match(_QBasicParser.COMMA);
              this.state = 1502;
              localContext._reclen = this.expr(0);
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    open_statement() {
      let localContext = new Open_statementContext(this.context, this.state);
      this.enterRule(localContext, 170, _QBasicParser.RULE_open_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1505;
          this.match(_QBasicParser.OPEN);
          this.state = 1506;
          localContext._file = this.expr(0);
          this.state = 1509;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 63) {
            {
              this.state = 1507;
              this.match(_QBasicParser.FOR);
              this.state = 1508;
              this.open_mode();
            }
          }
          this.state = 1513;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 29) {
            {
              this.state = 1511;
              this.match(_QBasicParser.ACCESS);
              this.state = 1512;
              this.open_access();
            }
          }
          this.state = 1516;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 83 || _la === 118) {
            {
              this.state = 1515;
              this.open_lock();
            }
          }
          this.state = 1518;
          this.match(_QBasicParser.AS);
          {
            this.state = 1520;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
            if (_la === 4) {
              {
                this.state = 1519;
                this.match(_QBasicParser.NUMBER);
              }
            }
            this.state = 1522;
            localContext._filenum = this.expr(0);
          }
          this.state = 1527;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 78) {
            {
              this.state = 1524;
              this.match(_QBasicParser.LEN);
              this.state = 1525;
              this.match(_QBasicParser.EQ);
              this.state = 1526;
              localContext._reclen = this.expr(0);
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    open_mode() {
      let localContext = new Open_modeContext(this.context, this.state);
      this.enterRule(localContext, 172, _QBasicParser.RULE_open_mode);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1529;
          _la = this.tokenStream.LA(1);
          if (!(_la === 32 || _la === 35 || _la === 71 || _la === 96 || _la === 107)) {
            this.errorHandler.recoverInline(this);
          } else {
            this.errorHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    open_access() {
      let localContext = new Open_accessContext(this.context, this.state);
      this.enterRule(localContext, 174, _QBasicParser.RULE_open_access);
      try {
        this.state = 1535;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 190, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1531;
              this.match(_QBasicParser.READ);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1532;
              this.match(_QBasicParser.WRITE);
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1533;
              this.match(_QBasicParser.READ);
              this.state = 1534;
              this.match(_QBasicParser.WRITE);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    open_lock() {
      let localContext = new Open_lockContext(this.context, this.state);
      this.enterRule(localContext, 176, _QBasicParser.RULE_open_lock);
      try {
        this.state = 1545;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 191, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1537;
              this.match(_QBasicParser.SHARED);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1538;
              this.match(_QBasicParser.LOCK);
              this.state = 1539;
              this.match(_QBasicParser.READ);
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1540;
              this.match(_QBasicParser.LOCK);
              this.state = 1541;
              this.match(_QBasicParser.WRITE);
            }
            break;
          case 4:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 1542;
              this.match(_QBasicParser.LOCK);
              this.state = 1543;
              this.match(_QBasicParser.READ);
              this.state = 1544;
              this.match(_QBasicParser.WRITE);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    paint_statement() {
      let localContext = new Paint_statementContext(this.context, this.state);
      this.enterRule(localContext, 178, _QBasicParser.RULE_paint_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1547;
          this.match(_QBasicParser.PAINT);
          this.state = 1549;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1548;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 1551;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1552;
          localContext._x = this.expr(0);
          this.state = 1553;
          this.match(_QBasicParser.COMMA);
          this.state = 1554;
          localContext._y = this.expr(0);
          this.state = 1555;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1574;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 196, this.context)) {
            case 1:
              {
                this.state = 1556;
                this.match(_QBasicParser.COMMA);
                this.state = 1558;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1557;
                    localContext._color_tile = this.expr(0);
                  }
                }
                this.state = 1560;
                this.match(_QBasicParser.COMMA);
                this.state = 1562;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1561;
                    localContext._bordercolor = this.expr(0);
                  }
                }
                this.state = 1564;
                this.match(_QBasicParser.COMMA);
                this.state = 1565;
                localContext._background = this.expr(0);
              }
              break;
            case 2:
              {
                this.state = 1566;
                this.match(_QBasicParser.COMMA);
                this.state = 1568;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1567;
                    localContext._color_tile = this.expr(0);
                  }
                }
                this.state = 1570;
                this.match(_QBasicParser.COMMA);
                this.state = 1571;
                localContext._bordercolor = this.expr(0);
              }
              break;
            case 3:
              {
                this.state = 1572;
                this.match(_QBasicParser.COMMA);
                this.state = 1573;
                localContext._color_tile = this.expr(0);
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    palette_statement() {
      let localContext = new Palette_statementContext(this.context, this.state);
      this.enterRule(localContext, 180, _QBasicParser.RULE_palette_statement);
      try {
        this.state = 1585;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 197, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1576;
              this.match(_QBasicParser.PALETTE);
              this.state = 1577;
              localContext._attribute = this.expr(0);
              this.state = 1578;
              this.match(_QBasicParser.COMMA);
              this.state = 1579;
              localContext._color = this.expr(0);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1581;
              this.match(_QBasicParser.PALETTE);
              this.state = 1582;
              this.match(_QBasicParser.USING);
              this.state = 1583;
              localContext._arrayname = this.variable_or_function_call();
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1584;
              this.match(_QBasicParser.PALETTE);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    play_statement() {
      let localContext = new Play_statementContext(this.context, this.state);
      this.enterRule(localContext, 182, _QBasicParser.RULE_play_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1587;
          this.match(_QBasicParser.PLAY);
          this.state = 1588;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    preset_statement() {
      let localContext = new Preset_statementContext(this.context, this.state);
      this.enterRule(localContext, 184, _QBasicParser.RULE_preset_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1590;
          this.match(_QBasicParser.PRESET);
          this.state = 1592;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1591;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 1594;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1595;
          localContext._x = this.expr(0);
          this.state = 1596;
          this.match(_QBasicParser.COMMA);
          this.state = 1597;
          localContext._y = this.expr(0);
          this.state = 1598;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1601;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1599;
              this.match(_QBasicParser.COMMA);
              this.state = 1600;
              localContext._color = this.expr(0);
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    print_statement() {
      let localContext = new Print_statementContext(this.context, this.state);
      this.enterRule(localContext, 186, _QBasicParser.RULE_print_statement);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1603;
          this.match(_QBasicParser.PRINT);
          this.state = 1607;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1604;
              this.file_number();
              this.state = 1605;
              this.match(_QBasicParser.COMMA);
            }
          }
          this.state = 1610;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 201, this.context)) {
            case 1:
              {
                this.state = 1609;
                this.expr(0);
              }
              break;
          }
          this.state = 1619;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 204, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                this.state = 1617;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 203, this.context)) {
                  case 1:
                    {
                      this.state = 1612;
                      _la = this.tokenStream.LA(1);
                      if (!(_la === 11 || _la === 12)) {
                        this.errorHandler.recoverInline(this);
                      } else {
                        this.errorHandler.reportMatch(this);
                        this.consume();
                      }
                    }
                    break;
                  case 2:
                    {
                      this.state = 1614;
                      this.errorHandler.sync(this);
                      _la = this.tokenStream.LA(1);
                      if (_la === 11 || _la === 12) {
                        {
                          this.state = 1613;
                          _la = this.tokenStream.LA(1);
                          if (!(_la === 11 || _la === 12)) {
                            this.errorHandler.recoverInline(this);
                          } else {
                            this.errorHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      }
                      this.state = 1616;
                      this.expr(0);
                    }
                    break;
                }
              }
            }
            this.state = 1621;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 204, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    print_using_statement() {
      let localContext = new Print_using_statementContext(this.context, this.state);
      this.enterRule(localContext, 188, _QBasicParser.RULE_print_using_statement);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1622;
          this.match(_QBasicParser.PRINT);
          this.state = 1626;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1623;
              this.file_number();
              this.state = 1624;
              this.match(_QBasicParser.COMMA);
            }
          }
          this.state = 1628;
          this.match(_QBasicParser.USING);
          this.state = 1629;
          this.expr(0);
          this.state = 1630;
          this.match(_QBasicParser.SEMICOLON);
          this.state = 1632;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 206, this.context)) {
            case 1:
              {
                this.state = 1631;
                this.expr(0);
              }
              break;
          }
          this.state = 1641;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 209, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              {
                this.state = 1639;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 208, this.context)) {
                  case 1:
                    {
                      this.state = 1634;
                      _la = this.tokenStream.LA(1);
                      if (!(_la === 11 || _la === 12)) {
                        this.errorHandler.recoverInline(this);
                      } else {
                        this.errorHandler.reportMatch(this);
                        this.consume();
                      }
                    }
                    break;
                  case 2:
                    {
                      this.state = 1636;
                      this.errorHandler.sync(this);
                      _la = this.tokenStream.LA(1);
                      if (_la === 11 || _la === 12) {
                        {
                          this.state = 1635;
                          _la = this.tokenStream.LA(1);
                          if (!(_la === 11 || _la === 12)) {
                            this.errorHandler.recoverInline(this);
                          } else {
                            this.errorHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      }
                      this.state = 1638;
                      this.expr(0);
                    }
                    break;
                }
              }
            }
            this.state = 1643;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 209, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    pset_statement() {
      let localContext = new Pset_statementContext(this.context, this.state);
      this.enterRule(localContext, 190, _QBasicParser.RULE_pset_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1644;
          this.match(_QBasicParser.PSET);
          this.state = 1646;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1645;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 1648;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1649;
          localContext._x = this.expr(0);
          this.state = 1650;
          this.match(_QBasicParser.COMMA);
          this.state = 1651;
          localContext._y = this.expr(0);
          this.state = 1652;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1655;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1653;
              this.match(_QBasicParser.COMMA);
              this.state = 1654;
              localContext._color = this.expr(0);
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    put_graphics_statement() {
      let localContext = new Put_graphics_statementContext(this.context, this.state);
      this.enterRule(localContext, 192, _QBasicParser.RULE_put_graphics_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1657;
          this.match(_QBasicParser.PUT);
          this.state = 1659;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 121) {
            {
              this.state = 1658;
              this.match(_QBasicParser.STEP);
            }
          }
          this.state = 1661;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 1662;
          localContext._x1 = this.expr(0);
          this.state = 1663;
          this.match(_QBasicParser.COMMA);
          this.state = 1664;
          localContext._y1 = this.expr(0);
          this.state = 1665;
          this.match(_QBasicParser.RIGHT_PAREN);
          this.state = 1666;
          this.match(_QBasicParser.COMMA);
          this.state = 1667;
          localContext._arrayname = this.variable_or_function_call();
          this.state = 1670;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1668;
              this.match(_QBasicParser.COMMA);
              this.state = 1669;
              _la = this.tokenStream.LA(1);
              if (!(_la === 30 || (_la - 97 & ~31) === 0 && (1 << _la - 97 & 385) !== 0 || _la === 139)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    put_io_statement() {
      let localContext = new Put_io_statementContext(this.context, this.state);
      this.enterRule(localContext, 194, _QBasicParser.RULE_put_io_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1672;
          this.match(_QBasicParser.PUT);
          this.state = 1674;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1673;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1676;
          this.expr(0);
          this.state = 1685;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1677;
              this.match(_QBasicParser.COMMA);
              this.state = 1679;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 215, this.context)) {
                case 1:
                  {
                    this.state = 1678;
                    this.expr(0);
                  }
                  break;
              }
              this.state = 1683;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 11) {
                {
                  this.state = 1681;
                  this.match(_QBasicParser.COMMA);
                  this.state = 1682;
                  this.variable_or_function_call();
                }
              }
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    read_statement() {
      let localContext = new Read_statementContext(this.context, this.state);
      this.enterRule(localContext, 196, _QBasicParser.RULE_read_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1687;
          this.match(_QBasicParser.READ);
          this.state = 1688;
          this.variable_or_function_call();
          this.state = 1693;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 11) {
            {
              {
                this.state = 1689;
                this.match(_QBasicParser.COMMA);
                this.state = 1690;
                this.variable_or_function_call();
              }
            }
            this.state = 1695;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    rem_statement() {
      let localContext = new Rem_statementContext(this.context, this.state);
      this.enterRule(localContext, 198, _QBasicParser.RULE_rem_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1696;
          this.match(_QBasicParser.REM);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    resume_statement() {
      let localContext = new Resume_statementContext(this.context, this.state);
      this.enterRule(localContext, 200, _QBasicParser.RULE_resume_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1698;
          this.match(_QBasicParser.RESUME);
          this.state = 1701;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 219, this.context)) {
            case 1:
              {
                this.state = 1699;
                this.match(_QBasicParser.NEXT);
              }
              break;
            case 2:
              {
                this.state = 1700;
                this.target();
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    return_statement() {
      let localContext = new Return_statementContext(this.context, this.state);
      this.enterRule(localContext, 202, _QBasicParser.RULE_return_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1703;
          this.match(_QBasicParser.RETURN);
          this.state = 1705;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 220, this.context)) {
            case 1:
              {
                this.state = 1704;
                this.target();
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    rset_statement() {
      let localContext = new Rset_statementContext(this.context, this.state);
      this.enterRule(localContext, 204, _QBasicParser.RULE_rset_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1707;
          this.match(_QBasicParser.RSET);
          this.state = 1708;
          this.variable_or_function_call();
          this.state = 1709;
          this.match(_QBasicParser.EQ);
          this.state = 1710;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    select_case_statement() {
      let localContext = new Select_case_statementContext(this.context, this.state);
      this.enterRule(localContext, 206, _QBasicParser.RULE_select_case_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1712;
          this.match(_QBasicParser.SELECT);
          this.state = 1713;
          this.match(_QBasicParser.CASE);
          this.state = 1714;
          this.expr(0);
          this.state = 1715;
          this.before_first_case();
          this.state = 1719;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 37) {
            {
              {
                this.state = 1716;
                this.case_block();
              }
            }
            this.state = 1721;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
          this.state = 1722;
          this.end_select_statement();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    before_first_case() {
      let localContext = new Before_first_caseContext(this.context, this.state);
      this.enterRule(localContext, 208, _QBasicParser.RULE_before_first_case);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1729;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          while (_la === 1 || _la === 110 || _la === 143) {
            {
              this.state = 1727;
              this.errorHandler.sync(this);
              switch (this.tokenStream.LA(1)) {
                case _QBasicParser.COLON:
                  {
                    this.state = 1724;
                    this.match(_QBasicParser.COLON);
                  }
                  break;
                case _QBasicParser.REM:
                  {
                    this.state = 1725;
                    this.rem_statement();
                  }
                  break;
                case _QBasicParser.NL:
                  {
                    this.state = 1726;
                    this.match(_QBasicParser.NL);
                  }
                  break;
                default:
                  throw new NoViableAltException(this);
              }
            }
            this.state = 1731;
            this.errorHandler.sync(this);
            _la = this.tokenStream.LA(1);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    case_block() {
      let localContext = new Case_blockContext(this.context, this.state);
      this.enterRule(localContext, 210, _QBasicParser.RULE_case_block);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1732;
          this.case_statement();
          this.state = 1733;
          this.block();
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    case_statement() {
      let localContext = new Case_statementContext(this.context, this.state);
      this.enterRule(localContext, 212, _QBasicParser.RULE_case_statement);
      let _la;
      try {
        this.state = 1746;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 225, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1735;
              this.match(_QBasicParser.CASE);
              this.state = 1736;
              this.case_expr();
              this.state = 1741;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1737;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1738;
                    this.case_expr();
                  }
                }
                this.state = 1743;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1744;
              this.match(_QBasicParser.CASE);
              this.state = 1745;
              this.match(_QBasicParser.ELSE);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    case_expr() {
      let localContext = new Case_exprContext(this.context, this.state);
      this.enterRule(localContext, 214, _QBasicParser.RULE_case_expr);
      let _la;
      try {
        this.state = 1756;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 226, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1748;
              this.match(_QBasicParser.IS);
              this.state = 1749;
              _la = this.tokenStream.LA(1);
              if (!((_la & ~31) === 0 && (1 << _la & 516096) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
              this.state = 1750;
              this.expr(0);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1751;
              this.expr(0);
              this.state = 1752;
              this.match(_QBasicParser.TO);
              this.state = 1753;
              this.expr(0);
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1755;
              this.expr(0);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    end_select_statement() {
      let localContext = new End_select_statementContext(this.context, this.state);
      this.enterRule(localContext, 216, _QBasicParser.RULE_end_select_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1759;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 22 || _la === 140 || _la === 141) {
            {
              this.state = 1758;
              this.label();
            }
          }
          this.state = 1761;
          this.match(_QBasicParser.END);
          this.state = 1762;
          this.match(_QBasicParser.SELECT);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    scope_statement() {
      let localContext = new Scope_statementContext(this.context, this.state);
      this.enterRule(localContext, 218, _QBasicParser.RULE_scope_statement);
      let _la;
      try {
        this.state = 1797;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.COMMON:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1764;
              this.match(_QBasicParser.COMMON);
              this.state = 1766;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 118) {
                {
                  this.state = 1765;
                  this.match(_QBasicParser.SHARED);
                }
              }
              this.state = 1769;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 5) {
                {
                  this.state = 1768;
                  this.block_name();
                }
              }
              this.state = 1771;
              this.scope_variable();
              this.state = 1776;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1772;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1773;
                    this.scope_variable();
                  }
                }
                this.state = 1778;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case _QBasicParser.SHARED:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1779;
              this.match(_QBasicParser.SHARED);
              this.state = 1780;
              this.scope_variable();
              this.state = 1785;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1781;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1782;
                    this.scope_variable();
                  }
                }
                this.state = 1787;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          case _QBasicParser.STATIC:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1788;
              this.match(_QBasicParser.STATIC);
              this.state = 1789;
              this.scope_variable();
              this.state = 1794;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 1790;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1791;
                    this.scope_variable();
                  }
                }
                this.state = 1796;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    block_name() {
      let localContext = new Block_nameContext(this.context, this.state);
      this.enterRule(localContext, 220, _QBasicParser.RULE_block_name);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1799;
          this.match(_QBasicParser.DIVIDE);
          this.state = 1801;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 141) {
            {
              this.state = 1800;
              this.match(_QBasicParser.ID);
            }
          }
          this.state = 1803;
          this.match(_QBasicParser.DIVIDE);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    scope_variable() {
      let localContext = new Scope_variableContext(this.context, this.state);
      this.enterRule(localContext, 222, _QBasicParser.RULE_scope_variable);
      let _la;
      try {
        this.state = 1816;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 237, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1805;
              this.untyped_id();
              this.state = 1807;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 1806;
                  this.array_declaration();
                }
              }
              this.state = 1809;
              this.match(_QBasicParser.AS);
              this.state = 1810;
              this.type_name();
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1812;
              this.match(_QBasicParser.ID);
              this.state = 1814;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 2) {
                {
                  this.state = 1813;
                  this.array_declaration();
                }
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    screen_statement() {
      let localContext = new Screen_statementContext(this.context, this.state);
      this.enterRule(localContext, 224, _QBasicParser.RULE_screen_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1818;
          this.match(_QBasicParser.SCREEN);
          this.state = 1819;
          localContext._screenmode = this.expr(0);
          this.state = 1838;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 241, this.context)) {
            case 1:
              {
                this.state = 1820;
                this.match(_QBasicParser.COMMA);
                this.state = 1822;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1821;
                    localContext._colorswitch = this.expr(0);
                  }
                }
                this.state = 1824;
                this.match(_QBasicParser.COMMA);
                this.state = 1826;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1825;
                    localContext._activepage = this.expr(0);
                  }
                }
                this.state = 1828;
                this.match(_QBasicParser.COMMA);
                this.state = 1829;
                localContext._visualpage = this.expr(0);
              }
              break;
            case 2:
              {
                this.state = 1830;
                this.match(_QBasicParser.COMMA);
                this.state = 1832;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                  {
                    this.state = 1831;
                    localContext._colorswitch = this.expr(0);
                  }
                }
                this.state = 1834;
                this.match(_QBasicParser.COMMA);
                this.state = 1835;
                localContext._activepage = this.expr(0);
              }
              break;
            case 3:
              {
                this.state = 1836;
                this.match(_QBasicParser.COMMA);
                this.state = 1837;
                localContext._colorswitch = this.expr(0);
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    seek_statement() {
      let localContext = new Seek_statementContext(this.context, this.state);
      this.enterRule(localContext, 226, _QBasicParser.RULE_seek_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1840;
          this.match(_QBasicParser.SEEK);
          this.state = 1842;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1841;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1844;
          this.expr(0);
          this.state = 1845;
          this.match(_QBasicParser.COMMA);
          this.state = 1846;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    stop_statement() {
      let localContext = new Stop_statementContext(this.context, this.state);
      this.enterRule(localContext, 228, _QBasicParser.RULE_stop_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1848;
          this.match(_QBasicParser.STOP);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    unlock_statement() {
      let localContext = new Unlock_statementContext(this.context, this.state);
      this.enterRule(localContext, 230, _QBasicParser.RULE_unlock_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1850;
          this.match(_QBasicParser.UNLOCK);
          this.state = 1852;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 4) {
            {
              this.state = 1851;
              this.match(_QBasicParser.NUMBER);
            }
          }
          this.state = 1854;
          this.expr(0);
          this.state = 1863;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 11) {
            {
              this.state = 1855;
              this.match(_QBasicParser.COMMA);
              this.state = 1861;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 244, this.context)) {
                case 1:
                  {
                    this.state = 1856;
                    this.expr(0);
                  }
                  break;
                case 2:
                  {
                    this.state = 1857;
                    this.expr(0);
                    this.state = 1858;
                    this.match(_QBasicParser.TO);
                    this.state = 1859;
                    this.expr(0);
                  }
                  break;
              }
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    view_statement() {
      let localContext = new View_statementContext(this.context, this.state);
      this.enterRule(localContext, 232, _QBasicParser.RULE_view_statement);
      let _la;
      try {
        this.state = 1891;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 249, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1865;
              this.match(_QBasicParser.VIEW);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1866;
              this.match(_QBasicParser.VIEW);
              this.state = 1868;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 114) {
                {
                  this.state = 1867;
                  this.match(_QBasicParser.SCREEN);
                }
              }
              this.state = 1870;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1871;
              localContext._x1 = this.expr(0);
              this.state = 1872;
              this.match(_QBasicParser.COMMA);
              this.state = 1873;
              localContext._y1 = this.expr(0);
              this.state = 1874;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1875;
              this.match(_QBasicParser.MINUS);
              this.state = 1876;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1877;
              localContext._x2 = this.expr(0);
              this.state = 1878;
              this.match(_QBasicParser.COMMA);
              this.state = 1879;
              localContext._y2 = this.expr(0);
              this.state = 1880;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1889;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 248, this.context)) {
                case 1:
                  {
                    this.state = 1881;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1883;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                    if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
                      {
                        this.state = 1882;
                        localContext._color = this.expr(0);
                      }
                    }
                    this.state = 1885;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1886;
                    localContext._border = this.expr(0);
                  }
                  break;
                case 2:
                  {
                    this.state = 1887;
                    this.match(_QBasicParser.COMMA);
                    this.state = 1888;
                    localContext._color = this.expr(0);
                  }
                  break;
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    view_print_statement() {
      let localContext = new View_print_statementContext(this.context, this.state);
      this.enterRule(localContext, 234, _QBasicParser.RULE_view_print_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1893;
          this.match(_QBasicParser.VIEW);
          this.state = 1894;
          this.match(_QBasicParser.PRINT);
          this.state = 1899;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 250, this.context)) {
            case 1:
              {
                this.state = 1895;
                localContext._toprow = this.expr(0);
                this.state = 1896;
                this.match(_QBasicParser.TO);
                this.state = 1897;
                localContext._bottomrow = this.expr(0);
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    while_wend_statement() {
      let localContext = new While_wend_statementContext(this.context, this.state);
      this.enterRule(localContext, 236, _QBasicParser.RULE_while_wend_statement);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1901;
          this.match(_QBasicParser.WHILE);
          this.state = 1902;
          this.expr(0);
          this.state = 1903;
          this.block();
          this.state = 1904;
          this.match(_QBasicParser.WEND);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    width_statement() {
      let localContext = new Width_statementContext(this.context, this.state);
      this.enterRule(localContext, 238, _QBasicParser.RULE_width_statement);
      try {
        this.state = 1924;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 251, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1906;
              this.match(_QBasicParser.WIDTH);
              this.state = 1907;
              localContext._columns = this.expr(0);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1908;
              this.match(_QBasicParser.WIDTH);
              this.state = 1909;
              this.match(_QBasicParser.COMMA);
              this.state = 1910;
              localContext._lines = this.expr(0);
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1911;
              this.match(_QBasicParser.WIDTH);
              this.state = 1912;
              this.expr(0);
              this.state = 1913;
              this.match(_QBasicParser.COMMA);
              this.state = 1914;
              this.expr(0);
            }
            break;
          case 4:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 1916;
              this.match(_QBasicParser.WIDTH);
              this.state = 1917;
              this.file_number();
              this.state = 1918;
              this.match(_QBasicParser.COMMA);
              this.state = 1919;
              localContext._width = this.expr(0);
            }
            break;
          case 5:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 1921;
              this.match(_QBasicParser.WIDTH);
              this.state = 1922;
              this.match(_QBasicParser.LPRINT);
              this.state = 1923;
              localContext._width = this.expr(0);
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    window_statement() {
      let localContext = new Window_statementContext(this.context, this.state);
      this.enterRule(localContext, 240, _QBasicParser.RULE_window_statement);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1926;
          this.match(_QBasicParser.WINDOW);
          this.state = 1942;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if (_la === 2 || _la === 114) {
            {
              this.state = 1928;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 114) {
                {
                  this.state = 1927;
                  this.match(_QBasicParser.SCREEN);
                }
              }
              this.state = 1930;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1931;
              localContext._x1 = this.expr(0);
              this.state = 1932;
              this.match(_QBasicParser.COMMA);
              this.state = 1933;
              localContext._y1 = this.expr(0);
              this.state = 1934;
              this.match(_QBasicParser.RIGHT_PAREN);
              this.state = 1935;
              this.match(_QBasicParser.MINUS);
              this.state = 1936;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 1937;
              localContext._x2 = this.expr(0);
              this.state = 1938;
              this.match(_QBasicParser.COMMA);
              this.state = 1939;
              localContext._y2 = this.expr(0);
              this.state = 1940;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    write_statement() {
      let localContext = new Write_statementContext(this.context, this.state);
      this.enterRule(localContext, 242, _QBasicParser.RULE_write_statement);
      let _la;
      try {
        this.state = 1963;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 256, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 1944;
              this.match(_QBasicParser.WRITE);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 1945;
              this.match(_QBasicParser.WRITE);
              this.state = 1946;
              this.file_number();
              this.state = 1947;
              this.match(_QBasicParser.COMMA);
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 1949;
              this.match(_QBasicParser.WRITE);
              this.state = 1953;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 4) {
                {
                  this.state = 1950;
                  this.file_number();
                  this.state = 1951;
                  this.match(_QBasicParser.COMMA);
                }
              }
              this.state = 1955;
              this.expr(0);
              this.state = 1960;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11 || _la === 12) {
                {
                  {
                    this.state = 1956;
                    _la = this.tokenStream.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this.errorHandler.recoverInline(this);
                    } else {
                      this.errorHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1957;
                    this.expr(0);
                  }
                }
                this.state = 1962;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    expr(_p) {
      if (_p === void 0) {
        _p = 0;
      }
      let parentContext = this.context;
      let parentState = this.state;
      let localContext = new ExprContext(this.context, parentState);
      let previousContext = localContext;
      let _startState = 244;
      this.enterRecursionRule(localContext, 244, _QBasicParser.RULE_expr, _p);
      let _la;
      try {
        let alternative;
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 1979;
          this.errorHandler.sync(this);
          switch (this.tokenStream.LA(1)) {
            case _QBasicParser.LEFT_PAREN:
              {
                localContext = new ParenExprContext(localContext);
                this.context = localContext;
                previousContext = localContext;
                this.state = 1966;
                this.match(_QBasicParser.LEFT_PAREN);
                this.state = 1967;
                this.expr(0);
                this.state = 1968;
                this.match(_QBasicParser.RIGHT_PAREN);
              }
              break;
            case _QBasicParser.PLUS:
              {
                localContext = new UnaryPlusExprContext(localContext);
                this.context = localContext;
                previousContext = localContext;
                this.state = 1970;
                this.match(_QBasicParser.PLUS);
                this.state = 1971;
                this.expr(16);
              }
              break;
            case _QBasicParser.MINUS:
              {
                localContext = new UnaryMinusExprContext(localContext);
                this.context = localContext;
                previousContext = localContext;
                this.state = 1972;
                this.match(_QBasicParser.MINUS);
                this.state = 1973;
                this.expr(15);
              }
              break;
            case _QBasicParser.NOT:
              {
                localContext = new NotExprContext(localContext);
                this.context = localContext;
                previousContext = localContext;
                this.state = 1974;
                this.match(_QBasicParser.NOT);
                this.state = 1975;
                this.expr(9);
              }
              break;
            case _QBasicParser.INPUT_STRING:
            case _QBasicParser.IOCTL_STRING:
            case _QBasicParser.LEN:
            case _QBasicParser.MID_STRING:
            case _QBasicParser.PEN:
            case _QBasicParser.PLAY:
            case _QBasicParser.SCREEN:
            case _QBasicParser.SEEK:
            case _QBasicParser.STRIG:
            case _QBasicParser.TIMER:
              {
                localContext = new BuiltinExprContext(localContext);
                this.context = localContext;
                previousContext = localContext;
                this.state = 1976;
                this.builtin_function();
              }
              break;
            case _QBasicParser.DIGITS:
            case _QBasicParser.HEX:
            case _QBasicParser.OCTAL:
            case _QBasicParser.PROBABLY_SINGLE_PRECISION_NUMBER:
            case _QBasicParser.DOUBLE_PRECISION_NUMBER:
            case _QBasicParser.STRING_LITERAL:
              {
                localContext = new ValueExprContext(localContext);
                this.context = localContext;
                previousContext = localContext;
                this.state = 1977;
                this.literal();
              }
              break;
            case _QBasicParser.FNID:
            case _QBasicParser.ID:
              {
                localContext = new VarCallExprContext(localContext);
                this.context = localContext;
                previousContext = localContext;
                this.state = 1978;
                this.variable_or_function_call();
              }
              break;
            default:
              throw new NoViableAltException(this);
          }
          this.context.stop = this.tokenStream.LT(-1);
          this.state = 2016;
          this.errorHandler.sync(this);
          alternative = this.interpreter.adaptivePredict(this.tokenStream, 259, this.context);
          while (alternative !== 2 && alternative !== ATN.INVALID_ALT_NUMBER) {
            if (alternative === 1) {
              if (this.parseListeners != null) {
                this.triggerExitRuleEvent();
              }
              previousContext = localContext;
              {
                this.state = 2014;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 258, this.context)) {
                  case 1:
                    {
                      localContext = new ExponentExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 1981;
                      if (!this.precpred(this.context, 17)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 17)");
                      }
                      this.state = 1982;
                      this.match(_QBasicParser.EXP);
                      this.state = 1983;
                      this.expr(18);
                    }
                    break;
                  case 2:
                    {
                      localContext = new MultiplyDivideExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 1984;
                      if (!this.precpred(this.context, 14)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 14)");
                      }
                      this.state = 1985;
                      _la = this.tokenStream.LA(1);
                      if (!(_la === 5 || _la === 10)) {
                        this.errorHandler.recoverInline(this);
                      } else {
                        this.errorHandler.reportMatch(this);
                        this.consume();
                      }
                      this.state = 1986;
                      this.expr(15);
                    }
                    break;
                  case 3:
                    {
                      localContext = new IntegerDivideExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 1987;
                      if (!this.precpred(this.context, 13)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 13)");
                      }
                      this.state = 1988;
                      this.match(_QBasicParser.INTEGER_DIVIDE);
                      this.state = 1989;
                      this.expr(14);
                    }
                    break;
                  case 4:
                    {
                      localContext = new ModExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 1990;
                      if (!this.precpred(this.context, 12)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 12)");
                      }
                      this.state = 1991;
                      this.match(_QBasicParser.MOD);
                      this.state = 1992;
                      this.expr(13);
                    }
                    break;
                  case 5:
                    {
                      localContext = new PlusMinusExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 1993;
                      if (!this.precpred(this.context, 11)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 11)");
                      }
                      this.state = 1994;
                      _la = this.tokenStream.LA(1);
                      if (!(_la === 8 || _la === 9)) {
                        this.errorHandler.recoverInline(this);
                      } else {
                        this.errorHandler.reportMatch(this);
                        this.consume();
                      }
                      this.state = 1995;
                      this.expr(12);
                    }
                    break;
                  case 6:
                    {
                      localContext = new ComparisonExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 1996;
                      if (!this.precpred(this.context, 10)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 10)");
                      }
                      this.state = 1997;
                      _la = this.tokenStream.LA(1);
                      if (!((_la & ~31) === 0 && (1 << _la & 516096) !== 0)) {
                        this.errorHandler.recoverInline(this);
                      } else {
                        this.errorHandler.reportMatch(this);
                        this.consume();
                      }
                      this.state = 1998;
                      this.expr(11);
                    }
                    break;
                  case 7:
                    {
                      localContext = new AndExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 1999;
                      if (!this.precpred(this.context, 8)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 8)");
                      }
                      this.state = 2e3;
                      this.match(_QBasicParser.AND);
                      this.state = 2001;
                      this.expr(9);
                    }
                    break;
                  case 8:
                    {
                      localContext = new OrExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 2002;
                      if (!this.precpred(this.context, 7)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 7)");
                      }
                      this.state = 2003;
                      this.match(_QBasicParser.OR);
                      this.state = 2004;
                      this.expr(8);
                    }
                    break;
                  case 9:
                    {
                      localContext = new XorExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 2005;
                      if (!this.precpred(this.context, 6)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 6)");
                      }
                      this.state = 2006;
                      this.match(_QBasicParser.XOR);
                      this.state = 2007;
                      this.expr(7);
                    }
                    break;
                  case 10:
                    {
                      localContext = new EqvExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 2008;
                      if (!this.precpred(this.context, 5)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 5)");
                      }
                      this.state = 2009;
                      this.match(_QBasicParser.EQV);
                      this.state = 2010;
                      this.expr(6);
                    }
                    break;
                  case 11:
                    {
                      localContext = new ImpExprContext(new ExprContext(parentContext, parentState));
                      this.pushNewRecursionContext(localContext, _startState, _QBasicParser.RULE_expr);
                      this.state = 2011;
                      if (!this.precpred(this.context, 4)) {
                        throw this.createFailedPredicateException("this.precpred(this.context, 4)");
                      }
                      this.state = 2012;
                      this.match(_QBasicParser.IMP);
                      this.state = 2013;
                      this.expr(5);
                    }
                    break;
                }
              }
            }
            this.state = 2018;
            this.errorHandler.sync(this);
            alternative = this.interpreter.adaptivePredict(this.tokenStream, 259, this.context);
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.unrollRecursionContexts(parentContext);
      }
      return localContext;
    }
    builtin_function() {
      let localContext = new Builtin_functionContext(this.context, this.state);
      this.enterRule(localContext, 246, _QBasicParser.RULE_builtin_function);
      let _la;
      try {
        this.state = 2087;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.INPUT_STRING:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 2019;
              this.match(_QBasicParser.INPUT_STRING);
              this.state = 2020;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2021;
              localContext._n = this.expr(0);
              this.state = 2027;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 11) {
                {
                  this.state = 2022;
                  this.match(_QBasicParser.COMMA);
                  this.state = 2024;
                  this.errorHandler.sync(this);
                  _la = this.tokenStream.LA(1);
                  if (_la === 4) {
                    {
                      this.state = 2023;
                      this.match(_QBasicParser.NUMBER);
                    }
                  }
                  this.state = 2026;
                  localContext._filenumber = this.expr(0);
                }
              }
              this.state = 2029;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.IOCTL_STRING:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 2031;
              this.match(_QBasicParser.IOCTL_STRING);
              this.state = 2032;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2034;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 4) {
                {
                  this.state = 2033;
                  this.match(_QBasicParser.NUMBER);
                }
              }
              this.state = 2036;
              localContext._filenumber = this.expr(0);
              this.state = 2037;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.LEN:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 2039;
              this.match(_QBasicParser.LEN);
              this.state = 2040;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2041;
              this.expr(0);
              this.state = 2042;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.MID_STRING:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 2044;
              this.match(_QBasicParser.MID_STRING);
              this.state = 2045;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2046;
              this.expr(0);
              this.state = 2047;
              this.match(_QBasicParser.COMMA);
              this.state = 2048;
              this.expr(0);
              this.state = 2051;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 11) {
                {
                  this.state = 2049;
                  this.match(_QBasicParser.COMMA);
                  this.state = 2050;
                  this.expr(0);
                }
              }
              this.state = 2053;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.PEN:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 2055;
              this.match(_QBasicParser.PEN);
              this.state = 2056;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2057;
              this.expr(0);
              this.state = 2058;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.PLAY:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 2060;
              this.match(_QBasicParser.PLAY);
              this.state = 2061;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2062;
              this.expr(0);
              this.state = 2063;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.SCREEN:
            this.enterOuterAlt(localContext, 7);
            {
              this.state = 2065;
              this.match(_QBasicParser.SCREEN);
              this.state = 2066;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2067;
              localContext._row = this.expr(0);
              this.state = 2068;
              this.match(_QBasicParser.COMMA);
              this.state = 2069;
              localContext._column = this.expr(0);
              this.state = 2072;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              if (_la === 11) {
                {
                  this.state = 2070;
                  this.match(_QBasicParser.COMMA);
                  this.state = 2071;
                  localContext._colorflag = this.expr(0);
                }
              }
              this.state = 2074;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.SEEK:
            this.enterOuterAlt(localContext, 8);
            {
              this.state = 2076;
              this.match(_QBasicParser.SEEK);
              this.state = 2077;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2078;
              this.expr(0);
              this.state = 2079;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.STRIG:
            this.enterOuterAlt(localContext, 9);
            {
              this.state = 2081;
              this.match(_QBasicParser.STRIG);
              this.state = 2082;
              this.match(_QBasicParser.LEFT_PAREN);
              this.state = 2083;
              this.expr(0);
              this.state = 2084;
              this.match(_QBasicParser.RIGHT_PAREN);
            }
            break;
          case _QBasicParser.TIMER:
            this.enterOuterAlt(localContext, 10);
            {
              this.state = 2086;
              this.match(_QBasicParser.TIMER);
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    args_or_indices() {
      let localContext = new Args_or_indicesContext(this.context, this.state);
      this.enterRule(localContext, 248, _QBasicParser.RULE_args_or_indices);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 2089;
          this.match(_QBasicParser.LEFT_PAREN);
          this.state = 2098;
          this.errorHandler.sync(this);
          _la = this.tokenStream.LA(1);
          if ((_la & ~31) === 0 && (1 << _la & 264241924) !== 0 || (_la - 72 & ~31) === 0 && (1 << _la - 72 & 1611726917) !== 0 || (_la - 114 & ~31) === 0 && (1 << _la - 114 & 201359875) !== 0) {
            {
              this.state = 2090;
              this.expr(0);
              this.state = 2095;
              this.errorHandler.sync(this);
              _la = this.tokenStream.LA(1);
              while (_la === 11) {
                {
                  {
                    this.state = 2091;
                    this.match(_QBasicParser.COMMA);
                    this.state = 2092;
                    this.expr(0);
                  }
                }
                this.state = 2097;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
              }
            }
          }
          this.state = 2100;
          this.match(_QBasicParser.RIGHT_PAREN);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    variable_or_function_call() {
      let localContext = new Variable_or_function_callContext(this.context, this.state);
      this.enterRule(localContext, 250, _QBasicParser.RULE_variable_or_function_call);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 2102;
          _la = this.tokenStream.LA(1);
          if (!(_la === 140 || _la === 141)) {
            this.errorHandler.recoverInline(this);
          } else {
            this.errorHandler.reportMatch(this);
            this.consume();
          }
          this.state = 2108;
          this.errorHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this.tokenStream, 269, this.context)) {
            case 1:
              {
                this.state = 2103;
                this.args_or_indices();
                this.state = 2106;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 268, this.context)) {
                  case 1:
                    {
                      this.state = 2104;
                      this.match(_QBasicParser.DOT);
                      this.state = 2105;
                      this.match(_QBasicParser.ID);
                    }
                    break;
                }
              }
              break;
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    type_name() {
      let localContext = new Type_nameContext(this.context, this.state);
      this.enterRule(localContext, 252, _QBasicParser.RULE_type_name);
      try {
        this.state = 2118;
        this.errorHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this.tokenStream, 270, this.context)) {
          case 1:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 2110;
              this.match(_QBasicParser.INTEGER);
            }
            break;
          case 2:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 2111;
              this.match(_QBasicParser.LONG);
            }
            break;
          case 3:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 2112;
              this.match(_QBasicParser.SINGLE);
            }
            break;
          case 4:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 2113;
              this.match(_QBasicParser.DOUBLE);
            }
            break;
          case 5:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 2114;
              this.match(_QBasicParser.STRING);
            }
            break;
          case 6:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 2115;
              this.fixed_string();
            }
            break;
          case 7:
            this.enterOuterAlt(localContext, 7);
            {
              this.state = 2116;
              this.untyped_id();
            }
            break;
          case 8:
            this.enterOuterAlt(localContext, 8);
            {
              this.state = 2117;
              this.untyped_fnid();
            }
            break;
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    type_name_for_parameter() {
      let localContext = new Type_name_for_parameterContext(this.context, this.state);
      this.enterRule(localContext, 254, _QBasicParser.RULE_type_name_for_parameter);
      try {
        this.state = 2127;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.INTEGER:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 2120;
              this.match(_QBasicParser.INTEGER);
            }
            break;
          case _QBasicParser.LONG:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 2121;
              this.match(_QBasicParser.LONG);
            }
            break;
          case _QBasicParser.SINGLE:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 2122;
              this.match(_QBasicParser.SINGLE);
            }
            break;
          case _QBasicParser.DOUBLE:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 2123;
              this.match(_QBasicParser.DOUBLE);
            }
            break;
          case _QBasicParser.STRING:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 2124;
              this.match(_QBasicParser.STRING);
            }
            break;
          case _QBasicParser.ID:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 2125;
              this.untyped_id();
            }
            break;
          case _QBasicParser.FNID:
            this.enterOuterAlt(localContext, 7);
            {
              this.state = 2126;
              this.untyped_fnid();
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    type_name_for_declare_parameter() {
      let localContext = new Type_name_for_declare_parameterContext(this.context, this.state);
      this.enterRule(localContext, 256, _QBasicParser.RULE_type_name_for_declare_parameter);
      try {
        this.state = 2137;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.INTEGER:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 2129;
              this.match(_QBasicParser.INTEGER);
            }
            break;
          case _QBasicParser.LONG:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 2130;
              this.match(_QBasicParser.LONG);
            }
            break;
          case _QBasicParser.SINGLE:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 2131;
              this.match(_QBasicParser.SINGLE);
            }
            break;
          case _QBasicParser.DOUBLE:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 2132;
              this.match(_QBasicParser.DOUBLE);
            }
            break;
          case _QBasicParser.STRING:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 2133;
              this.match(_QBasicParser.STRING);
            }
            break;
          case _QBasicParser.ANY:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 2134;
              this.match(_QBasicParser.ANY);
            }
            break;
          case _QBasicParser.ID:
            this.enterOuterAlt(localContext, 7);
            {
              this.state = 2135;
              this.untyped_id();
            }
            break;
          case _QBasicParser.FNID:
            this.enterOuterAlt(localContext, 8);
            {
              this.state = 2136;
              this.untyped_fnid();
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    type_name_for_def_fn_parameter() {
      let localContext = new Type_name_for_def_fn_parameterContext(this.context, this.state);
      this.enterRule(localContext, 258, _QBasicParser.RULE_type_name_for_def_fn_parameter);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 2139;
          _la = this.tokenStream.LA(1);
          if (!((_la - 55 & ~31) === 0 && (1 << _la - 55 & 538968065) !== 0 || _la === 119 || _la === 124)) {
            this.errorHandler.recoverInline(this);
          } else {
            this.errorHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    type_name_for_type_element() {
      let localContext = new Type_name_for_type_elementContext(this.context, this.state);
      this.enterRule(localContext, 260, _QBasicParser.RULE_type_name_for_type_element);
      try {
        this.state = 2148;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.INTEGER:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 2141;
              this.match(_QBasicParser.INTEGER);
            }
            break;
          case _QBasicParser.LONG:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 2142;
              this.match(_QBasicParser.LONG);
            }
            break;
          case _QBasicParser.SINGLE:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 2143;
              this.match(_QBasicParser.SINGLE);
            }
            break;
          case _QBasicParser.DOUBLE:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 2144;
              this.match(_QBasicParser.DOUBLE);
            }
            break;
          case _QBasicParser.STRING:
            this.enterOuterAlt(localContext, 5);
            {
              this.state = 2145;
              this.fixed_string();
            }
            break;
          case _QBasicParser.ID:
            this.enterOuterAlt(localContext, 6);
            {
              this.state = 2146;
              this.untyped_id();
            }
            break;
          case _QBasicParser.FNID:
            this.enterOuterAlt(localContext, 7);
            {
              this.state = 2147;
              this.untyped_fnid();
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    file_number() {
      let localContext = new File_numberContext(this.context, this.state);
      this.enterRule(localContext, 262, _QBasicParser.RULE_file_number);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 2150;
          this.match(_QBasicParser.NUMBER);
          this.state = 2151;
          this.expr(0);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    fixed_string() {
      let localContext = new Fixed_stringContext(this.context, this.state);
      this.enterRule(localContext, 264, _QBasicParser.RULE_fixed_string);
      let _la;
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 2153;
          this.match(_QBasicParser.STRING);
          this.state = 2154;
          this.match(_QBasicParser.TIMES);
          this.state = 2155;
          _la = this.tokenStream.LA(1);
          if (!(_la === 22 || _la === 141)) {
            this.errorHandler.recoverInline(this);
          } else {
            this.errorHandler.reportMatch(this);
            this.consume();
          }
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    untyped_id() {
      let localContext = new Untyped_idContext(this.context, this.state);
      this.enterRule(localContext, 266, _QBasicParser.RULE_untyped_id);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 2157;
          this.match(_QBasicParser.ID);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    untyped_fnid() {
      let localContext = new Untyped_fnidContext(this.context, this.state);
      this.enterRule(localContext, 268, _QBasicParser.RULE_untyped_fnid);
      try {
        this.enterOuterAlt(localContext, 1);
        {
          this.state = 2159;
          this.match(_QBasicParser.FNID);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    literal() {
      let localContext = new LiteralContext(this.context, this.state);
      this.enterRule(localContext, 270, _QBasicParser.RULE_literal);
      let _la;
      try {
        this.state = 2168;
        this.errorHandler.sync(this);
        switch (this.tokenStream.LA(1)) {
          case _QBasicParser.PROBABLY_SINGLE_PRECISION_NUMBER:
            this.enterOuterAlt(localContext, 1);
            {
              this.state = 2161;
              this.match(_QBasicParser.PROBABLY_SINGLE_PRECISION_NUMBER);
            }
            break;
          case _QBasicParser.DOUBLE_PRECISION_NUMBER:
            this.enterOuterAlt(localContext, 2);
            {
              this.state = 2162;
              this.match(_QBasicParser.DOUBLE_PRECISION_NUMBER);
            }
            break;
          case _QBasicParser.DIGITS:
          case _QBasicParser.HEX:
          case _QBasicParser.OCTAL:
            this.enterOuterAlt(localContext, 3);
            {
              this.state = 2163;
              _la = this.tokenStream.LA(1);
              if (!((_la & ~31) === 0 && (1 << _la & 29360128) !== 0)) {
                this.errorHandler.recoverInline(this);
              } else {
                this.errorHandler.reportMatch(this);
                this.consume();
              }
              this.state = 2165;
              this.errorHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this.tokenStream, 274, this.context)) {
                case 1:
                  {
                    this.state = 2164;
                    _la = this.tokenStream.LA(1);
                    if (!(_la === 19 || _la === 20)) {
                      this.errorHandler.recoverInline(this);
                    } else {
                      this.errorHandler.reportMatch(this);
                      this.consume();
                    }
                  }
                  break;
              }
            }
            break;
          case _QBasicParser.STRING_LITERAL:
            this.enterOuterAlt(localContext, 4);
            {
              this.state = 2167;
              this.match(_QBasicParser.STRING_LITERAL);
            }
            break;
          default:
            throw new NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof RecognitionException) {
          this.errorHandler.reportError(this, re);
          this.errorHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localContext;
    }
    sempred(localContext, ruleIndex, predIndex) {
      switch (ruleIndex) {
        case 122:
          return this.expr_sempred(localContext, predIndex);
      }
      return true;
    }
    expr_sempred(localContext, predIndex) {
      switch (predIndex) {
        case 0:
          return this.precpred(this.context, 17);
        case 1:
          return this.precpred(this.context, 14);
        case 2:
          return this.precpred(this.context, 13);
        case 3:
          return this.precpred(this.context, 12);
        case 4:
          return this.precpred(this.context, 11);
        case 5:
          return this.precpred(this.context, 10);
        case 6:
          return this.precpred(this.context, 8);
        case 7:
          return this.precpred(this.context, 7);
        case 8:
          return this.precpred(this.context, 6);
        case 9:
          return this.precpred(this.context, 5);
        case 10:
          return this.precpred(this.context, 4);
      }
      return true;
    }
    static _serializedATN = [
      4,
      1,
      154,
      2171,
      2,
      0,
      7,
      0,
      2,
      1,
      7,
      1,
      2,
      2,
      7,
      2,
      2,
      3,
      7,
      3,
      2,
      4,
      7,
      4,
      2,
      5,
      7,
      5,
      2,
      6,
      7,
      6,
      2,
      7,
      7,
      7,
      2,
      8,
      7,
      8,
      2,
      9,
      7,
      9,
      2,
      10,
      7,
      10,
      2,
      11,
      7,
      11,
      2,
      12,
      7,
      12,
      2,
      13,
      7,
      13,
      2,
      14,
      7,
      14,
      2,
      15,
      7,
      15,
      2,
      16,
      7,
      16,
      2,
      17,
      7,
      17,
      2,
      18,
      7,
      18,
      2,
      19,
      7,
      19,
      2,
      20,
      7,
      20,
      2,
      21,
      7,
      21,
      2,
      22,
      7,
      22,
      2,
      23,
      7,
      23,
      2,
      24,
      7,
      24,
      2,
      25,
      7,
      25,
      2,
      26,
      7,
      26,
      2,
      27,
      7,
      27,
      2,
      28,
      7,
      28,
      2,
      29,
      7,
      29,
      2,
      30,
      7,
      30,
      2,
      31,
      7,
      31,
      2,
      32,
      7,
      32,
      2,
      33,
      7,
      33,
      2,
      34,
      7,
      34,
      2,
      35,
      7,
      35,
      2,
      36,
      7,
      36,
      2,
      37,
      7,
      37,
      2,
      38,
      7,
      38,
      2,
      39,
      7,
      39,
      2,
      40,
      7,
      40,
      2,
      41,
      7,
      41,
      2,
      42,
      7,
      42,
      2,
      43,
      7,
      43,
      2,
      44,
      7,
      44,
      2,
      45,
      7,
      45,
      2,
      46,
      7,
      46,
      2,
      47,
      7,
      47,
      2,
      48,
      7,
      48,
      2,
      49,
      7,
      49,
      2,
      50,
      7,
      50,
      2,
      51,
      7,
      51,
      2,
      52,
      7,
      52,
      2,
      53,
      7,
      53,
      2,
      54,
      7,
      54,
      2,
      55,
      7,
      55,
      2,
      56,
      7,
      56,
      2,
      57,
      7,
      57,
      2,
      58,
      7,
      58,
      2,
      59,
      7,
      59,
      2,
      60,
      7,
      60,
      2,
      61,
      7,
      61,
      2,
      62,
      7,
      62,
      2,
      63,
      7,
      63,
      2,
      64,
      7,
      64,
      2,
      65,
      7,
      65,
      2,
      66,
      7,
      66,
      2,
      67,
      7,
      67,
      2,
      68,
      7,
      68,
      2,
      69,
      7,
      69,
      2,
      70,
      7,
      70,
      2,
      71,
      7,
      71,
      2,
      72,
      7,
      72,
      2,
      73,
      7,
      73,
      2,
      74,
      7,
      74,
      2,
      75,
      7,
      75,
      2,
      76,
      7,
      76,
      2,
      77,
      7,
      77,
      2,
      78,
      7,
      78,
      2,
      79,
      7,
      79,
      2,
      80,
      7,
      80,
      2,
      81,
      7,
      81,
      2,
      82,
      7,
      82,
      2,
      83,
      7,
      83,
      2,
      84,
      7,
      84,
      2,
      85,
      7,
      85,
      2,
      86,
      7,
      86,
      2,
      87,
      7,
      87,
      2,
      88,
      7,
      88,
      2,
      89,
      7,
      89,
      2,
      90,
      7,
      90,
      2,
      91,
      7,
      91,
      2,
      92,
      7,
      92,
      2,
      93,
      7,
      93,
      2,
      94,
      7,
      94,
      2,
      95,
      7,
      95,
      2,
      96,
      7,
      96,
      2,
      97,
      7,
      97,
      2,
      98,
      7,
      98,
      2,
      99,
      7,
      99,
      2,
      100,
      7,
      100,
      2,
      101,
      7,
      101,
      2,
      102,
      7,
      102,
      2,
      103,
      7,
      103,
      2,
      104,
      7,
      104,
      2,
      105,
      7,
      105,
      2,
      106,
      7,
      106,
      2,
      107,
      7,
      107,
      2,
      108,
      7,
      108,
      2,
      109,
      7,
      109,
      2,
      110,
      7,
      110,
      2,
      111,
      7,
      111,
      2,
      112,
      7,
      112,
      2,
      113,
      7,
      113,
      2,
      114,
      7,
      114,
      2,
      115,
      7,
      115,
      2,
      116,
      7,
      116,
      2,
      117,
      7,
      117,
      2,
      118,
      7,
      118,
      2,
      119,
      7,
      119,
      2,
      120,
      7,
      120,
      2,
      121,
      7,
      121,
      2,
      122,
      7,
      122,
      2,
      123,
      7,
      123,
      2,
      124,
      7,
      124,
      2,
      125,
      7,
      125,
      2,
      126,
      7,
      126,
      2,
      127,
      7,
      127,
      2,
      128,
      7,
      128,
      2,
      129,
      7,
      129,
      2,
      130,
      7,
      130,
      2,
      131,
      7,
      131,
      2,
      132,
      7,
      132,
      2,
      133,
      7,
      133,
      2,
      134,
      7,
      134,
      2,
      135,
      7,
      135,
      1,
      0,
      3,
      0,
      274,
      8,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      3,
      0,
      284,
      8,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      5,
      0,
      292,
      8,
      0,
      10,
      0,
      12,
      0,
      295,
      9,
      0,
      1,
      0,
      1,
      0,
      5,
      0,
      299,
      8,
      0,
      10,
      0,
      12,
      0,
      302,
      9,
      0,
      1,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      5,
      1,
      308,
      8,
      1,
      10,
      1,
      12,
      1,
      311,
      9,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      5,
      1,
      316,
      8,
      1,
      10,
      1,
      12,
      1,
      319,
      9,
      1,
      1,
      1,
      1,
      1,
      3,
      1,
      323,
      8,
      1,
      1,
      1,
      1,
      1,
      3,
      1,
      327,
      8,
      1,
      1,
      1,
      1,
      1,
      5,
      1,
      331,
      8,
      1,
      10,
      1,
      12,
      1,
      334,
      9,
      1,
      1,
      1,
      1,
      1,
      5,
      1,
      338,
      8,
      1,
      10,
      1,
      12,
      1,
      341,
      9,
      1,
      1,
      1,
      3,
      1,
      344,
      8,
      1,
      1,
      1,
      1,
      1,
      3,
      1,
      348,
      8,
      1,
      1,
      1,
      1,
      1,
      5,
      1,
      352,
      8,
      1,
      10,
      1,
      12,
      1,
      355,
      9,
      1,
      3,
      1,
      357,
      8,
      1,
      1,
      2,
      1,
      2,
      1,
      2,
      1,
      2,
      3,
      2,
      363,
      8,
      2,
      1,
      3,
      1,
      3,
      1,
      4,
      1,
      4,
      3,
      4,
      369,
      8,
      4,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      1,
      5,
      3,
      5,
      440,
      8,
      5,
      1,
      6,
      1,
      6,
      1,
      6,
      1,
      6,
      1,
      6,
      3,
      6,
      447,
      8,
      6,
      1,
      6,
      1,
      6,
      3,
      6,
      451,
      8,
      6,
      1,
      6,
      3,
      6,
      454,
      8,
      6,
      1,
      7,
      1,
      7,
      1,
      7,
      5,
      7,
      459,
      8,
      7,
      10,
      7,
      12,
      7,
      462,
      9,
      7,
      1,
      8,
      1,
      8,
      3,
      8,
      466,
      8,
      8,
      1,
      8,
      1,
      8,
      1,
      8,
      1,
      8,
      1,
      8,
      3,
      8,
      473,
      8,
      8,
      3,
      8,
      475,
      8,
      8,
      1,
      9,
      1,
      9,
      1,
      9,
      1,
      9,
      3,
      9,
      481,
      8,
      9,
      1,
      9,
      1,
      9,
      3,
      9,
      485,
      8,
      9,
      1,
      9,
      3,
      9,
      488,
      8,
      9,
      1,
      9,
      1,
      9,
      1,
      9,
      1,
      9,
      1,
      9,
      1,
      9,
      3,
      9,
      496,
      8,
      9,
      1,
      10,
      1,
      10,
      1,
      10,
      5,
      10,
      501,
      8,
      10,
      10,
      10,
      12,
      10,
      504,
      9,
      10,
      1,
      11,
      1,
      11,
      1,
      11,
      1,
      11,
      1,
      11,
      3,
      11,
      511,
      8,
      11,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      3,
      12,
      517,
      8,
      12,
      1,
      12,
      3,
      12,
      520,
      8,
      12,
      1,
      12,
      3,
      12,
      523,
      8,
      12,
      1,
      12,
      1,
      12,
      1,
      12,
      1,
      13,
      1,
      13,
      1,
      13,
      5,
      13,
      531,
      8,
      13,
      10,
      13,
      12,
      13,
      534,
      9,
      13,
      1,
      14,
      1,
      14,
      3,
      14,
      538,
      8,
      14,
      1,
      14,
      1,
      14,
      1,
      14,
      1,
      14,
      1,
      14,
      3,
      14,
      545,
      8,
      14,
      3,
      14,
      547,
      8,
      14,
      1,
      15,
      1,
      15,
      3,
      15,
      551,
      8,
      15,
      1,
      15,
      1,
      15,
      1,
      16,
      3,
      16,
      556,
      8,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      1,
      16,
      5,
      16,
      562,
      8,
      16,
      10,
      16,
      12,
      16,
      565,
      9,
      16,
      1,
      17,
      1,
      17,
      1,
      17,
      1,
      17,
      1,
      17,
      1,
      17,
      5,
      17,
      573,
      8,
      17,
      10,
      17,
      12,
      17,
      576,
      9,
      17,
      1,
      17,
      3,
      17,
      579,
      8,
      17,
      1,
      17,
      1,
      17,
      1,
      18,
      3,
      18,
      584,
      8,
      18,
      1,
      18,
      1,
      18,
      1,
      18,
      1,
      18,
      1,
      18,
      1,
      19,
      3,
      19,
      592,
      8,
      19,
      1,
      19,
      1,
      19,
      1,
      19,
      1,
      20,
      3,
      20,
      598,
      8,
      20,
      1,
      20,
      1,
      20,
      1,
      20,
      1,
      21,
      3,
      21,
      604,
      8,
      21,
      1,
      21,
      1,
      21,
      3,
      21,
      608,
      8,
      21,
      1,
      21,
      1,
      21,
      5,
      21,
      612,
      8,
      21,
      10,
      21,
      12,
      21,
      615,
      9,
      21,
      1,
      21,
      1,
      21,
      5,
      21,
      619,
      8,
      21,
      10,
      21,
      12,
      21,
      622,
      9,
      21,
      1,
      22,
      1,
      22,
      1,
      22,
      5,
      22,
      627,
      8,
      22,
      10,
      22,
      12,
      22,
      630,
      9,
      22,
      1,
      22,
      1,
      22,
      3,
      22,
      634,
      8,
      22,
      1,
      22,
      1,
      22,
      3,
      22,
      638,
      8,
      22,
      1,
      22,
      1,
      22,
      5,
      22,
      642,
      8,
      22,
      10,
      22,
      12,
      22,
      645,
      9,
      22,
      1,
      22,
      1,
      22,
      5,
      22,
      649,
      8,
      22,
      10,
      22,
      12,
      22,
      652,
      9,
      22,
      1,
      23,
      1,
      23,
      1,
      23,
      1,
      23,
      1,
      24,
      1,
      24,
      1,
      24,
      1,
      24,
      3,
      24,
      662,
      8,
      24,
      1,
      24,
      3,
      24,
      665,
      8,
      24,
      1,
      24,
      3,
      24,
      668,
      8,
      24,
      1,
      24,
      1,
      24,
      1,
      24,
      1,
      25,
      3,
      25,
      674,
      8,
      25,
      1,
      25,
      1,
      25,
      1,
      25,
      1,
      25,
      5,
      25,
      680,
      8,
      25,
      10,
      25,
      12,
      25,
      683,
      9,
      25,
      1,
      26,
      1,
      26,
      1,
      26,
      3,
      26,
      688,
      8,
      26,
      1,
      26,
      4,
      26,
      691,
      8,
      26,
      11,
      26,
      12,
      26,
      692,
      1,
      26,
      1,
      26,
      1,
      26,
      1,
      26,
      4,
      26,
      699,
      8,
      26,
      11,
      26,
      12,
      26,
      700,
      1,
      26,
      1,
      26,
      1,
      26,
      1,
      27,
      1,
      27,
      3,
      27,
      708,
      8,
      27,
      1,
      27,
      1,
      27,
      1,
      27,
      4,
      27,
      713,
      8,
      27,
      11,
      27,
      12,
      27,
      714,
      1,
      28,
      3,
      28,
      718,
      8,
      28,
      1,
      28,
      1,
      28,
      1,
      28,
      1,
      28,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      1,
      29,
      3,
      29,
      730,
      8,
      29,
      1,
      29,
      1,
      29,
      3,
      29,
      734,
      8,
      29,
      3,
      29,
      736,
      8,
      29,
      1,
      30,
      1,
      30,
      1,
      30,
      5,
      30,
      741,
      8,
      30,
      10,
      30,
      12,
      30,
      744,
      9,
      30,
      1,
      31,
      1,
      31,
      1,
      31,
      1,
      31,
      1,
      31,
      3,
      31,
      751,
      8,
      31,
      1,
      31,
      3,
      31,
      754,
      8,
      31,
      1,
      32,
      1,
      32,
      1,
      32,
      1,
      32,
      1,
      32,
      1,
      32,
      3,
      32,
      762,
      8,
      32,
      1,
      32,
      1,
      32,
      1,
      32,
      1,
      33,
      1,
      33,
      1,
      33,
      5,
      33,
      770,
      8,
      33,
      10,
      33,
      12,
      33,
      773,
      9,
      33,
      1,
      34,
      1,
      34,
      1,
      34,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      1,
      35,
      3,
      35,
      802,
      8,
      35,
      1,
      36,
      1,
      36,
      3,
      36,
      806,
      8,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      3,
      36,
      817,
      8,
      36,
      1,
      36,
      1,
      36,
      3,
      36,
      821,
      8,
      36,
      1,
      36,
      1,
      36,
      3,
      36,
      825,
      8,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      3,
      36,
      831,
      8,
      36,
      1,
      36,
      1,
      36,
      3,
      36,
      835,
      8,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      3,
      36,
      841,
      8,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      1,
      36,
      3,
      36,
      847,
      8,
      36,
      3,
      36,
      849,
      8,
      36,
      1,
      37,
      1,
      37,
      3,
      37,
      853,
      8,
      37,
      1,
      37,
      1,
      37,
      3,
      37,
      857,
      8,
      37,
      1,
      37,
      1,
      37,
      1,
      37,
      1,
      37,
      3,
      37,
      863,
      8,
      37,
      1,
      37,
      1,
      37,
      3,
      37,
      867,
      8,
      37,
      1,
      37,
      1,
      37,
      3,
      37,
      871,
      8,
      37,
      1,
      38,
      1,
      38,
      3,
      38,
      875,
      8,
      38,
      1,
      38,
      3,
      38,
      878,
      8,
      38,
      1,
      38,
      1,
      38,
      3,
      38,
      882,
      8,
      38,
      1,
      38,
      5,
      38,
      885,
      8,
      38,
      10,
      38,
      12,
      38,
      888,
      9,
      38,
      1,
      39,
      1,
      39,
      3,
      39,
      892,
      8,
      39,
      1,
      39,
      1,
      39,
      3,
      39,
      896,
      8,
      39,
      1,
      39,
      1,
      39,
      1,
      39,
      3,
      39,
      901,
      8,
      39,
      1,
      39,
      1,
      39,
      1,
      39,
      3,
      39,
      906,
      8,
      39,
      3,
      39,
      908,
      8,
      39,
      1,
      40,
      1,
      40,
      1,
      40,
      1,
      40,
      5,
      40,
      914,
      8,
      40,
      10,
      40,
      12,
      40,
      917,
      9,
      40,
      1,
      41,
      1,
      41,
      1,
      41,
      1,
      41,
      1,
      42,
      1,
      42,
      1,
      43,
      1,
      43,
      1,
      43,
      1,
      43,
      5,
      43,
      929,
      8,
      43,
      10,
      43,
      12,
      43,
      932,
      9,
      43,
      1,
      44,
      1,
      44,
      1,
      44,
      3,
      44,
      937,
      8,
      44,
      1,
      45,
      1,
      45,
      1,
      45,
      1,
      45,
      3,
      45,
      943,
      8,
      45,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      5,
      46,
      949,
      8,
      46,
      10,
      46,
      12,
      46,
      952,
      9,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      5,
      46,
      958,
      8,
      46,
      10,
      46,
      12,
      46,
      961,
      9,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      5,
      46,
      967,
      8,
      46,
      10,
      46,
      12,
      46,
      970,
      9,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      5,
      46,
      976,
      8,
      46,
      10,
      46,
      12,
      46,
      979,
      9,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      1,
      46,
      5,
      46,
      985,
      8,
      46,
      10,
      46,
      12,
      46,
      988,
      9,
      46,
      3,
      46,
      990,
      8,
      46,
      1,
      47,
      1,
      47,
      1,
      47,
      3,
      47,
      995,
      8,
      47,
      1,
      48,
      1,
      48,
      3,
      48,
      999,
      8,
      48,
      1,
      48,
      1,
      48,
      1,
      48,
      5,
      48,
      1004,
      8,
      48,
      10,
      48,
      12,
      48,
      1007,
      9,
      48,
      1,
      48,
      1,
      48,
      3,
      48,
      1011,
      8,
      48,
      1,
      48,
      1,
      48,
      1,
      48,
      5,
      48,
      1016,
      8,
      48,
      10,
      48,
      12,
      48,
      1019,
      9,
      48,
      3,
      48,
      1021,
      8,
      48,
      1,
      49,
      1,
      49,
      3,
      49,
      1025,
      8,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      1,
      49,
      3,
      49,
      1032,
      8,
      49,
      3,
      49,
      1034,
      8,
      49,
      1,
      50,
      1,
      50,
      1,
      50,
      1,
      50,
      5,
      50,
      1040,
      8,
      50,
      10,
      50,
      12,
      50,
      1043,
      9,
      50,
      1,
      50,
      1,
      50,
      1,
      51,
      1,
      51,
      1,
      51,
      3,
      51,
      1050,
      8,
      51,
      1,
      51,
      1,
      51,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      1,
      52,
      3,
      52,
      1069,
      8,
      52,
      1,
      53,
      1,
      53,
      1,
      53,
      1,
      53,
      3,
      53,
      1075,
      8,
      53,
      1,
      54,
      1,
      54,
      1,
      55,
      1,
      55,
      1,
      55,
      1,
      56,
      1,
      56,
      3,
      56,
      1084,
      8,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      1,
      56,
      5,
      56,
      1091,
      8,
      56,
      10,
      56,
      12,
      56,
      1094,
      9,
      56,
      1,
      57,
      1,
      57,
      1,
      57,
      1,
      57,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      3,
      58,
      1108,
      8,
      58,
      1,
      58,
      1,
      58,
      1,
      58,
      3,
      58,
      1113,
      8,
      58,
      1,
      58,
      1,
      58,
      3,
      58,
      1117,
      8,
      58,
      1,
      59,
      1,
      59,
      3,
      59,
      1121,
      8,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      3,
      59,
      1130,
      8,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      59,
      1,
      60,
      1,
      60,
      3,
      60,
      1142,
      8,
      60,
      1,
      60,
      1,
      60,
      1,
      60,
      3,
      60,
      1147,
      8,
      60,
      1,
      60,
      1,
      60,
      3,
      60,
      1151,
      8,
      60,
      3,
      60,
      1153,
      8,
      60,
      1,
      61,
      1,
      61,
      1,
      61,
      1,
      62,
      1,
      62,
      1,
      62,
      1,
      63,
      1,
      63,
      3,
      63,
      1163,
      8,
      63,
      1,
      64,
      1,
      64,
      1,
      64,
      1,
      64,
      1,
      64,
      1,
      64,
      3,
      64,
      1171,
      8,
      64,
      1,
      64,
      1,
      64,
      1,
      64,
      1,
      64,
      1,
      64,
      3,
      64,
      1178,
      8,
      64,
      3,
      64,
      1180,
      8,
      64,
      1,
      65,
      1,
      65,
      1,
      65,
      5,
      65,
      1185,
      8,
      65,
      10,
      65,
      12,
      65,
      1188,
      9,
      65,
      1,
      65,
      3,
      65,
      1191,
      8,
      65,
      1,
      66,
      1,
      66,
      3,
      66,
      1195,
      8,
      66,
      1,
      66,
      1,
      66,
      3,
      66,
      1199,
      8,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      5,
      66,
      1204,
      8,
      66,
      10,
      66,
      12,
      66,
      1207,
      9,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      1,
      66,
      5,
      66,
      1215,
      8,
      66,
      10,
      66,
      12,
      66,
      1218,
      9,
      66,
      3,
      66,
      1220,
      8,
      66,
      1,
      67,
      1,
      67,
      3,
      67,
      1224,
      8,
      67,
      1,
      67,
      1,
      67,
      1,
      67,
      1,
      67,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      1,
      68,
      3,
      68,
      1239,
      8,
      68,
      1,
      69,
      1,
      69,
      3,
      69,
      1243,
      8,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      3,
      69,
      1251,
      8,
      69,
      1,
      69,
      1,
      69,
      3,
      69,
      1255,
      8,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      3,
      69,
      1264,
      8,
      69,
      1,
      69,
      1,
      69,
      3,
      69,
      1268,
      8,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      3,
      69,
      1274,
      8,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      1,
      69,
      3,
      69,
      1280,
      8,
      69,
      1,
      69,
      3,
      69,
      1283,
      8,
      69,
      3,
      69,
      1285,
      8,
      69,
      1,
      70,
      1,
      70,
      1,
      71,
      1,
      71,
      1,
      71,
      3,
      71,
      1292,
      8,
      71,
      1,
      71,
      1,
      71,
      3,
      71,
      1296,
      8,
      71,
      1,
      71,
      1,
      71,
      1,
      71,
      1,
      71,
      1,
      71,
      1,
      71,
      1,
      71,
      3,
      71,
      1305,
      8,
      71,
      1,
      72,
      1,
      72,
      3,
      72,
      1309,
      8,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1313,
      8,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1317,
      8,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1321,
      8,
      72,
      1,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1326,
      8,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1330,
      8,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1334,
      8,
      72,
      1,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1339,
      8,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1343,
      8,
      72,
      1,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1348,
      8,
      72,
      1,
      72,
      1,
      72,
      1,
      72,
      3,
      72,
      1353,
      8,
      72,
      1,
      73,
      1,
      73,
      3,
      73,
      1357,
      8,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      1,
      73,
      3,
      73,
      1366,
      8,
      73,
      3,
      73,
      1368,
      8,
      73,
      1,
      74,
      1,
      74,
      1,
      74,
      3,
      74,
      1373,
      8,
      74,
      1,
      74,
      5,
      74,
      1376,
      8,
      74,
      10,
      74,
      12,
      74,
      1379,
      9,
      74,
      1,
      75,
      1,
      75,
      1,
      75,
      1,
      75,
      1,
      75,
      3,
      75,
      1386,
      8,
      75,
      1,
      75,
      1,
      75,
      3,
      75,
      1390,
      8,
      75,
      1,
      75,
      5,
      75,
      1393,
      8,
      75,
      10,
      75,
      12,
      75,
      1396,
      9,
      75,
      1,
      76,
      1,
      76,
      1,
      76,
      1,
      76,
      1,
      76,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      3,
      77,
      1410,
      8,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      77,
      1,
      78,
      1,
      78,
      1,
      78,
      1,
      78,
      1,
      78,
      1,
      79,
      1,
      79,
      1,
      79,
      1,
      79,
      1,
      79,
      1,
      79,
      3,
      79,
      1427,
      8,
      79,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      1,
      80,
      3,
      80,
      1473,
      8,
      80,
      1,
      81,
      1,
      81,
      1,
      81,
      1,
      81,
      1,
      81,
      1,
      82,
      1,
      82,
      1,
      82,
      5,
      82,
      1483,
      8,
      82,
      10,
      82,
      12,
      82,
      1486,
      9,
      82,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      83,
      1,
      84,
      1,
      84,
      1,
      84,
      1,
      84,
      3,
      84,
      1497,
      8,
      84,
      1,
      84,
      1,
      84,
      1,
      84,
      1,
      84,
      1,
      84,
      3,
      84,
      1504,
      8,
      84,
      1,
      85,
      1,
      85,
      1,
      85,
      1,
      85,
      3,
      85,
      1510,
      8,
      85,
      1,
      85,
      1,
      85,
      3,
      85,
      1514,
      8,
      85,
      1,
      85,
      3,
      85,
      1517,
      8,
      85,
      1,
      85,
      1,
      85,
      3,
      85,
      1521,
      8,
      85,
      1,
      85,
      1,
      85,
      1,
      85,
      1,
      85,
      1,
      85,
      3,
      85,
      1528,
      8,
      85,
      1,
      86,
      1,
      86,
      1,
      87,
      1,
      87,
      1,
      87,
      1,
      87,
      3,
      87,
      1536,
      8,
      87,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      88,
      1,
      88,
      3,
      88,
      1546,
      8,
      88,
      1,
      89,
      1,
      89,
      3,
      89,
      1550,
      8,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      3,
      89,
      1559,
      8,
      89,
      1,
      89,
      1,
      89,
      3,
      89,
      1563,
      8,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      3,
      89,
      1569,
      8,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      1,
      89,
      3,
      89,
      1575,
      8,
      89,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      90,
      1,
      90,
      3,
      90,
      1586,
      8,
      90,
      1,
      91,
      1,
      91,
      1,
      91,
      1,
      92,
      1,
      92,
      3,
      92,
      1593,
      8,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      1,
      92,
      3,
      92,
      1602,
      8,
      92,
      1,
      93,
      1,
      93,
      1,
      93,
      1,
      93,
      3,
      93,
      1608,
      8,
      93,
      1,
      93,
      3,
      93,
      1611,
      8,
      93,
      1,
      93,
      1,
      93,
      3,
      93,
      1615,
      8,
      93,
      1,
      93,
      5,
      93,
      1618,
      8,
      93,
      10,
      93,
      12,
      93,
      1621,
      9,
      93,
      1,
      94,
      1,
      94,
      1,
      94,
      1,
      94,
      3,
      94,
      1627,
      8,
      94,
      1,
      94,
      1,
      94,
      1,
      94,
      1,
      94,
      3,
      94,
      1633,
      8,
      94,
      1,
      94,
      1,
      94,
      3,
      94,
      1637,
      8,
      94,
      1,
      94,
      5,
      94,
      1640,
      8,
      94,
      10,
      94,
      12,
      94,
      1643,
      9,
      94,
      1,
      95,
      1,
      95,
      3,
      95,
      1647,
      8,
      95,
      1,
      95,
      1,
      95,
      1,
      95,
      1,
      95,
      1,
      95,
      1,
      95,
      1,
      95,
      3,
      95,
      1656,
      8,
      95,
      1,
      96,
      1,
      96,
      3,
      96,
      1660,
      8,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      1,
      96,
      3,
      96,
      1671,
      8,
      96,
      1,
      97,
      1,
      97,
      3,
      97,
      1675,
      8,
      97,
      1,
      97,
      1,
      97,
      1,
      97,
      3,
      97,
      1680,
      8,
      97,
      1,
      97,
      1,
      97,
      3,
      97,
      1684,
      8,
      97,
      3,
      97,
      1686,
      8,
      97,
      1,
      98,
      1,
      98,
      1,
      98,
      1,
      98,
      5,
      98,
      1692,
      8,
      98,
      10,
      98,
      12,
      98,
      1695,
      9,
      98,
      1,
      99,
      1,
      99,
      1,
      100,
      1,
      100,
      1,
      100,
      3,
      100,
      1702,
      8,
      100,
      1,
      101,
      1,
      101,
      3,
      101,
      1706,
      8,
      101,
      1,
      102,
      1,
      102,
      1,
      102,
      1,
      102,
      1,
      102,
      1,
      103,
      1,
      103,
      1,
      103,
      1,
      103,
      1,
      103,
      5,
      103,
      1718,
      8,
      103,
      10,
      103,
      12,
      103,
      1721,
      9,
      103,
      1,
      103,
      1,
      103,
      1,
      104,
      1,
      104,
      1,
      104,
      5,
      104,
      1728,
      8,
      104,
      10,
      104,
      12,
      104,
      1731,
      9,
      104,
      1,
      105,
      1,
      105,
      1,
      105,
      1,
      106,
      1,
      106,
      1,
      106,
      1,
      106,
      5,
      106,
      1740,
      8,
      106,
      10,
      106,
      12,
      106,
      1743,
      9,
      106,
      1,
      106,
      1,
      106,
      3,
      106,
      1747,
      8,
      106,
      1,
      107,
      1,
      107,
      1,
      107,
      1,
      107,
      1,
      107,
      1,
      107,
      1,
      107,
      1,
      107,
      3,
      107,
      1757,
      8,
      107,
      1,
      108,
      3,
      108,
      1760,
      8,
      108,
      1,
      108,
      1,
      108,
      1,
      108,
      1,
      109,
      1,
      109,
      3,
      109,
      1767,
      8,
      109,
      1,
      109,
      3,
      109,
      1770,
      8,
      109,
      1,
      109,
      1,
      109,
      1,
      109,
      5,
      109,
      1775,
      8,
      109,
      10,
      109,
      12,
      109,
      1778,
      9,
      109,
      1,
      109,
      1,
      109,
      1,
      109,
      1,
      109,
      5,
      109,
      1784,
      8,
      109,
      10,
      109,
      12,
      109,
      1787,
      9,
      109,
      1,
      109,
      1,
      109,
      1,
      109,
      1,
      109,
      5,
      109,
      1793,
      8,
      109,
      10,
      109,
      12,
      109,
      1796,
      9,
      109,
      3,
      109,
      1798,
      8,
      109,
      1,
      110,
      1,
      110,
      3,
      110,
      1802,
      8,
      110,
      1,
      110,
      1,
      110,
      1,
      111,
      1,
      111,
      3,
      111,
      1808,
      8,
      111,
      1,
      111,
      1,
      111,
      1,
      111,
      1,
      111,
      1,
      111,
      3,
      111,
      1815,
      8,
      111,
      3,
      111,
      1817,
      8,
      111,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      3,
      112,
      1823,
      8,
      112,
      1,
      112,
      1,
      112,
      3,
      112,
      1827,
      8,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      3,
      112,
      1833,
      8,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      1,
      112,
      3,
      112,
      1839,
      8,
      112,
      1,
      113,
      1,
      113,
      3,
      113,
      1843,
      8,
      113,
      1,
      113,
      1,
      113,
      1,
      113,
      1,
      113,
      1,
      114,
      1,
      114,
      1,
      115,
      1,
      115,
      3,
      115,
      1853,
      8,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      1,
      115,
      3,
      115,
      1862,
      8,
      115,
      3,
      115,
      1864,
      8,
      115,
      1,
      116,
      1,
      116,
      1,
      116,
      3,
      116,
      1869,
      8,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      3,
      116,
      1884,
      8,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      1,
      116,
      3,
      116,
      1890,
      8,
      116,
      3,
      116,
      1892,
      8,
      116,
      1,
      117,
      1,
      117,
      1,
      117,
      1,
      117,
      1,
      117,
      1,
      117,
      3,
      117,
      1900,
      8,
      117,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      118,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      1,
      119,
      3,
      119,
      1925,
      8,
      119,
      1,
      120,
      1,
      120,
      3,
      120,
      1929,
      8,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      1,
      120,
      3,
      120,
      1943,
      8,
      120,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      3,
      121,
      1954,
      8,
      121,
      1,
      121,
      1,
      121,
      1,
      121,
      5,
      121,
      1959,
      8,
      121,
      10,
      121,
      12,
      121,
      1962,
      9,
      121,
      3,
      121,
      1964,
      8,
      121,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      3,
      122,
      1980,
      8,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      1,
      122,
      5,
      122,
      2015,
      8,
      122,
      10,
      122,
      12,
      122,
      2018,
      9,
      122,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      3,
      123,
      2025,
      8,
      123,
      1,
      123,
      3,
      123,
      2028,
      8,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      3,
      123,
      2035,
      8,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      3,
      123,
      2052,
      8,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      3,
      123,
      2073,
      8,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      1,
      123,
      3,
      123,
      2088,
      8,
      123,
      1,
      124,
      1,
      124,
      1,
      124,
      1,
      124,
      5,
      124,
      2094,
      8,
      124,
      10,
      124,
      12,
      124,
      2097,
      9,
      124,
      3,
      124,
      2099,
      8,
      124,
      1,
      124,
      1,
      124,
      1,
      125,
      1,
      125,
      1,
      125,
      1,
      125,
      3,
      125,
      2107,
      8,
      125,
      3,
      125,
      2109,
      8,
      125,
      1,
      126,
      1,
      126,
      1,
      126,
      1,
      126,
      1,
      126,
      1,
      126,
      1,
      126,
      1,
      126,
      3,
      126,
      2119,
      8,
      126,
      1,
      127,
      1,
      127,
      1,
      127,
      1,
      127,
      1,
      127,
      1,
      127,
      1,
      127,
      3,
      127,
      2128,
      8,
      127,
      1,
      128,
      1,
      128,
      1,
      128,
      1,
      128,
      1,
      128,
      1,
      128,
      1,
      128,
      1,
      128,
      3,
      128,
      2138,
      8,
      128,
      1,
      129,
      1,
      129,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      130,
      1,
      130,
      3,
      130,
      2149,
      8,
      130,
      1,
      131,
      1,
      131,
      1,
      131,
      1,
      132,
      1,
      132,
      1,
      132,
      1,
      132,
      1,
      133,
      1,
      133,
      1,
      134,
      1,
      134,
      1,
      135,
      1,
      135,
      1,
      135,
      1,
      135,
      3,
      135,
      2166,
      8,
      135,
      1,
      135,
      3,
      135,
      2169,
      8,
      135,
      1,
      135,
      0,
      1,
      244,
      136,
      0,
      2,
      4,
      6,
      8,
      10,
      12,
      14,
      16,
      18,
      20,
      22,
      24,
      26,
      28,
      30,
      32,
      34,
      36,
      38,
      40,
      42,
      44,
      46,
      48,
      50,
      52,
      54,
      56,
      58,
      60,
      62,
      64,
      66,
      68,
      70,
      72,
      74,
      76,
      78,
      80,
      82,
      84,
      86,
      88,
      90,
      92,
      94,
      96,
      98,
      100,
      102,
      104,
      106,
      108,
      110,
      112,
      114,
      116,
      118,
      120,
      122,
      124,
      126,
      128,
      130,
      132,
      134,
      136,
      138,
      140,
      142,
      144,
      146,
      148,
      150,
      152,
      154,
      156,
      158,
      160,
      162,
      164,
      166,
      168,
      170,
      172,
      174,
      176,
      178,
      180,
      182,
      184,
      186,
      188,
      190,
      192,
      194,
      196,
      198,
      200,
      202,
      204,
      206,
      208,
      210,
      212,
      214,
      216,
      218,
      220,
      222,
      224,
      226,
      228,
      230,
      232,
      234,
      236,
      238,
      240,
      242,
      244,
      246,
      248,
      250,
      252,
      254,
      256,
      258,
      260,
      262,
      264,
      266,
      268,
      270,
      0,
      15,
      2,
      0,
      1,
      1,
      143,
      143,
      3,
      0,
      94,
      94,
      98,
      98,
      122,
      122,
      1,
      0,
      140,
      141,
      5,
      0,
      47,
      47,
      54,
      54,
      63,
      63,
      65,
      65,
      125,
      125,
      1,
      0,
      11,
      12,
      2,
      0,
      94,
      94,
      98,
      98,
      5,
      0,
      32,
      32,
      35,
      35,
      71,
      71,
      96,
      96,
      107,
      107,
      4,
      0,
      30,
      30,
      97,
      97,
      104,
      105,
      139,
      139,
      1,
      0,
      13,
      18,
      2,
      0,
      5,
      5,
      10,
      10,
      1,
      0,
      8,
      9,
      5,
      0,
      55,
      55,
      76,
      76,
      84,
      84,
      119,
      119,
      124,
      124,
      2,
      0,
      22,
      22,
      141,
      141,
      1,
      0,
      22,
      24,
      1,
      0,
      19,
      20,
      2475,
      0,
      300,
      1,
      0,
      0,
      0,
      2,
      356,
      1,
      0,
      0,
      0,
      4,
      362,
      1,
      0,
      0,
      0,
      6,
      364,
      1,
      0,
      0,
      0,
      8,
      368,
      1,
      0,
      0,
      0,
      10,
      439,
      1,
      0,
      0,
      0,
      12,
      441,
      1,
      0,
      0,
      0,
      14,
      455,
      1,
      0,
      0,
      0,
      16,
      474,
      1,
      0,
      0,
      0,
      18,
      476,
      1,
      0,
      0,
      0,
      20,
      497,
      1,
      0,
      0,
      0,
      22,
      510,
      1,
      0,
      0,
      0,
      24,
      512,
      1,
      0,
      0,
      0,
      26,
      527,
      1,
      0,
      0,
      0,
      28,
      546,
      1,
      0,
      0,
      0,
      30,
      548,
      1,
      0,
      0,
      0,
      32,
      555,
      1,
      0,
      0,
      0,
      34,
      566,
      1,
      0,
      0,
      0,
      36,
      583,
      1,
      0,
      0,
      0,
      38,
      591,
      1,
      0,
      0,
      0,
      40,
      597,
      1,
      0,
      0,
      0,
      42,
      620,
      1,
      0,
      0,
      0,
      44,
      623,
      1,
      0,
      0,
      0,
      46,
      653,
      1,
      0,
      0,
      0,
      48,
      657,
      1,
      0,
      0,
      0,
      50,
      673,
      1,
      0,
      0,
      0,
      52,
      684,
      1,
      0,
      0,
      0,
      54,
      707,
      1,
      0,
      0,
      0,
      56,
      717,
      1,
      0,
      0,
      0,
      58,
      735,
      1,
      0,
      0,
      0,
      60,
      737,
      1,
      0,
      0,
      0,
      62,
      753,
      1,
      0,
      0,
      0,
      64,
      755,
      1,
      0,
      0,
      0,
      66,
      766,
      1,
      0,
      0,
      0,
      68,
      774,
      1,
      0,
      0,
      0,
      70,
      801,
      1,
      0,
      0,
      0,
      72,
      803,
      1,
      0,
      0,
      0,
      74,
      870,
      1,
      0,
      0,
      0,
      76,
      872,
      1,
      0,
      0,
      0,
      78,
      889,
      1,
      0,
      0,
      0,
      80,
      909,
      1,
      0,
      0,
      0,
      82,
      918,
      1,
      0,
      0,
      0,
      84,
      922,
      1,
      0,
      0,
      0,
      86,
      924,
      1,
      0,
      0,
      0,
      88,
      936,
      1,
      0,
      0,
      0,
      90,
      938,
      1,
      0,
      0,
      0,
      92,
      989,
      1,
      0,
      0,
      0,
      94,
      991,
      1,
      0,
      0,
      0,
      96,
      1020,
      1,
      0,
      0,
      0,
      98,
      1033,
      1,
      0,
      0,
      0,
      100,
      1035,
      1,
      0,
      0,
      0,
      102,
      1049,
      1,
      0,
      0,
      0,
      104,
      1068,
      1,
      0,
      0,
      0,
      106,
      1074,
      1,
      0,
      0,
      0,
      108,
      1076,
      1,
      0,
      0,
      0,
      110,
      1078,
      1,
      0,
      0,
      0,
      112,
      1081,
      1,
      0,
      0,
      0,
      114,
      1095,
      1,
      0,
      0,
      0,
      116,
      1099,
      1,
      0,
      0,
      0,
      118,
      1118,
      1,
      0,
      0,
      0,
      120,
      1139,
      1,
      0,
      0,
      0,
      122,
      1154,
      1,
      0,
      0,
      0,
      124,
      1157,
      1,
      0,
      0,
      0,
      126,
      1162,
      1,
      0,
      0,
      0,
      128,
      1179,
      1,
      0,
      0,
      0,
      130,
      1190,
      1,
      0,
      0,
      0,
      132,
      1219,
      1,
      0,
      0,
      0,
      134,
      1221,
      1,
      0,
      0,
      0,
      136,
      1238,
      1,
      0,
      0,
      0,
      138,
      1240,
      1,
      0,
      0,
      0,
      140,
      1286,
      1,
      0,
      0,
      0,
      142,
      1304,
      1,
      0,
      0,
      0,
      144,
      1306,
      1,
      0,
      0,
      0,
      146,
      1354,
      1,
      0,
      0,
      0,
      148,
      1369,
      1,
      0,
      0,
      0,
      150,
      1380,
      1,
      0,
      0,
      0,
      152,
      1397,
      1,
      0,
      0,
      0,
      154,
      1402,
      1,
      0,
      0,
      0,
      156,
      1415,
      1,
      0,
      0,
      0,
      158,
      1420,
      1,
      0,
      0,
      0,
      160,
      1472,
      1,
      0,
      0,
      0,
      162,
      1474,
      1,
      0,
      0,
      0,
      164,
      1479,
      1,
      0,
      0,
      0,
      166,
      1487,
      1,
      0,
      0,
      0,
      168,
      1492,
      1,
      0,
      0,
      0,
      170,
      1505,
      1,
      0,
      0,
      0,
      172,
      1529,
      1,
      0,
      0,
      0,
      174,
      1535,
      1,
      0,
      0,
      0,
      176,
      1545,
      1,
      0,
      0,
      0,
      178,
      1547,
      1,
      0,
      0,
      0,
      180,
      1585,
      1,
      0,
      0,
      0,
      182,
      1587,
      1,
      0,
      0,
      0,
      184,
      1590,
      1,
      0,
      0,
      0,
      186,
      1603,
      1,
      0,
      0,
      0,
      188,
      1622,
      1,
      0,
      0,
      0,
      190,
      1644,
      1,
      0,
      0,
      0,
      192,
      1657,
      1,
      0,
      0,
      0,
      194,
      1672,
      1,
      0,
      0,
      0,
      196,
      1687,
      1,
      0,
      0,
      0,
      198,
      1696,
      1,
      0,
      0,
      0,
      200,
      1698,
      1,
      0,
      0,
      0,
      202,
      1703,
      1,
      0,
      0,
      0,
      204,
      1707,
      1,
      0,
      0,
      0,
      206,
      1712,
      1,
      0,
      0,
      0,
      208,
      1729,
      1,
      0,
      0,
      0,
      210,
      1732,
      1,
      0,
      0,
      0,
      212,
      1746,
      1,
      0,
      0,
      0,
      214,
      1756,
      1,
      0,
      0,
      0,
      216,
      1759,
      1,
      0,
      0,
      0,
      218,
      1797,
      1,
      0,
      0,
      0,
      220,
      1799,
      1,
      0,
      0,
      0,
      222,
      1816,
      1,
      0,
      0,
      0,
      224,
      1818,
      1,
      0,
      0,
      0,
      226,
      1840,
      1,
      0,
      0,
      0,
      228,
      1848,
      1,
      0,
      0,
      0,
      230,
      1850,
      1,
      0,
      0,
      0,
      232,
      1891,
      1,
      0,
      0,
      0,
      234,
      1893,
      1,
      0,
      0,
      0,
      236,
      1901,
      1,
      0,
      0,
      0,
      238,
      1924,
      1,
      0,
      0,
      0,
      240,
      1926,
      1,
      0,
      0,
      0,
      242,
      1963,
      1,
      0,
      0,
      0,
      244,
      1979,
      1,
      0,
      0,
      0,
      246,
      2087,
      1,
      0,
      0,
      0,
      248,
      2089,
      1,
      0,
      0,
      0,
      250,
      2102,
      1,
      0,
      0,
      0,
      252,
      2118,
      1,
      0,
      0,
      0,
      254,
      2127,
      1,
      0,
      0,
      0,
      256,
      2137,
      1,
      0,
      0,
      0,
      258,
      2139,
      1,
      0,
      0,
      0,
      260,
      2148,
      1,
      0,
      0,
      0,
      262,
      2150,
      1,
      0,
      0,
      0,
      264,
      2153,
      1,
      0,
      0,
      0,
      266,
      2157,
      1,
      0,
      0,
      0,
      268,
      2159,
      1,
      0,
      0,
      0,
      270,
      2168,
      1,
      0,
      0,
      0,
      272,
      274,
      3,
      4,
      2,
      0,
      273,
      272,
      1,
      0,
      0,
      0,
      273,
      274,
      1,
      0,
      0,
      0,
      274,
      283,
      1,
      0,
      0,
      0,
      275,
      284,
      3,
      10,
      5,
      0,
      276,
      284,
      3,
      12,
      6,
      0,
      277,
      284,
      3,
      18,
      9,
      0,
      278,
      284,
      3,
      24,
      12,
      0,
      279,
      284,
      3,
      34,
      17,
      0,
      280,
      284,
      3,
      46,
      23,
      0,
      281,
      284,
      3,
      48,
      24,
      0,
      282,
      284,
      3,
      52,
      26,
      0,
      283,
      275,
      1,
      0,
      0,
      0,
      283,
      276,
      1,
      0,
      0,
      0,
      283,
      277,
      1,
      0,
      0,
      0,
      283,
      278,
      1,
      0,
      0,
      0,
      283,
      279,
      1,
      0,
      0,
      0,
      283,
      280,
      1,
      0,
      0,
      0,
      283,
      281,
      1,
      0,
      0,
      0,
      283,
      282,
      1,
      0,
      0,
      0,
      284,
      293,
      1,
      0,
      0,
      0,
      285,
      286,
      5,
      1,
      0,
      0,
      286,
      292,
      3,
      10,
      5,
      0,
      287,
      292,
      3,
      12,
      6,
      0,
      288,
      292,
      3,
      18,
      9,
      0,
      289,
      292,
      3,
      46,
      23,
      0,
      290,
      292,
      3,
      52,
      26,
      0,
      291,
      285,
      1,
      0,
      0,
      0,
      291,
      287,
      1,
      0,
      0,
      0,
      291,
      288,
      1,
      0,
      0,
      0,
      291,
      289,
      1,
      0,
      0,
      0,
      291,
      290,
      1,
      0,
      0,
      0,
      292,
      295,
      1,
      0,
      0,
      0,
      293,
      291,
      1,
      0,
      0,
      0,
      293,
      294,
      1,
      0,
      0,
      0,
      294,
      296,
      1,
      0,
      0,
      0,
      295,
      293,
      1,
      0,
      0,
      0,
      296,
      297,
      5,
      143,
      0,
      0,
      297,
      299,
      1,
      0,
      0,
      0,
      298,
      273,
      1,
      0,
      0,
      0,
      299,
      302,
      1,
      0,
      0,
      0,
      300,
      298,
      1,
      0,
      0,
      0,
      300,
      301,
      1,
      0,
      0,
      0,
      301,
      303,
      1,
      0,
      0,
      0,
      302,
      300,
      1,
      0,
      0,
      0,
      303,
      304,
      5,
      0,
      0,
      1,
      304,
      1,
      1,
      0,
      0,
      0,
      305,
      306,
      5,
      1,
      0,
      0,
      306,
      308,
      3,
      10,
      5,
      0,
      307,
      305,
      1,
      0,
      0,
      0,
      308,
      311,
      1,
      0,
      0,
      0,
      309,
      307,
      1,
      0,
      0,
      0,
      309,
      310,
      1,
      0,
      0,
      0,
      310,
      312,
      1,
      0,
      0,
      0,
      311,
      309,
      1,
      0,
      0,
      0,
      312,
      357,
      5,
      1,
      0,
      0,
      313,
      314,
      5,
      1,
      0,
      0,
      314,
      316,
      3,
      10,
      5,
      0,
      315,
      313,
      1,
      0,
      0,
      0,
      316,
      319,
      1,
      0,
      0,
      0,
      317,
      315,
      1,
      0,
      0,
      0,
      317,
      318,
      1,
      0,
      0,
      0,
      318,
      320,
      1,
      0,
      0,
      0,
      319,
      317,
      1,
      0,
      0,
      0,
      320,
      339,
      5,
      143,
      0,
      0,
      321,
      323,
      3,
      4,
      2,
      0,
      322,
      321,
      1,
      0,
      0,
      0,
      322,
      323,
      1,
      0,
      0,
      0,
      323,
      326,
      1,
      0,
      0,
      0,
      324,
      327,
      3,
      10,
      5,
      0,
      325,
      327,
      3,
      34,
      17,
      0,
      326,
      324,
      1,
      0,
      0,
      0,
      326,
      325,
      1,
      0,
      0,
      0,
      327,
      332,
      1,
      0,
      0,
      0,
      328,
      329,
      5,
      1,
      0,
      0,
      329,
      331,
      3,
      10,
      5,
      0,
      330,
      328,
      1,
      0,
      0,
      0,
      331,
      334,
      1,
      0,
      0,
      0,
      332,
      330,
      1,
      0,
      0,
      0,
      332,
      333,
      1,
      0,
      0,
      0,
      333,
      335,
      1,
      0,
      0,
      0,
      334,
      332,
      1,
      0,
      0,
      0,
      335,
      336,
      5,
      143,
      0,
      0,
      336,
      338,
      1,
      0,
      0,
      0,
      337,
      322,
      1,
      0,
      0,
      0,
      338,
      341,
      1,
      0,
      0,
      0,
      339,
      337,
      1,
      0,
      0,
      0,
      339,
      340,
      1,
      0,
      0,
      0,
      340,
      343,
      1,
      0,
      0,
      0,
      341,
      339,
      1,
      0,
      0,
      0,
      342,
      344,
      3,
      4,
      2,
      0,
      343,
      342,
      1,
      0,
      0,
      0,
      343,
      344,
      1,
      0,
      0,
      0,
      344,
      347,
      1,
      0,
      0,
      0,
      345,
      348,
      3,
      10,
      5,
      0,
      346,
      348,
      3,
      34,
      17,
      0,
      347,
      345,
      1,
      0,
      0,
      0,
      347,
      346,
      1,
      0,
      0,
      0,
      348,
      353,
      1,
      0,
      0,
      0,
      349,
      350,
      5,
      1,
      0,
      0,
      350,
      352,
      3,
      10,
      5,
      0,
      351,
      349,
      1,
      0,
      0,
      0,
      352,
      355,
      1,
      0,
      0,
      0,
      353,
      351,
      1,
      0,
      0,
      0,
      353,
      354,
      1,
      0,
      0,
      0,
      354,
      357,
      1,
      0,
      0,
      0,
      355,
      353,
      1,
      0,
      0,
      0,
      356,
      309,
      1,
      0,
      0,
      0,
      356,
      317,
      1,
      0,
      0,
      0,
      357,
      3,
      1,
      0,
      0,
      0,
      358,
      363,
      3,
      6,
      3,
      0,
      359,
      360,
      3,
      8,
      4,
      0,
      360,
      361,
      5,
      1,
      0,
      0,
      361,
      363,
      1,
      0,
      0,
      0,
      362,
      358,
      1,
      0,
      0,
      0,
      362,
      359,
      1,
      0,
      0,
      0,
      363,
      5,
      1,
      0,
      0,
      0,
      364,
      365,
      5,
      22,
      0,
      0,
      365,
      7,
      1,
      0,
      0,
      0,
      366,
      369,
      3,
      266,
      133,
      0,
      367,
      369,
      3,
      268,
      134,
      0,
      368,
      366,
      1,
      0,
      0,
      0,
      368,
      367,
      1,
      0,
      0,
      0,
      369,
      9,
      1,
      0,
      0,
      0,
      370,
      440,
      3,
      56,
      28,
      0,
      371,
      440,
      3,
      58,
      29,
      0,
      372,
      440,
      3,
      64,
      32,
      0,
      373,
      440,
      3,
      72,
      36,
      0,
      374,
      440,
      3,
      74,
      37,
      0,
      375,
      440,
      3,
      76,
      38,
      0,
      376,
      440,
      3,
      78,
      39,
      0,
      377,
      440,
      3,
      80,
      40,
      0,
      378,
      440,
      3,
      86,
      43,
      0,
      379,
      440,
      3,
      90,
      45,
      0,
      380,
      440,
      3,
      92,
      46,
      0,
      381,
      440,
      3,
      96,
      48,
      0,
      382,
      440,
      3,
      104,
      52,
      0,
      383,
      440,
      3,
      68,
      34,
      0,
      384,
      440,
      3,
      70,
      35,
      0,
      385,
      440,
      3,
      108,
      54,
      0,
      386,
      440,
      3,
      110,
      55,
      0,
      387,
      440,
      3,
      112,
      56,
      0,
      388,
      440,
      3,
      116,
      58,
      0,
      389,
      440,
      3,
      118,
      59,
      0,
      390,
      440,
      3,
      120,
      60,
      0,
      391,
      440,
      3,
      122,
      61,
      0,
      392,
      440,
      3,
      124,
      62,
      0,
      393,
      440,
      3,
      128,
      64,
      0,
      394,
      440,
      3,
      132,
      66,
      0,
      395,
      440,
      3,
      134,
      67,
      0,
      396,
      440,
      3,
      136,
      68,
      0,
      397,
      440,
      3,
      138,
      69,
      0,
      398,
      440,
      3,
      142,
      71,
      0,
      399,
      440,
      3,
      144,
      72,
      0,
      400,
      440,
      3,
      146,
      73,
      0,
      401,
      440,
      3,
      148,
      74,
      0,
      402,
      440,
      3,
      150,
      75,
      0,
      403,
      440,
      3,
      152,
      76,
      0,
      404,
      440,
      3,
      154,
      77,
      0,
      405,
      440,
      3,
      156,
      78,
      0,
      406,
      440,
      3,
      158,
      79,
      0,
      407,
      440,
      3,
      160,
      80,
      0,
      408,
      440,
      3,
      162,
      81,
      0,
      409,
      440,
      3,
      166,
      83,
      0,
      410,
      440,
      3,
      170,
      85,
      0,
      411,
      440,
      3,
      168,
      84,
      0,
      412,
      440,
      3,
      178,
      89,
      0,
      413,
      440,
      3,
      180,
      90,
      0,
      414,
      440,
      3,
      182,
      91,
      0,
      415,
      440,
      3,
      184,
      92,
      0,
      416,
      440,
      3,
      186,
      93,
      0,
      417,
      440,
      3,
      188,
      94,
      0,
      418,
      440,
      3,
      190,
      95,
      0,
      419,
      440,
      3,
      192,
      96,
      0,
      420,
      440,
      3,
      194,
      97,
      0,
      421,
      440,
      3,
      196,
      98,
      0,
      422,
      440,
      3,
      198,
      99,
      0,
      423,
      440,
      3,
      200,
      100,
      0,
      424,
      440,
      3,
      202,
      101,
      0,
      425,
      440,
      3,
      204,
      102,
      0,
      426,
      440,
      3,
      218,
      109,
      0,
      427,
      440,
      3,
      224,
      112,
      0,
      428,
      440,
      3,
      226,
      113,
      0,
      429,
      440,
      3,
      206,
      103,
      0,
      430,
      440,
      3,
      228,
      114,
      0,
      431,
      440,
      3,
      230,
      115,
      0,
      432,
      440,
      3,
      232,
      116,
      0,
      433,
      440,
      3,
      234,
      117,
      0,
      434,
      440,
      3,
      236,
      118,
      0,
      435,
      440,
      3,
      238,
      119,
      0,
      436,
      440,
      3,
      240,
      120,
      0,
      437,
      440,
      3,
      242,
      121,
      0,
      438,
      440,
      1,
      0,
      0,
      0,
      439,
      370,
      1,
      0,
      0,
      0,
      439,
      371,
      1,
      0,
      0,
      0,
      439,
      372,
      1,
      0,
      0,
      0,
      439,
      373,
      1,
      0,
      0,
      0,
      439,
      374,
      1,
      0,
      0,
      0,
      439,
      375,
      1,
      0,
      0,
      0,
      439,
      376,
      1,
      0,
      0,
      0,
      439,
      377,
      1,
      0,
      0,
      0,
      439,
      378,
      1,
      0,
      0,
      0,
      439,
      379,
      1,
      0,
      0,
      0,
      439,
      380,
      1,
      0,
      0,
      0,
      439,
      381,
      1,
      0,
      0,
      0,
      439,
      382,
      1,
      0,
      0,
      0,
      439,
      383,
      1,
      0,
      0,
      0,
      439,
      384,
      1,
      0,
      0,
      0,
      439,
      385,
      1,
      0,
      0,
      0,
      439,
      386,
      1,
      0,
      0,
      0,
      439,
      387,
      1,
      0,
      0,
      0,
      439,
      388,
      1,
      0,
      0,
      0,
      439,
      389,
      1,
      0,
      0,
      0,
      439,
      390,
      1,
      0,
      0,
      0,
      439,
      391,
      1,
      0,
      0,
      0,
      439,
      392,
      1,
      0,
      0,
      0,
      439,
      393,
      1,
      0,
      0,
      0,
      439,
      394,
      1,
      0,
      0,
      0,
      439,
      395,
      1,
      0,
      0,
      0,
      439,
      396,
      1,
      0,
      0,
      0,
      439,
      397,
      1,
      0,
      0,
      0,
      439,
      398,
      1,
      0,
      0,
      0,
      439,
      399,
      1,
      0,
      0,
      0,
      439,
      400,
      1,
      0,
      0,
      0,
      439,
      401,
      1,
      0,
      0,
      0,
      439,
      402,
      1,
      0,
      0,
      0,
      439,
      403,
      1,
      0,
      0,
      0,
      439,
      404,
      1,
      0,
      0,
      0,
      439,
      405,
      1,
      0,
      0,
      0,
      439,
      406,
      1,
      0,
      0,
      0,
      439,
      407,
      1,
      0,
      0,
      0,
      439,
      408,
      1,
      0,
      0,
      0,
      439,
      409,
      1,
      0,
      0,
      0,
      439,
      410,
      1,
      0,
      0,
      0,
      439,
      411,
      1,
      0,
      0,
      0,
      439,
      412,
      1,
      0,
      0,
      0,
      439,
      413,
      1,
      0,
      0,
      0,
      439,
      414,
      1,
      0,
      0,
      0,
      439,
      415,
      1,
      0,
      0,
      0,
      439,
      416,
      1,
      0,
      0,
      0,
      439,
      417,
      1,
      0,
      0,
      0,
      439,
      418,
      1,
      0,
      0,
      0,
      439,
      419,
      1,
      0,
      0,
      0,
      439,
      420,
      1,
      0,
      0,
      0,
      439,
      421,
      1,
      0,
      0,
      0,
      439,
      422,
      1,
      0,
      0,
      0,
      439,
      423,
      1,
      0,
      0,
      0,
      439,
      424,
      1,
      0,
      0,
      0,
      439,
      425,
      1,
      0,
      0,
      0,
      439,
      426,
      1,
      0,
      0,
      0,
      439,
      427,
      1,
      0,
      0,
      0,
      439,
      428,
      1,
      0,
      0,
      0,
      439,
      429,
      1,
      0,
      0,
      0,
      439,
      430,
      1,
      0,
      0,
      0,
      439,
      431,
      1,
      0,
      0,
      0,
      439,
      432,
      1,
      0,
      0,
      0,
      439,
      433,
      1,
      0,
      0,
      0,
      439,
      434,
      1,
      0,
      0,
      0,
      439,
      435,
      1,
      0,
      0,
      0,
      439,
      436,
      1,
      0,
      0,
      0,
      439,
      437,
      1,
      0,
      0,
      0,
      439,
      438,
      1,
      0,
      0,
      0,
      440,
      11,
      1,
      0,
      0,
      0,
      441,
      446,
      5,
      46,
      0,
      0,
      442,
      443,
      5,
      125,
      0,
      0,
      443,
      447,
      3,
      266,
      133,
      0,
      444,
      445,
      5,
      65,
      0,
      0,
      445,
      447,
      5,
      141,
      0,
      0,
      446,
      442,
      1,
      0,
      0,
      0,
      446,
      444,
      1,
      0,
      0,
      0,
      447,
      453,
      1,
      0,
      0,
      0,
      448,
      450,
      5,
      2,
      0,
      0,
      449,
      451,
      3,
      14,
      7,
      0,
      450,
      449,
      1,
      0,
      0,
      0,
      450,
      451,
      1,
      0,
      0,
      0,
      451,
      452,
      1,
      0,
      0,
      0,
      452,
      454,
      5,
      3,
      0,
      0,
      453,
      448,
      1,
      0,
      0,
      0,
      453,
      454,
      1,
      0,
      0,
      0,
      454,
      13,
      1,
      0,
      0,
      0,
      455,
      460,
      3,
      16,
      8,
      0,
      456,
      457,
      5,
      11,
      0,
      0,
      457,
      459,
      3,
      16,
      8,
      0,
      458,
      456,
      1,
      0,
      0,
      0,
      459,
      462,
      1,
      0,
      0,
      0,
      460,
      458,
      1,
      0,
      0,
      0,
      460,
      461,
      1,
      0,
      0,
      0,
      461,
      15,
      1,
      0,
      0,
      0,
      462,
      460,
      1,
      0,
      0,
      0,
      463,
      465,
      3,
      266,
      133,
      0,
      464,
      466,
      3,
      30,
      15,
      0,
      465,
      464,
      1,
      0,
      0,
      0,
      465,
      466,
      1,
      0,
      0,
      0,
      466,
      467,
      1,
      0,
      0,
      0,
      467,
      468,
      5,
      33,
      0,
      0,
      468,
      469,
      3,
      256,
      128,
      0,
      469,
      475,
      1,
      0,
      0,
      0,
      470,
      472,
      5,
      141,
      0,
      0,
      471,
      473,
      3,
      30,
      15,
      0,
      472,
      471,
      1,
      0,
      0,
      0,
      472,
      473,
      1,
      0,
      0,
      0,
      473,
      475,
      1,
      0,
      0,
      0,
      474,
      463,
      1,
      0,
      0,
      0,
      474,
      470,
      1,
      0,
      0,
      0,
      475,
      17,
      1,
      0,
      0,
      0,
      476,
      480,
      5,
      47,
      0,
      0,
      477,
      481,
      5,
      140,
      0,
      0,
      478,
      479,
      5,
      64,
      0,
      0,
      479,
      481,
      5,
      141,
      0,
      0,
      480,
      477,
      1,
      0,
      0,
      0,
      480,
      478,
      1,
      0,
      0,
      0,
      481,
      487,
      1,
      0,
      0,
      0,
      482,
      484,
      5,
      2,
      0,
      0,
      483,
      485,
      3,
      20,
      10,
      0,
      484,
      483,
      1,
      0,
      0,
      0,
      484,
      485,
      1,
      0,
      0,
      0,
      485,
      486,
      1,
      0,
      0,
      0,
      486,
      488,
      5,
      3,
      0,
      0,
      487,
      482,
      1,
      0,
      0,
      0,
      487,
      488,
      1,
      0,
      0,
      0,
      488,
      495,
      1,
      0,
      0,
      0,
      489,
      490,
      5,
      16,
      0,
      0,
      490,
      496,
      3,
      244,
      122,
      0,
      491,
      492,
      3,
      2,
      1,
      0,
      492,
      493,
      5,
      60,
      0,
      0,
      493,
      494,
      5,
      47,
      0,
      0,
      494,
      496,
      1,
      0,
      0,
      0,
      495,
      489,
      1,
      0,
      0,
      0,
      495,
      491,
      1,
      0,
      0,
      0,
      496,
      19,
      1,
      0,
      0,
      0,
      497,
      502,
      3,
      22,
      11,
      0,
      498,
      499,
      5,
      11,
      0,
      0,
      499,
      501,
      3,
      22,
      11,
      0,
      500,
      498,
      1,
      0,
      0,
      0,
      501,
      504,
      1,
      0,
      0,
      0,
      502,
      500,
      1,
      0,
      0,
      0,
      502,
      503,
      1,
      0,
      0,
      0,
      503,
      21,
      1,
      0,
      0,
      0,
      504,
      502,
      1,
      0,
      0,
      0,
      505,
      506,
      3,
      266,
      133,
      0,
      506,
      507,
      5,
      33,
      0,
      0,
      507,
      508,
      3,
      258,
      129,
      0,
      508,
      511,
      1,
      0,
      0,
      0,
      509,
      511,
      5,
      141,
      0,
      0,
      510,
      505,
      1,
      0,
      0,
      0,
      510,
      509,
      1,
      0,
      0,
      0,
      511,
      23,
      1,
      0,
      0,
      0,
      512,
      513,
      5,
      65,
      0,
      0,
      513,
      519,
      5,
      141,
      0,
      0,
      514,
      516,
      5,
      2,
      0,
      0,
      515,
      517,
      3,
      26,
      13,
      0,
      516,
      515,
      1,
      0,
      0,
      0,
      516,
      517,
      1,
      0,
      0,
      0,
      517,
      518,
      1,
      0,
      0,
      0,
      518,
      520,
      5,
      3,
      0,
      0,
      519,
      514,
      1,
      0,
      0,
      0,
      519,
      520,
      1,
      0,
      0,
      0,
      520,
      522,
      1,
      0,
      0,
      0,
      521,
      523,
      5,
      120,
      0,
      0,
      522,
      521,
      1,
      0,
      0,
      0,
      522,
      523,
      1,
      0,
      0,
      0,
      523,
      524,
      1,
      0,
      0,
      0,
      524,
      525,
      3,
      2,
      1,
      0,
      525,
      526,
      3,
      32,
      16,
      0,
      526,
      25,
      1,
      0,
      0,
      0,
      527,
      532,
      3,
      28,
      14,
      0,
      528,
      529,
      5,
      11,
      0,
      0,
      529,
      531,
      3,
      28,
      14,
      0,
      530,
      528,
      1,
      0,
      0,
      0,
      531,
      534,
      1,
      0,
      0,
      0,
      532,
      530,
      1,
      0,
      0,
      0,
      532,
      533,
      1,
      0,
      0,
      0,
      533,
      27,
      1,
      0,
      0,
      0,
      534,
      532,
      1,
      0,
      0,
      0,
      535,
      537,
      3,
      266,
      133,
      0,
      536,
      538,
      3,
      30,
      15,
      0,
      537,
      536,
      1,
      0,
      0,
      0,
      537,
      538,
      1,
      0,
      0,
      0,
      538,
      539,
      1,
      0,
      0,
      0,
      539,
      540,
      5,
      33,
      0,
      0,
      540,
      541,
      3,
      254,
      127,
      0,
      541,
      547,
      1,
      0,
      0,
      0,
      542,
      544,
      5,
      141,
      0,
      0,
      543,
      545,
      3,
      30,
      15,
      0,
      544,
      543,
      1,
      0,
      0,
      0,
      544,
      545,
      1,
      0,
      0,
      0,
      545,
      547,
      1,
      0,
      0,
      0,
      546,
      535,
      1,
      0,
      0,
      0,
      546,
      542,
      1,
      0,
      0,
      0,
      547,
      29,
      1,
      0,
      0,
      0,
      548,
      550,
      5,
      2,
      0,
      0,
      549,
      551,
      5,
      22,
      0,
      0,
      550,
      549,
      1,
      0,
      0,
      0,
      550,
      551,
      1,
      0,
      0,
      0,
      551,
      552,
      1,
      0,
      0,
      0,
      552,
      553,
      5,
      3,
      0,
      0,
      553,
      31,
      1,
      0,
      0,
      0,
      554,
      556,
      3,
      4,
      2,
      0,
      555,
      554,
      1,
      0,
      0,
      0,
      555,
      556,
      1,
      0,
      0,
      0,
      556,
      557,
      1,
      0,
      0,
      0,
      557,
      558,
      5,
      60,
      0,
      0,
      558,
      563,
      5,
      65,
      0,
      0,
      559,
      560,
      5,
      1,
      0,
      0,
      560,
      562,
      3,
      10,
      5,
      0,
      561,
      559,
      1,
      0,
      0,
      0,
      562,
      565,
      1,
      0,
      0,
      0,
      563,
      561,
      1,
      0,
      0,
      0,
      563,
      564,
      1,
      0,
      0,
      0,
      564,
      33,
      1,
      0,
      0,
      0,
      565,
      563,
      1,
      0,
      0,
      0,
      566,
      567,
      5,
      69,
      0,
      0,
      567,
      568,
      3,
      244,
      122,
      0,
      568,
      569,
      5,
      126,
      0,
      0,
      569,
      570,
      5,
      143,
      0,
      0,
      570,
      574,
      3,
      42,
      21,
      0,
      571,
      573,
      3,
      36,
      18,
      0,
      572,
      571,
      1,
      0,
      0,
      0,
      573,
      576,
      1,
      0,
      0,
      0,
      574,
      572,
      1,
      0,
      0,
      0,
      574,
      575,
      1,
      0,
      0,
      0,
      575,
      578,
      1,
      0,
      0,
      0,
      576,
      574,
      1,
      0,
      0,
      0,
      577,
      579,
      3,
      38,
      19,
      0,
      578,
      577,
      1,
      0,
      0,
      0,
      578,
      579,
      1,
      0,
      0,
      0,
      579,
      580,
      1,
      0,
      0,
      0,
      580,
      581,
      3,
      40,
      20,
      0,
      581,
      35,
      1,
      0,
      0,
      0,
      582,
      584,
      3,
      4,
      2,
      0,
      583,
      582,
      1,
      0,
      0,
      0,
      583,
      584,
      1,
      0,
      0,
      0,
      584,
      585,
      1,
      0,
      0,
      0,
      585,
      586,
      5,
      57,
      0,
      0,
      586,
      587,
      3,
      244,
      122,
      0,
      587,
      588,
      5,
      126,
      0,
      0,
      588,
      589,
      3,
      44,
      22,
      0,
      589,
      37,
      1,
      0,
      0,
      0,
      590,
      592,
      3,
      4,
      2,
      0,
      591,
      590,
      1,
      0,
      0,
      0,
      591,
      592,
      1,
      0,
      0,
      0,
      592,
      593,
      1,
      0,
      0,
      0,
      593,
      594,
      5,
      56,
      0,
      0,
      594,
      595,
      3,
      44,
      22,
      0,
      595,
      39,
      1,
      0,
      0,
      0,
      596,
      598,
      3,
      4,
      2,
      0,
      597,
      596,
      1,
      0,
      0,
      0,
      597,
      598,
      1,
      0,
      0,
      0,
      598,
      599,
      1,
      0,
      0,
      0,
      599,
      600,
      5,
      60,
      0,
      0,
      600,
      601,
      5,
      69,
      0,
      0,
      601,
      41,
      1,
      0,
      0,
      0,
      602,
      604,
      3,
      4,
      2,
      0,
      603,
      602,
      1,
      0,
      0,
      0,
      603,
      604,
      1,
      0,
      0,
      0,
      604,
      607,
      1,
      0,
      0,
      0,
      605,
      608,
      3,
      10,
      5,
      0,
      606,
      608,
      3,
      34,
      17,
      0,
      607,
      605,
      1,
      0,
      0,
      0,
      607,
      606,
      1,
      0,
      0,
      0,
      608,
      613,
      1,
      0,
      0,
      0,
      609,
      610,
      5,
      1,
      0,
      0,
      610,
      612,
      3,
      10,
      5,
      0,
      611,
      609,
      1,
      0,
      0,
      0,
      612,
      615,
      1,
      0,
      0,
      0,
      613,
      611,
      1,
      0,
      0,
      0,
      613,
      614,
      1,
      0,
      0,
      0,
      614,
      616,
      1,
      0,
      0,
      0,
      615,
      613,
      1,
      0,
      0,
      0,
      616,
      617,
      5,
      143,
      0,
      0,
      617,
      619,
      1,
      0,
      0,
      0,
      618,
      603,
      1,
      0,
      0,
      0,
      619,
      622,
      1,
      0,
      0,
      0,
      620,
      618,
      1,
      0,
      0,
      0,
      620,
      621,
      1,
      0,
      0,
      0,
      621,
      43,
      1,
      0,
      0,
      0,
      622,
      620,
      1,
      0,
      0,
      0,
      623,
      628,
      3,
      10,
      5,
      0,
      624,
      625,
      5,
      1,
      0,
      0,
      625,
      627,
      3,
      10,
      5,
      0,
      626,
      624,
      1,
      0,
      0,
      0,
      627,
      630,
      1,
      0,
      0,
      0,
      628,
      626,
      1,
      0,
      0,
      0,
      628,
      629,
      1,
      0,
      0,
      0,
      629,
      631,
      1,
      0,
      0,
      0,
      630,
      628,
      1,
      0,
      0,
      0,
      631,
      650,
      5,
      143,
      0,
      0,
      632,
      634,
      3,
      4,
      2,
      0,
      633,
      632,
      1,
      0,
      0,
      0,
      633,
      634,
      1,
      0,
      0,
      0,
      634,
      637,
      1,
      0,
      0,
      0,
      635,
      638,
      3,
      10,
      5,
      0,
      636,
      638,
      3,
      34,
      17,
      0,
      637,
      635,
      1,
      0,
      0,
      0,
      637,
      636,
      1,
      0,
      0,
      0,
      638,
      643,
      1,
      0,
      0,
      0,
      639,
      640,
      5,
      1,
      0,
      0,
      640,
      642,
      3,
      10,
      5,
      0,
      641,
      639,
      1,
      0,
      0,
      0,
      642,
      645,
      1,
      0,
      0,
      0,
      643,
      641,
      1,
      0,
      0,
      0,
      643,
      644,
      1,
      0,
      0,
      0,
      644,
      646,
      1,
      0,
      0,
      0,
      645,
      643,
      1,
      0,
      0,
      0,
      646,
      647,
      5,
      143,
      0,
      0,
      647,
      649,
      1,
      0,
      0,
      0,
      648,
      633,
      1,
      0,
      0,
      0,
      649,
      652,
      1,
      0,
      0,
      0,
      650,
      648,
      1,
      0,
      0,
      0,
      650,
      651,
      1,
      0,
      0,
      0,
      651,
      45,
      1,
      0,
      0,
      0,
      652,
      650,
      1,
      0,
      0,
      0,
      653,
      654,
      5,
      93,
      0,
      0,
      654,
      655,
      5,
      34,
      0,
      0,
      655,
      656,
      5,
      22,
      0,
      0,
      656,
      47,
      1,
      0,
      0,
      0,
      657,
      658,
      5,
      125,
      0,
      0,
      658,
      664,
      3,
      266,
      133,
      0,
      659,
      661,
      5,
      2,
      0,
      0,
      660,
      662,
      3,
      26,
      13,
      0,
      661,
      660,
      1,
      0,
      0,
      0,
      661,
      662,
      1,
      0,
      0,
      0,
      662,
      663,
      1,
      0,
      0,
      0,
      663,
      665,
      5,
      3,
      0,
      0,
      664,
      659,
      1,
      0,
      0,
      0,
      664,
      665,
      1,
      0,
      0,
      0,
      665,
      667,
      1,
      0,
      0,
      0,
      666,
      668,
      5,
      120,
      0,
      0,
      667,
      666,
      1,
      0,
      0,
      0,
      667,
      668,
      1,
      0,
      0,
      0,
      668,
      669,
      1,
      0,
      0,
      0,
      669,
      670,
      3,
      2,
      1,
      0,
      670,
      671,
      3,
      50,
      25,
      0,
      671,
      49,
      1,
      0,
      0,
      0,
      672,
      674,
      3,
      4,
      2,
      0,
      673,
      672,
      1,
      0,
      0,
      0,
      673,
      674,
      1,
      0,
      0,
      0,
      674,
      675,
      1,
      0,
      0,
      0,
      675,
      676,
      5,
      60,
      0,
      0,
      676,
      681,
      5,
      125,
      0,
      0,
      677,
      678,
      5,
      1,
      0,
      0,
      678,
      680,
      3,
      10,
      5,
      0,
      679,
      677,
      1,
      0,
      0,
      0,
      680,
      683,
      1,
      0,
      0,
      0,
      681,
      679,
      1,
      0,
      0,
      0,
      681,
      682,
      1,
      0,
      0,
      0,
      682,
      51,
      1,
      0,
      0,
      0,
      683,
      681,
      1,
      0,
      0,
      0,
      684,
      687,
      5,
      128,
      0,
      0,
      685,
      688,
      3,
      266,
      133,
      0,
      686,
      688,
      3,
      268,
      134,
      0,
      687,
      685,
      1,
      0,
      0,
      0,
      687,
      686,
      1,
      0,
      0,
      0,
      688,
      690,
      1,
      0,
      0,
      0,
      689,
      691,
      7,
      0,
      0,
      0,
      690,
      689,
      1,
      0,
      0,
      0,
      691,
      692,
      1,
      0,
      0,
      0,
      692,
      690,
      1,
      0,
      0,
      0,
      692,
      693,
      1,
      0,
      0,
      0,
      693,
      698,
      1,
      0,
      0,
      0,
      694,
      695,
      3,
      198,
      99,
      0,
      695,
      696,
      5,
      143,
      0,
      0,
      696,
      699,
      1,
      0,
      0,
      0,
      697,
      699,
      3,
      54,
      27,
      0,
      698,
      694,
      1,
      0,
      0,
      0,
      698,
      697,
      1,
      0,
      0,
      0,
      699,
      700,
      1,
      0,
      0,
      0,
      700,
      698,
      1,
      0,
      0,
      0,
      700,
      701,
      1,
      0,
      0,
      0,
      701,
      702,
      1,
      0,
      0,
      0,
      702,
      703,
      5,
      60,
      0,
      0,
      703,
      704,
      5,
      128,
      0,
      0,
      704,
      53,
      1,
      0,
      0,
      0,
      705,
      708,
      3,
      266,
      133,
      0,
      706,
      708,
      3,
      268,
      134,
      0,
      707,
      705,
      1,
      0,
      0,
      0,
      707,
      706,
      1,
      0,
      0,
      0,
      708,
      709,
      1,
      0,
      0,
      0,
      709,
      710,
      5,
      33,
      0,
      0,
      710,
      712,
      3,
      260,
      130,
      0,
      711,
      713,
      7,
      0,
      0,
      0,
      712,
      711,
      1,
      0,
      0,
      0,
      713,
      714,
      1,
      0,
      0,
      0,
      714,
      712,
      1,
      0,
      0,
      0,
      714,
      715,
      1,
      0,
      0,
      0,
      715,
      55,
      1,
      0,
      0,
      0,
      716,
      718,
      5,
      79,
      0,
      0,
      717,
      716,
      1,
      0,
      0,
      0,
      717,
      718,
      1,
      0,
      0,
      0,
      718,
      719,
      1,
      0,
      0,
      0,
      719,
      720,
      3,
      250,
      125,
      0,
      720,
      721,
      5,
      16,
      0,
      0,
      721,
      722,
      3,
      244,
      122,
      0,
      722,
      57,
      1,
      0,
      0,
      0,
      723,
      724,
      5,
      36,
      0,
      0,
      724,
      729,
      3,
      266,
      133,
      0,
      725,
      726,
      5,
      2,
      0,
      0,
      726,
      727,
      3,
      60,
      30,
      0,
      727,
      728,
      5,
      3,
      0,
      0,
      728,
      730,
      1,
      0,
      0,
      0,
      729,
      725,
      1,
      0,
      0,
      0,
      729,
      730,
      1,
      0,
      0,
      0,
      730,
      736,
      1,
      0,
      0,
      0,
      731,
      733,
      3,
      266,
      133,
      0,
      732,
      734,
      3,
      60,
      30,
      0,
      733,
      732,
      1,
      0,
      0,
      0,
      733,
      734,
      1,
      0,
      0,
      0,
      734,
      736,
      1,
      0,
      0,
      0,
      735,
      723,
      1,
      0,
      0,
      0,
      735,
      731,
      1,
      0,
      0,
      0,
      736,
      59,
      1,
      0,
      0,
      0,
      737,
      742,
      3,
      62,
      31,
      0,
      738,
      739,
      5,
      11,
      0,
      0,
      739,
      741,
      3,
      62,
      31,
      0,
      740,
      738,
      1,
      0,
      0,
      0,
      741,
      744,
      1,
      0,
      0,
      0,
      742,
      740,
      1,
      0,
      0,
      0,
      742,
      743,
      1,
      0,
      0,
      0,
      743,
      61,
      1,
      0,
      0,
      0,
      744,
      742,
      1,
      0,
      0,
      0,
      745,
      746,
      5,
      141,
      0,
      0,
      746,
      747,
      5,
      2,
      0,
      0,
      747,
      754,
      5,
      3,
      0,
      0,
      748,
      750,
      5,
      141,
      0,
      0,
      749,
      751,
      3,
      248,
      124,
      0,
      750,
      749,
      1,
      0,
      0,
      0,
      750,
      751,
      1,
      0,
      0,
      0,
      751,
      754,
      1,
      0,
      0,
      0,
      752,
      754,
      3,
      244,
      122,
      0,
      753,
      745,
      1,
      0,
      0,
      0,
      753,
      748,
      1,
      0,
      0,
      0,
      753,
      752,
      1,
      0,
      0,
      0,
      754,
      63,
      1,
      0,
      0,
      0,
      755,
      756,
      5,
      36,
      0,
      0,
      756,
      757,
      5,
      28,
      0,
      0,
      757,
      761,
      5,
      2,
      0,
      0,
      758,
      759,
      3,
      66,
      33,
      0,
      759,
      760,
      5,
      11,
      0,
      0,
      760,
      762,
      1,
      0,
      0,
      0,
      761,
      758,
      1,
      0,
      0,
      0,
      761,
      762,
      1,
      0,
      0,
      0,
      762,
      763,
      1,
      0,
      0,
      0,
      763,
      764,
      3,
      244,
      122,
      0,
      764,
      765,
      5,
      3,
      0,
      0,
      765,
      65,
      1,
      0,
      0,
      0,
      766,
      771,
      3,
      244,
      122,
      0,
      767,
      768,
      5,
      11,
      0,
      0,
      768,
      770,
      3,
      244,
      122,
      0,
      769,
      767,
      1,
      0,
      0,
      0,
      770,
      773,
      1,
      0,
      0,
      0,
      771,
      769,
      1,
      0,
      0,
      0,
      771,
      772,
      1,
      0,
      0,
      0,
      772,
      67,
      1,
      0,
      0,
      0,
      773,
      771,
      1,
      0,
      0,
      0,
      774,
      775,
      5,
      59,
      0,
      0,
      775,
      776,
      3,
      244,
      122,
      0,
      776,
      69,
      1,
      0,
      0,
      0,
      777,
      778,
      5,
      42,
      0,
      0,
      778,
      779,
      5,
      2,
      0,
      0,
      779,
      780,
      3,
      244,
      122,
      0,
      780,
      781,
      5,
      3,
      0,
      0,
      781,
      782,
      7,
      1,
      0,
      0,
      782,
      802,
      1,
      0,
      0,
      0,
      783,
      784,
      5,
      77,
      0,
      0,
      784,
      785,
      5,
      2,
      0,
      0,
      785,
      786,
      3,
      244,
      122,
      0,
      786,
      787,
      5,
      3,
      0,
      0,
      787,
      788,
      7,
      1,
      0,
      0,
      788,
      802,
      1,
      0,
      0,
      0,
      789,
      790,
      5,
      101,
      0,
      0,
      790,
      802,
      7,
      1,
      0,
      0,
      791,
      792,
      5,
      102,
      0,
      0,
      792,
      802,
      7,
      1,
      0,
      0,
      793,
      794,
      5,
      123,
      0,
      0,
      794,
      795,
      5,
      2,
      0,
      0,
      795,
      796,
      3,
      244,
      122,
      0,
      796,
      797,
      5,
      3,
      0,
      0,
      797,
      798,
      7,
      1,
      0,
      0,
      798,
      802,
      1,
      0,
      0,
      0,
      799,
      800,
      5,
      129,
      0,
      0,
      800,
      802,
      7,
      1,
      0,
      0,
      801,
      777,
      1,
      0,
      0,
      0,
      801,
      783,
      1,
      0,
      0,
      0,
      801,
      789,
      1,
      0,
      0,
      0,
      801,
      791,
      1,
      0,
      0,
      0,
      801,
      793,
      1,
      0,
      0,
      0,
      801,
      799,
      1,
      0,
      0,
      0,
      802,
      71,
      1,
      0,
      0,
      0,
      803,
      805,
      5,
      38,
      0,
      0,
      804,
      806,
      5,
      121,
      0,
      0,
      805,
      804,
      1,
      0,
      0,
      0,
      805,
      806,
      1,
      0,
      0,
      0,
      806,
      807,
      1,
      0,
      0,
      0,
      807,
      808,
      5,
      2,
      0,
      0,
      808,
      809,
      3,
      244,
      122,
      0,
      809,
      810,
      5,
      11,
      0,
      0,
      810,
      811,
      3,
      244,
      122,
      0,
      811,
      812,
      5,
      3,
      0,
      0,
      812,
      813,
      5,
      11,
      0,
      0,
      813,
      848,
      3,
      244,
      122,
      0,
      814,
      816,
      5,
      11,
      0,
      0,
      815,
      817,
      3,
      244,
      122,
      0,
      816,
      815,
      1,
      0,
      0,
      0,
      816,
      817,
      1,
      0,
      0,
      0,
      817,
      818,
      1,
      0,
      0,
      0,
      818,
      820,
      5,
      11,
      0,
      0,
      819,
      821,
      3,
      244,
      122,
      0,
      820,
      819,
      1,
      0,
      0,
      0,
      820,
      821,
      1,
      0,
      0,
      0,
      821,
      822,
      1,
      0,
      0,
      0,
      822,
      824,
      5,
      11,
      0,
      0,
      823,
      825,
      3,
      244,
      122,
      0,
      824,
      823,
      1,
      0,
      0,
      0,
      824,
      825,
      1,
      0,
      0,
      0,
      825,
      826,
      1,
      0,
      0,
      0,
      826,
      827,
      5,
      11,
      0,
      0,
      827,
      849,
      3,
      244,
      122,
      0,
      828,
      830,
      5,
      11,
      0,
      0,
      829,
      831,
      3,
      244,
      122,
      0,
      830,
      829,
      1,
      0,
      0,
      0,
      830,
      831,
      1,
      0,
      0,
      0,
      831,
      832,
      1,
      0,
      0,
      0,
      832,
      834,
      5,
      11,
      0,
      0,
      833,
      835,
      3,
      244,
      122,
      0,
      834,
      833,
      1,
      0,
      0,
      0,
      834,
      835,
      1,
      0,
      0,
      0,
      835,
      836,
      1,
      0,
      0,
      0,
      836,
      837,
      5,
      11,
      0,
      0,
      837,
      849,
      3,
      244,
      122,
      0,
      838,
      840,
      5,
      11,
      0,
      0,
      839,
      841,
      3,
      244,
      122,
      0,
      840,
      839,
      1,
      0,
      0,
      0,
      840,
      841,
      1,
      0,
      0,
      0,
      841,
      842,
      1,
      0,
      0,
      0,
      842,
      843,
      5,
      11,
      0,
      0,
      843,
      849,
      3,
      244,
      122,
      0,
      844,
      846,
      5,
      11,
      0,
      0,
      845,
      847,
      3,
      244,
      122,
      0,
      846,
      845,
      1,
      0,
      0,
      0,
      846,
      847,
      1,
      0,
      0,
      0,
      847,
      849,
      1,
      0,
      0,
      0,
      848,
      814,
      1,
      0,
      0,
      0,
      848,
      828,
      1,
      0,
      0,
      0,
      848,
      838,
      1,
      0,
      0,
      0,
      848,
      844,
      1,
      0,
      0,
      0,
      848,
      849,
      1,
      0,
      0,
      0,
      849,
      73,
      1,
      0,
      0,
      0,
      850,
      852,
      5,
      39,
      0,
      0,
      851,
      853,
      3,
      244,
      122,
      0,
      852,
      851,
      1,
      0,
      0,
      0,
      852,
      853,
      1,
      0,
      0,
      0,
      853,
      871,
      1,
      0,
      0,
      0,
      854,
      856,
      5,
      39,
      0,
      0,
      855,
      857,
      3,
      244,
      122,
      0,
      856,
      855,
      1,
      0,
      0,
      0,
      856,
      857,
      1,
      0,
      0,
      0,
      857,
      858,
      1,
      0,
      0,
      0,
      858,
      859,
      5,
      11,
      0,
      0,
      859,
      871,
      3,
      244,
      122,
      0,
      860,
      862,
      5,
      39,
      0,
      0,
      861,
      863,
      3,
      244,
      122,
      0,
      862,
      861,
      1,
      0,
      0,
      0,
      862,
      863,
      1,
      0,
      0,
      0,
      863,
      864,
      1,
      0,
      0,
      0,
      864,
      866,
      5,
      11,
      0,
      0,
      865,
      867,
      3,
      244,
      122,
      0,
      866,
      865,
      1,
      0,
      0,
      0,
      866,
      867,
      1,
      0,
      0,
      0,
      867,
      868,
      1,
      0,
      0,
      0,
      868,
      869,
      5,
      11,
      0,
      0,
      869,
      871,
      3,
      244,
      122,
      0,
      870,
      850,
      1,
      0,
      0,
      0,
      870,
      854,
      1,
      0,
      0,
      0,
      870,
      860,
      1,
      0,
      0,
      0,
      871,
      75,
      1,
      0,
      0,
      0,
      872,
      877,
      5,
      40,
      0,
      0,
      873,
      875,
      5,
      4,
      0,
      0,
      874,
      873,
      1,
      0,
      0,
      0,
      874,
      875,
      1,
      0,
      0,
      0,
      875,
      876,
      1,
      0,
      0,
      0,
      876,
      878,
      3,
      244,
      122,
      0,
      877,
      874,
      1,
      0,
      0,
      0,
      877,
      878,
      1,
      0,
      0,
      0,
      878,
      886,
      1,
      0,
      0,
      0,
      879,
      881,
      5,
      11,
      0,
      0,
      880,
      882,
      5,
      4,
      0,
      0,
      881,
      880,
      1,
      0,
      0,
      0,
      881,
      882,
      1,
      0,
      0,
      0,
      882,
      883,
      1,
      0,
      0,
      0,
      883,
      885,
      3,
      244,
      122,
      0,
      884,
      879,
      1,
      0,
      0,
      0,
      885,
      888,
      1,
      0,
      0,
      0,
      886,
      884,
      1,
      0,
      0,
      0,
      886,
      887,
      1,
      0,
      0,
      0,
      887,
      77,
      1,
      0,
      0,
      0,
      888,
      886,
      1,
      0,
      0,
      0,
      889,
      907,
      5,
      41,
      0,
      0,
      890,
      892,
      3,
      244,
      122,
      0,
      891,
      890,
      1,
      0,
      0,
      0,
      891,
      892,
      1,
      0,
      0,
      0,
      892,
      893,
      1,
      0,
      0,
      0,
      893,
      895,
      5,
      11,
      0,
      0,
      894,
      896,
      3,
      244,
      122,
      0,
      895,
      894,
      1,
      0,
      0,
      0,
      895,
      896,
      1,
      0,
      0,
      0,
      896,
      897,
      1,
      0,
      0,
      0,
      897,
      898,
      5,
      11,
      0,
      0,
      898,
      908,
      3,
      244,
      122,
      0,
      899,
      901,
      3,
      244,
      122,
      0,
      900,
      899,
      1,
      0,
      0,
      0,
      900,
      901,
      1,
      0,
      0,
      0,
      901,
      902,
      1,
      0,
      0,
      0,
      902,
      903,
      5,
      11,
      0,
      0,
      903,
      908,
      3,
      244,
      122,
      0,
      904,
      906,
      3,
      244,
      122,
      0,
      905,
      904,
      1,
      0,
      0,
      0,
      905,
      906,
      1,
      0,
      0,
      0,
      906,
      908,
      1,
      0,
      0,
      0,
      907,
      891,
      1,
      0,
      0,
      0,
      907,
      900,
      1,
      0,
      0,
      0,
      907,
      905,
      1,
      0,
      0,
      0,
      908,
      79,
      1,
      0,
      0,
      0,
      909,
      910,
      5,
      44,
      0,
      0,
      910,
      915,
      3,
      82,
      41,
      0,
      911,
      912,
      5,
      11,
      0,
      0,
      912,
      914,
      3,
      82,
      41,
      0,
      913,
      911,
      1,
      0,
      0,
      0,
      914,
      917,
      1,
      0,
      0,
      0,
      915,
      913,
      1,
      0,
      0,
      0,
      915,
      916,
      1,
      0,
      0,
      0,
      916,
      81,
      1,
      0,
      0,
      0,
      917,
      915,
      1,
      0,
      0,
      0,
      918,
      919,
      5,
      141,
      0,
      0,
      919,
      920,
      5,
      16,
      0,
      0,
      920,
      921,
      3,
      84,
      42,
      0,
      921,
      83,
      1,
      0,
      0,
      0,
      922,
      923,
      3,
      244,
      122,
      0,
      923,
      85,
      1,
      0,
      0,
      0,
      924,
      925,
      5,
      45,
      0,
      0,
      925,
      930,
      3,
      88,
      44,
      0,
      926,
      927,
      5,
      151,
      0,
      0,
      927,
      929,
      3,
      88,
      44,
      0,
      928,
      926,
      1,
      0,
      0,
      0,
      929,
      932,
      1,
      0,
      0,
      0,
      930,
      928,
      1,
      0,
      0,
      0,
      930,
      931,
      1,
      0,
      0,
      0,
      931,
      87,
      1,
      0,
      0,
      0,
      932,
      930,
      1,
      0,
      0,
      0,
      933,
      937,
      5,
      152,
      0,
      0,
      934,
      937,
      5,
      153,
      0,
      0,
      935,
      937,
      1,
      0,
      0,
      0,
      936,
      933,
      1,
      0,
      0,
      0,
      936,
      934,
      1,
      0,
      0,
      0,
      936,
      935,
      1,
      0,
      0,
      0,
      937,
      89,
      1,
      0,
      0,
      0,
      938,
      939,
      5,
      47,
      0,
      0,
      939,
      942,
      5,
      116,
      0,
      0,
      940,
      941,
      5,
      16,
      0,
      0,
      941,
      943,
      3,
      244,
      122,
      0,
      942,
      940,
      1,
      0,
      0,
      0,
      942,
      943,
      1,
      0,
      0,
      0,
      943,
      91,
      1,
      0,
      0,
      0,
      944,
      945,
      5,
      49,
      0,
      0,
      945,
      950,
      3,
      94,
      47,
      0,
      946,
      947,
      5,
      11,
      0,
      0,
      947,
      949,
      3,
      94,
      47,
      0,
      948,
      946,
      1,
      0,
      0,
      0,
      949,
      952,
      1,
      0,
      0,
      0,
      950,
      948,
      1,
      0,
      0,
      0,
      950,
      951,
      1,
      0,
      0,
      0,
      951,
      990,
      1,
      0,
      0,
      0,
      952,
      950,
      1,
      0,
      0,
      0,
      953,
      954,
      5,
      50,
      0,
      0,
      954,
      959,
      3,
      94,
      47,
      0,
      955,
      956,
      5,
      11,
      0,
      0,
      956,
      958,
      3,
      94,
      47,
      0,
      957,
      955,
      1,
      0,
      0,
      0,
      958,
      961,
      1,
      0,
      0,
      0,
      959,
      957,
      1,
      0,
      0,
      0,
      959,
      960,
      1,
      0,
      0,
      0,
      960,
      990,
      1,
      0,
      0,
      0,
      961,
      959,
      1,
      0,
      0,
      0,
      962,
      963,
      5,
      51,
      0,
      0,
      963,
      968,
      3,
      94,
      47,
      0,
      964,
      965,
      5,
      11,
      0,
      0,
      965,
      967,
      3,
      94,
      47,
      0,
      966,
      964,
      1,
      0,
      0,
      0,
      967,
      970,
      1,
      0,
      0,
      0,
      968,
      966,
      1,
      0,
      0,
      0,
      968,
      969,
      1,
      0,
      0,
      0,
      969,
      990,
      1,
      0,
      0,
      0,
      970,
      968,
      1,
      0,
      0,
      0,
      971,
      972,
      5,
      48,
      0,
      0,
      972,
      977,
      3,
      94,
      47,
      0,
      973,
      974,
      5,
      11,
      0,
      0,
      974,
      976,
      3,
      94,
      47,
      0,
      975,
      973,
      1,
      0,
      0,
      0,
      976,
      979,
      1,
      0,
      0,
      0,
      977,
      975,
      1,
      0,
      0,
      0,
      977,
      978,
      1,
      0,
      0,
      0,
      978,
      990,
      1,
      0,
      0,
      0,
      979,
      977,
      1,
      0,
      0,
      0,
      980,
      981,
      5,
      52,
      0,
      0,
      981,
      986,
      3,
      94,
      47,
      0,
      982,
      983,
      5,
      11,
      0,
      0,
      983,
      985,
      3,
      94,
      47,
      0,
      984,
      982,
      1,
      0,
      0,
      0,
      985,
      988,
      1,
      0,
      0,
      0,
      986,
      984,
      1,
      0,
      0,
      0,
      986,
      987,
      1,
      0,
      0,
      0,
      987,
      990,
      1,
      0,
      0,
      0,
      988,
      986,
      1,
      0,
      0,
      0,
      989,
      944,
      1,
      0,
      0,
      0,
      989,
      953,
      1,
      0,
      0,
      0,
      989,
      962,
      1,
      0,
      0,
      0,
      989,
      971,
      1,
      0,
      0,
      0,
      989,
      980,
      1,
      0,
      0,
      0,
      990,
      93,
      1,
      0,
      0,
      0,
      991,
      994,
      7,
      2,
      0,
      0,
      992,
      993,
      5,
      8,
      0,
      0,
      993,
      995,
      7,
      2,
      0,
      0,
      994,
      992,
      1,
      0,
      0,
      0,
      994,
      995,
      1,
      0,
      0,
      0,
      995,
      95,
      1,
      0,
      0,
      0,
      996,
      998,
      5,
      53,
      0,
      0,
      997,
      999,
      5,
      118,
      0,
      0,
      998,
      997,
      1,
      0,
      0,
      0,
      998,
      999,
      1,
      0,
      0,
      0,
      999,
      1e3,
      1,
      0,
      0,
      0,
      1e3,
      1005,
      3,
      98,
      49,
      0,
      1001,
      1002,
      5,
      11,
      0,
      0,
      1002,
      1004,
      3,
      98,
      49,
      0,
      1003,
      1001,
      1,
      0,
      0,
      0,
      1004,
      1007,
      1,
      0,
      0,
      0,
      1005,
      1003,
      1,
      0,
      0,
      0,
      1005,
      1006,
      1,
      0,
      0,
      0,
      1006,
      1021,
      1,
      0,
      0,
      0,
      1007,
      1005,
      1,
      0,
      0,
      0,
      1008,
      1010,
      5,
      109,
      0,
      0,
      1009,
      1011,
      5,
      118,
      0,
      0,
      1010,
      1009,
      1,
      0,
      0,
      0,
      1010,
      1011,
      1,
      0,
      0,
      0,
      1011,
      1012,
      1,
      0,
      0,
      0,
      1012,
      1017,
      3,
      98,
      49,
      0,
      1013,
      1014,
      5,
      11,
      0,
      0,
      1014,
      1016,
      3,
      98,
      49,
      0,
      1015,
      1013,
      1,
      0,
      0,
      0,
      1016,
      1019,
      1,
      0,
      0,
      0,
      1017,
      1015,
      1,
      0,
      0,
      0,
      1017,
      1018,
      1,
      0,
      0,
      0,
      1018,
      1021,
      1,
      0,
      0,
      0,
      1019,
      1017,
      1,
      0,
      0,
      0,
      1020,
      996,
      1,
      0,
      0,
      0,
      1020,
      1008,
      1,
      0,
      0,
      0,
      1021,
      97,
      1,
      0,
      0,
      0,
      1022,
      1024,
      3,
      266,
      133,
      0,
      1023,
      1025,
      3,
      100,
      50,
      0,
      1024,
      1023,
      1,
      0,
      0,
      0,
      1024,
      1025,
      1,
      0,
      0,
      0,
      1025,
      1026,
      1,
      0,
      0,
      0,
      1026,
      1027,
      5,
      33,
      0,
      0,
      1027,
      1028,
      3,
      252,
      126,
      0,
      1028,
      1034,
      1,
      0,
      0,
      0,
      1029,
      1031,
      5,
      141,
      0,
      0,
      1030,
      1032,
      3,
      100,
      50,
      0,
      1031,
      1030,
      1,
      0,
      0,
      0,
      1031,
      1032,
      1,
      0,
      0,
      0,
      1032,
      1034,
      1,
      0,
      0,
      0,
      1033,
      1022,
      1,
      0,
      0,
      0,
      1033,
      1029,
      1,
      0,
      0,
      0,
      1034,
      99,
      1,
      0,
      0,
      0,
      1035,
      1036,
      5,
      2,
      0,
      0,
      1036,
      1041,
      3,
      102,
      51,
      0,
      1037,
      1038,
      5,
      11,
      0,
      0,
      1038,
      1040,
      3,
      102,
      51,
      0,
      1039,
      1037,
      1,
      0,
      0,
      0,
      1040,
      1043,
      1,
      0,
      0,
      0,
      1041,
      1039,
      1,
      0,
      0,
      0,
      1041,
      1042,
      1,
      0,
      0,
      0,
      1042,
      1044,
      1,
      0,
      0,
      0,
      1043,
      1041,
      1,
      0,
      0,
      0,
      1044,
      1045,
      5,
      3,
      0,
      0,
      1045,
      101,
      1,
      0,
      0,
      0,
      1046,
      1047,
      3,
      244,
      122,
      0,
      1047,
      1048,
      5,
      127,
      0,
      0,
      1048,
      1050,
      1,
      0,
      0,
      0,
      1049,
      1046,
      1,
      0,
      0,
      0,
      1049,
      1050,
      1,
      0,
      0,
      0,
      1050,
      1051,
      1,
      0,
      0,
      0,
      1051,
      1052,
      3,
      244,
      122,
      0,
      1052,
      103,
      1,
      0,
      0,
      0,
      1053,
      1054,
      5,
      54,
      0,
      0,
      1054,
      1055,
      3,
      106,
      53,
      0,
      1055,
      1056,
      1,
      0,
      0,
      0,
      1056,
      1057,
      3,
      2,
      1,
      0,
      1057,
      1058,
      5,
      85,
      0,
      0,
      1058,
      1069,
      1,
      0,
      0,
      0,
      1059,
      1060,
      5,
      54,
      0,
      0,
      1060,
      1061,
      3,
      2,
      1,
      0,
      1061,
      1062,
      5,
      85,
      0,
      0,
      1062,
      1063,
      3,
      106,
      53,
      0,
      1063,
      1069,
      1,
      0,
      0,
      0,
      1064,
      1065,
      5,
      54,
      0,
      0,
      1065,
      1066,
      3,
      2,
      1,
      0,
      1066,
      1067,
      5,
      85,
      0,
      0,
      1067,
      1069,
      1,
      0,
      0,
      0,
      1068,
      1053,
      1,
      0,
      0,
      0,
      1068,
      1059,
      1,
      0,
      0,
      0,
      1068,
      1064,
      1,
      0,
      0,
      0,
      1069,
      105,
      1,
      0,
      0,
      0,
      1070,
      1071,
      5,
      135,
      0,
      0,
      1071,
      1075,
      3,
      244,
      122,
      0,
      1072,
      1073,
      5,
      131,
      0,
      0,
      1073,
      1075,
      3,
      244,
      122,
      0,
      1074,
      1070,
      1,
      0,
      0,
      0,
      1074,
      1072,
      1,
      0,
      0,
      0,
      1075,
      107,
      1,
      0,
      0,
      0,
      1076,
      1077,
      5,
      60,
      0,
      0,
      1077,
      109,
      1,
      0,
      0,
      0,
      1078,
      1079,
      5,
      61,
      0,
      0,
      1079,
      1080,
      7,
      3,
      0,
      0,
      1080,
      111,
      1,
      0,
      0,
      0,
      1081,
      1083,
      5,
      62,
      0,
      0,
      1082,
      1084,
      5,
      4,
      0,
      0,
      1083,
      1082,
      1,
      0,
      0,
      0,
      1083,
      1084,
      1,
      0,
      0,
      0,
      1084,
      1085,
      1,
      0,
      0,
      0,
      1085,
      1086,
      3,
      244,
      122,
      0,
      1086,
      1087,
      5,
      11,
      0,
      0,
      1087,
      1092,
      3,
      114,
      57,
      0,
      1088,
      1089,
      5,
      11,
      0,
      0,
      1089,
      1091,
      3,
      114,
      57,
      0,
      1090,
      1088,
      1,
      0,
      0,
      0,
      1091,
      1094,
      1,
      0,
      0,
      0,
      1092,
      1090,
      1,
      0,
      0,
      0,
      1092,
      1093,
      1,
      0,
      0,
      0,
      1093,
      113,
      1,
      0,
      0,
      0,
      1094,
      1092,
      1,
      0,
      0,
      0,
      1095,
      1096,
      3,
      244,
      122,
      0,
      1096,
      1097,
      5,
      33,
      0,
      0,
      1097,
      1098,
      3,
      250,
      125,
      0,
      1098,
      115,
      1,
      0,
      0,
      0,
      1099,
      1100,
      5,
      63,
      0,
      0,
      1100,
      1101,
      5,
      141,
      0,
      0,
      1101,
      1102,
      5,
      16,
      0,
      0,
      1102,
      1103,
      3,
      244,
      122,
      0,
      1103,
      1104,
      5,
      127,
      0,
      0,
      1104,
      1107,
      3,
      244,
      122,
      0,
      1105,
      1106,
      5,
      121,
      0,
      0,
      1106,
      1108,
      3,
      244,
      122,
      0,
      1107,
      1105,
      1,
      0,
      0,
      0,
      1107,
      1108,
      1,
      0,
      0,
      0,
      1108,
      1109,
      1,
      0,
      0,
      0,
      1109,
      1116,
      3,
      2,
      1,
      0,
      1110,
      1112,
      5,
      91,
      0,
      0,
      1111,
      1113,
      5,
      141,
      0,
      0,
      1112,
      1111,
      1,
      0,
      0,
      0,
      1112,
      1113,
      1,
      0,
      0,
      0,
      1113,
      1117,
      1,
      0,
      0,
      0,
      1114,
      1115,
      5,
      147,
      0,
      0,
      1115,
      1117,
      5,
      141,
      0,
      0,
      1116,
      1110,
      1,
      0,
      0,
      0,
      1116,
      1114,
      1,
      0,
      0,
      0,
      1117,
      117,
      1,
      0,
      0,
      0,
      1118,
      1120,
      5,
      66,
      0,
      0,
      1119,
      1121,
      5,
      121,
      0,
      0,
      1120,
      1119,
      1,
      0,
      0,
      0,
      1120,
      1121,
      1,
      0,
      0,
      0,
      1121,
      1122,
      1,
      0,
      0,
      0,
      1122,
      1123,
      5,
      2,
      0,
      0,
      1123,
      1124,
      3,
      244,
      122,
      0,
      1124,
      1125,
      5,
      11,
      0,
      0,
      1125,
      1126,
      3,
      244,
      122,
      0,
      1126,
      1127,
      5,
      3,
      0,
      0,
      1127,
      1129,
      5,
      8,
      0,
      0,
      1128,
      1130,
      5,
      121,
      0,
      0,
      1129,
      1128,
      1,
      0,
      0,
      0,
      1129,
      1130,
      1,
      0,
      0,
      0,
      1130,
      1131,
      1,
      0,
      0,
      0,
      1131,
      1132,
      5,
      2,
      0,
      0,
      1132,
      1133,
      3,
      244,
      122,
      0,
      1133,
      1134,
      5,
      11,
      0,
      0,
      1134,
      1135,
      3,
      244,
      122,
      0,
      1135,
      1136,
      5,
      3,
      0,
      0,
      1136,
      1137,
      5,
      11,
      0,
      0,
      1137,
      1138,
      3,
      250,
      125,
      0,
      1138,
      119,
      1,
      0,
      0,
      0,
      1139,
      1141,
      5,
      66,
      0,
      0,
      1140,
      1142,
      5,
      4,
      0,
      0,
      1141,
      1140,
      1,
      0,
      0,
      0,
      1141,
      1142,
      1,
      0,
      0,
      0,
      1142,
      1143,
      1,
      0,
      0,
      0,
      1143,
      1152,
      3,
      244,
      122,
      0,
      1144,
      1146,
      5,
      11,
      0,
      0,
      1145,
      1147,
      3,
      244,
      122,
      0,
      1146,
      1145,
      1,
      0,
      0,
      0,
      1146,
      1147,
      1,
      0,
      0,
      0,
      1147,
      1150,
      1,
      0,
      0,
      0,
      1148,
      1149,
      5,
      11,
      0,
      0,
      1149,
      1151,
      3,
      250,
      125,
      0,
      1150,
      1148,
      1,
      0,
      0,
      0,
      1150,
      1151,
      1,
      0,
      0,
      0,
      1151,
      1153,
      1,
      0,
      0,
      0,
      1152,
      1144,
      1,
      0,
      0,
      0,
      1152,
      1153,
      1,
      0,
      0,
      0,
      1153,
      121,
      1,
      0,
      0,
      0,
      1154,
      1155,
      5,
      67,
      0,
      0,
      1155,
      1156,
      3,
      126,
      63,
      0,
      1156,
      123,
      1,
      0,
      0,
      0,
      1157,
      1158,
      5,
      68,
      0,
      0,
      1158,
      1159,
      3,
      126,
      63,
      0,
      1159,
      125,
      1,
      0,
      0,
      0,
      1160,
      1163,
      3,
      6,
      3,
      0,
      1161,
      1163,
      3,
      8,
      4,
      0,
      1162,
      1160,
      1,
      0,
      0,
      0,
      1162,
      1161,
      1,
      0,
      0,
      0,
      1163,
      127,
      1,
      0,
      0,
      0,
      1164,
      1165,
      5,
      69,
      0,
      0,
      1165,
      1166,
      3,
      244,
      122,
      0,
      1166,
      1167,
      5,
      126,
      0,
      0,
      1167,
      1170,
      3,
      130,
      65,
      0,
      1168,
      1169,
      5,
      56,
      0,
      0,
      1169,
      1171,
      3,
      130,
      65,
      0,
      1170,
      1168,
      1,
      0,
      0,
      0,
      1170,
      1171,
      1,
      0,
      0,
      0,
      1171,
      1180,
      1,
      0,
      0,
      0,
      1172,
      1173,
      5,
      69,
      0,
      0,
      1173,
      1174,
      3,
      244,
      122,
      0,
      1174,
      1177,
      3,
      124,
      62,
      0,
      1175,
      1176,
      5,
      56,
      0,
      0,
      1176,
      1178,
      3,
      130,
      65,
      0,
      1177,
      1175,
      1,
      0,
      0,
      0,
      1177,
      1178,
      1,
      0,
      0,
      0,
      1178,
      1180,
      1,
      0,
      0,
      0,
      1179,
      1164,
      1,
      0,
      0,
      0,
      1179,
      1172,
      1,
      0,
      0,
      0,
      1180,
      129,
      1,
      0,
      0,
      0,
      1181,
      1186,
      3,
      10,
      5,
      0,
      1182,
      1183,
      5,
      1,
      0,
      0,
      1183,
      1185,
      3,
      10,
      5,
      0,
      1184,
      1182,
      1,
      0,
      0,
      0,
      1185,
      1188,
      1,
      0,
      0,
      0,
      1186,
      1184,
      1,
      0,
      0,
      0,
      1186,
      1187,
      1,
      0,
      0,
      0,
      1187,
      1191,
      1,
      0,
      0,
      0,
      1188,
      1186,
      1,
      0,
      0,
      0,
      1189,
      1191,
      3,
      6,
      3,
      0,
      1190,
      1181,
      1,
      0,
      0,
      0,
      1190,
      1189,
      1,
      0,
      0,
      0,
      1191,
      131,
      1,
      0,
      0,
      0,
      1192,
      1194,
      5,
      71,
      0,
      0,
      1193,
      1195,
      5,
      12,
      0,
      0,
      1194,
      1193,
      1,
      0,
      0,
      0,
      1194,
      1195,
      1,
      0,
      0,
      0,
      1195,
      1198,
      1,
      0,
      0,
      0,
      1196,
      1197,
      5,
      27,
      0,
      0,
      1197,
      1199,
      7,
      4,
      0,
      0,
      1198,
      1196,
      1,
      0,
      0,
      0,
      1198,
      1199,
      1,
      0,
      0,
      0,
      1199,
      1200,
      1,
      0,
      0,
      0,
      1200,
      1205,
      3,
      250,
      125,
      0,
      1201,
      1202,
      5,
      11,
      0,
      0,
      1202,
      1204,
      3,
      250,
      125,
      0,
      1203,
      1201,
      1,
      0,
      0,
      0,
      1204,
      1207,
      1,
      0,
      0,
      0,
      1205,
      1203,
      1,
      0,
      0,
      0,
      1205,
      1206,
      1,
      0,
      0,
      0,
      1206,
      1220,
      1,
      0,
      0,
      0,
      1207,
      1205,
      1,
      0,
      0,
      0,
      1208,
      1209,
      5,
      71,
      0,
      0,
      1209,
      1210,
      3,
      262,
      131,
      0,
      1210,
      1211,
      5,
      11,
      0,
      0,
      1211,
      1216,
      3,
      250,
      125,
      0,
      1212,
      1213,
      5,
      11,
      0,
      0,
      1213,
      1215,
      3,
      250,
      125,
      0,
      1214,
      1212,
      1,
      0,
      0,
      0,
      1215,
      1218,
      1,
      0,
      0,
      0,
      1216,
      1214,
      1,
      0,
      0,
      0,
      1216,
      1217,
      1,
      0,
      0,
      0,
      1217,
      1220,
      1,
      0,
      0,
      0,
      1218,
      1216,
      1,
      0,
      0,
      0,
      1219,
      1192,
      1,
      0,
      0,
      0,
      1219,
      1208,
      1,
      0,
      0,
      0,
      1220,
      133,
      1,
      0,
      0,
      0,
      1221,
      1223,
      5,
      73,
      0,
      0,
      1222,
      1224,
      5,
      4,
      0,
      0,
      1223,
      1222,
      1,
      0,
      0,
      0,
      1223,
      1224,
      1,
      0,
      0,
      0,
      1224,
      1225,
      1,
      0,
      0,
      0,
      1225,
      1226,
      3,
      244,
      122,
      0,
      1226,
      1227,
      5,
      11,
      0,
      0,
      1227,
      1228,
      3,
      244,
      122,
      0,
      1228,
      135,
      1,
      0,
      0,
      0,
      1229,
      1230,
      5,
      77,
      0,
      0,
      1230,
      1239,
      5,
      81,
      0,
      0,
      1231,
      1232,
      5,
      77,
      0,
      0,
      1232,
      1239,
      7,
      5,
      0,
      0,
      1233,
      1234,
      5,
      77,
      0,
      0,
      1234,
      1235,
      3,
      244,
      122,
      0,
      1235,
      1236,
      5,
      11,
      0,
      0,
      1236,
      1237,
      3,
      244,
      122,
      0,
      1237,
      1239,
      1,
      0,
      0,
      0,
      1238,
      1229,
      1,
      0,
      0,
      0,
      1238,
      1231,
      1,
      0,
      0,
      0,
      1238,
      1233,
      1,
      0,
      0,
      0,
      1239,
      137,
      1,
      0,
      0,
      0,
      1240,
      1250,
      5,
      80,
      0,
      0,
      1241,
      1243,
      5,
      121,
      0,
      0,
      1242,
      1241,
      1,
      0,
      0,
      0,
      1242,
      1243,
      1,
      0,
      0,
      0,
      1243,
      1244,
      1,
      0,
      0,
      0,
      1244,
      1245,
      5,
      2,
      0,
      0,
      1245,
      1246,
      3,
      244,
      122,
      0,
      1246,
      1247,
      5,
      11,
      0,
      0,
      1247,
      1248,
      3,
      244,
      122,
      0,
      1248,
      1249,
      5,
      3,
      0,
      0,
      1249,
      1251,
      1,
      0,
      0,
      0,
      1250,
      1242,
      1,
      0,
      0,
      0,
      1250,
      1251,
      1,
      0,
      0,
      0,
      1251,
      1252,
      1,
      0,
      0,
      0,
      1252,
      1254,
      5,
      8,
      0,
      0,
      1253,
      1255,
      5,
      121,
      0,
      0,
      1254,
      1253,
      1,
      0,
      0,
      0,
      1254,
      1255,
      1,
      0,
      0,
      0,
      1255,
      1256,
      1,
      0,
      0,
      0,
      1256,
      1257,
      5,
      2,
      0,
      0,
      1257,
      1258,
      3,
      244,
      122,
      0,
      1258,
      1259,
      5,
      11,
      0,
      0,
      1259,
      1260,
      3,
      244,
      122,
      0,
      1260,
      1284,
      5,
      3,
      0,
      0,
      1261,
      1263,
      5,
      11,
      0,
      0,
      1262,
      1264,
      3,
      244,
      122,
      0,
      1263,
      1262,
      1,
      0,
      0,
      0,
      1263,
      1264,
      1,
      0,
      0,
      0,
      1264,
      1265,
      1,
      0,
      0,
      0,
      1265,
      1267,
      5,
      11,
      0,
      0,
      1266,
      1268,
      3,
      140,
      70,
      0,
      1267,
      1266,
      1,
      0,
      0,
      0,
      1267,
      1268,
      1,
      0,
      0,
      0,
      1268,
      1269,
      1,
      0,
      0,
      0,
      1269,
      1270,
      5,
      11,
      0,
      0,
      1270,
      1285,
      3,
      244,
      122,
      0,
      1271,
      1273,
      5,
      11,
      0,
      0,
      1272,
      1274,
      3,
      244,
      122,
      0,
      1273,
      1272,
      1,
      0,
      0,
      0,
      1273,
      1274,
      1,
      0,
      0,
      0,
      1274,
      1275,
      1,
      0,
      0,
      0,
      1275,
      1276,
      5,
      11,
      0,
      0,
      1276,
      1285,
      3,
      140,
      70,
      0,
      1277,
      1279,
      5,
      11,
      0,
      0,
      1278,
      1280,
      3,
      244,
      122,
      0,
      1279,
      1278,
      1,
      0,
      0,
      0,
      1279,
      1280,
      1,
      0,
      0,
      0,
      1280,
      1282,
      1,
      0,
      0,
      0,
      1281,
      1283,
      5,
      11,
      0,
      0,
      1282,
      1281,
      1,
      0,
      0,
      0,
      1282,
      1283,
      1,
      0,
      0,
      0,
      1283,
      1285,
      1,
      0,
      0,
      0,
      1284,
      1261,
      1,
      0,
      0,
      0,
      1284,
      1271,
      1,
      0,
      0,
      0,
      1284,
      1277,
      1,
      0,
      0,
      0,
      1284,
      1285,
      1,
      0,
      0,
      0,
      1285,
      139,
      1,
      0,
      0,
      0,
      1286,
      1287,
      5,
      141,
      0,
      0,
      1287,
      141,
      1,
      0,
      0,
      0,
      1288,
      1289,
      5,
      80,
      0,
      0,
      1289,
      1291,
      5,
      71,
      0,
      0,
      1290,
      1292,
      5,
      12,
      0,
      0,
      1291,
      1290,
      1,
      0,
      0,
      0,
      1291,
      1292,
      1,
      0,
      0,
      0,
      1292,
      1295,
      1,
      0,
      0,
      0,
      1293,
      1294,
      5,
      27,
      0,
      0,
      1294,
      1296,
      7,
      4,
      0,
      0,
      1295,
      1293,
      1,
      0,
      0,
      0,
      1295,
      1296,
      1,
      0,
      0,
      0,
      1296,
      1297,
      1,
      0,
      0,
      0,
      1297,
      1305,
      3,
      250,
      125,
      0,
      1298,
      1299,
      5,
      80,
      0,
      0,
      1299,
      1300,
      5,
      71,
      0,
      0,
      1300,
      1301,
      3,
      262,
      131,
      0,
      1301,
      1302,
      5,
      11,
      0,
      0,
      1302,
      1303,
      3,
      250,
      125,
      0,
      1303,
      1305,
      1,
      0,
      0,
      0,
      1304,
      1288,
      1,
      0,
      0,
      0,
      1304,
      1298,
      1,
      0,
      0,
      0,
      1305,
      143,
      1,
      0,
      0,
      0,
      1306,
      1352,
      5,
      82,
      0,
      0,
      1307,
      1309,
      3,
      244,
      122,
      0,
      1308,
      1307,
      1,
      0,
      0,
      0,
      1308,
      1309,
      1,
      0,
      0,
      0,
      1309,
      1310,
      1,
      0,
      0,
      0,
      1310,
      1312,
      5,
      11,
      0,
      0,
      1311,
      1313,
      3,
      244,
      122,
      0,
      1312,
      1311,
      1,
      0,
      0,
      0,
      1312,
      1313,
      1,
      0,
      0,
      0,
      1313,
      1314,
      1,
      0,
      0,
      0,
      1314,
      1316,
      5,
      11,
      0,
      0,
      1315,
      1317,
      3,
      244,
      122,
      0,
      1316,
      1315,
      1,
      0,
      0,
      0,
      1316,
      1317,
      1,
      0,
      0,
      0,
      1317,
      1318,
      1,
      0,
      0,
      0,
      1318,
      1320,
      5,
      11,
      0,
      0,
      1319,
      1321,
      3,
      244,
      122,
      0,
      1320,
      1319,
      1,
      0,
      0,
      0,
      1320,
      1321,
      1,
      0,
      0,
      0,
      1321,
      1322,
      1,
      0,
      0,
      0,
      1322,
      1323,
      5,
      11,
      0,
      0,
      1323,
      1353,
      3,
      244,
      122,
      0,
      1324,
      1326,
      3,
      244,
      122,
      0,
      1325,
      1324,
      1,
      0,
      0,
      0,
      1325,
      1326,
      1,
      0,
      0,
      0,
      1326,
      1327,
      1,
      0,
      0,
      0,
      1327,
      1329,
      5,
      11,
      0,
      0,
      1328,
      1330,
      3,
      244,
      122,
      0,
      1329,
      1328,
      1,
      0,
      0,
      0,
      1329,
      1330,
      1,
      0,
      0,
      0,
      1330,
      1331,
      1,
      0,
      0,
      0,
      1331,
      1333,
      5,
      11,
      0,
      0,
      1332,
      1334,
      3,
      244,
      122,
      0,
      1333,
      1332,
      1,
      0,
      0,
      0,
      1333,
      1334,
      1,
      0,
      0,
      0,
      1334,
      1335,
      1,
      0,
      0,
      0,
      1335,
      1336,
      5,
      11,
      0,
      0,
      1336,
      1353,
      3,
      244,
      122,
      0,
      1337,
      1339,
      3,
      244,
      122,
      0,
      1338,
      1337,
      1,
      0,
      0,
      0,
      1338,
      1339,
      1,
      0,
      0,
      0,
      1339,
      1340,
      1,
      0,
      0,
      0,
      1340,
      1342,
      5,
      11,
      0,
      0,
      1341,
      1343,
      3,
      244,
      122,
      0,
      1342,
      1341,
      1,
      0,
      0,
      0,
      1342,
      1343,
      1,
      0,
      0,
      0,
      1343,
      1344,
      1,
      0,
      0,
      0,
      1344,
      1345,
      5,
      11,
      0,
      0,
      1345,
      1353,
      3,
      244,
      122,
      0,
      1346,
      1348,
      3,
      244,
      122,
      0,
      1347,
      1346,
      1,
      0,
      0,
      0,
      1347,
      1348,
      1,
      0,
      0,
      0,
      1348,
      1349,
      1,
      0,
      0,
      0,
      1349,
      1350,
      5,
      11,
      0,
      0,
      1350,
      1353,
      3,
      244,
      122,
      0,
      1351,
      1353,
      3,
      244,
      122,
      0,
      1352,
      1308,
      1,
      0,
      0,
      0,
      1352,
      1325,
      1,
      0,
      0,
      0,
      1352,
      1338,
      1,
      0,
      0,
      0,
      1352,
      1347,
      1,
      0,
      0,
      0,
      1352,
      1351,
      1,
      0,
      0,
      0,
      1352,
      1353,
      1,
      0,
      0,
      0,
      1353,
      145,
      1,
      0,
      0,
      0,
      1354,
      1356,
      5,
      83,
      0,
      0,
      1355,
      1357,
      5,
      4,
      0,
      0,
      1356,
      1355,
      1,
      0,
      0,
      0,
      1356,
      1357,
      1,
      0,
      0,
      0,
      1357,
      1358,
      1,
      0,
      0,
      0,
      1358,
      1367,
      3,
      244,
      122,
      0,
      1359,
      1365,
      5,
      11,
      0,
      0,
      1360,
      1366,
      3,
      244,
      122,
      0,
      1361,
      1362,
      3,
      244,
      122,
      0,
      1362,
      1363,
      5,
      127,
      0,
      0,
      1363,
      1364,
      3,
      244,
      122,
      0,
      1364,
      1366,
      1,
      0,
      0,
      0,
      1365,
      1360,
      1,
      0,
      0,
      0,
      1365,
      1361,
      1,
      0,
      0,
      0,
      1366,
      1368,
      1,
      0,
      0,
      0,
      1367,
      1359,
      1,
      0,
      0,
      0,
      1367,
      1368,
      1,
      0,
      0,
      0,
      1368,
      147,
      1,
      0,
      0,
      0,
      1369,
      1377,
      5,
      86,
      0,
      0,
      1370,
      1376,
      7,
      4,
      0,
      0,
      1371,
      1373,
      7,
      4,
      0,
      0,
      1372,
      1371,
      1,
      0,
      0,
      0,
      1372,
      1373,
      1,
      0,
      0,
      0,
      1373,
      1374,
      1,
      0,
      0,
      0,
      1374,
      1376,
      3,
      244,
      122,
      0,
      1375,
      1370,
      1,
      0,
      0,
      0,
      1375,
      1372,
      1,
      0,
      0,
      0,
      1376,
      1379,
      1,
      0,
      0,
      0,
      1377,
      1375,
      1,
      0,
      0,
      0,
      1377,
      1378,
      1,
      0,
      0,
      0,
      1378,
      149,
      1,
      0,
      0,
      0,
      1379,
      1377,
      1,
      0,
      0,
      0,
      1380,
      1381,
      5,
      86,
      0,
      0,
      1381,
      1382,
      5,
      132,
      0,
      0,
      1382,
      1383,
      3,
      244,
      122,
      0,
      1383,
      1385,
      5,
      12,
      0,
      0,
      1384,
      1386,
      3,
      244,
      122,
      0,
      1385,
      1384,
      1,
      0,
      0,
      0,
      1385,
      1386,
      1,
      0,
      0,
      0,
      1386,
      1394,
      1,
      0,
      0,
      0,
      1387,
      1393,
      7,
      4,
      0,
      0,
      1388,
      1390,
      7,
      4,
      0,
      0,
      1389,
      1388,
      1,
      0,
      0,
      0,
      1389,
      1390,
      1,
      0,
      0,
      0,
      1390,
      1391,
      1,
      0,
      0,
      0,
      1391,
      1393,
      3,
      244,
      122,
      0,
      1392,
      1387,
      1,
      0,
      0,
      0,
      1392,
      1389,
      1,
      0,
      0,
      0,
      1393,
      1396,
      1,
      0,
      0,
      0,
      1394,
      1392,
      1,
      0,
      0,
      0,
      1394,
      1395,
      1,
      0,
      0,
      0,
      1395,
      151,
      1,
      0,
      0,
      0,
      1396,
      1394,
      1,
      0,
      0,
      0,
      1397,
      1398,
      5,
      87,
      0,
      0,
      1398,
      1399,
      3,
      250,
      125,
      0,
      1399,
      1400,
      5,
      16,
      0,
      0,
      1400,
      1401,
      3,
      244,
      122,
      0,
      1401,
      153,
      1,
      0,
      0,
      0,
      1402,
      1403,
      5,
      88,
      0,
      0,
      1403,
      1404,
      5,
      2,
      0,
      0,
      1404,
      1405,
      3,
      250,
      125,
      0,
      1405,
      1406,
      5,
      11,
      0,
      0,
      1406,
      1409,
      3,
      244,
      122,
      0,
      1407,
      1408,
      5,
      11,
      0,
      0,
      1408,
      1410,
      3,
      244,
      122,
      0,
      1409,
      1407,
      1,
      0,
      0,
      0,
      1409,
      1410,
      1,
      0,
      0,
      0,
      1410,
      1411,
      1,
      0,
      0,
      0,
      1411,
      1412,
      5,
      3,
      0,
      0,
      1412,
      1413,
      5,
      16,
      0,
      0,
      1413,
      1414,
      3,
      244,
      122,
      0,
      1414,
      155,
      1,
      0,
      0,
      0,
      1415,
      1416,
      5,
      90,
      0,
      0,
      1416,
      1417,
      3,
      244,
      122,
      0,
      1417,
      1418,
      5,
      33,
      0,
      0,
      1418,
      1419,
      3,
      244,
      122,
      0,
      1419,
      157,
      1,
      0,
      0,
      0,
      1420,
      1421,
      5,
      98,
      0,
      0,
      1421,
      1426,
      5,
      59,
      0,
      0,
      1422,
      1423,
      5,
      68,
      0,
      0,
      1423,
      1427,
      3,
      126,
      63,
      0,
      1424,
      1425,
      5,
      111,
      0,
      0,
      1425,
      1427,
      5,
      91,
      0,
      0,
      1426,
      1422,
      1,
      0,
      0,
      0,
      1426,
      1424,
      1,
      0,
      0,
      0,
      1427,
      159,
      1,
      0,
      0,
      0,
      1428,
      1429,
      5,
      98,
      0,
      0,
      1429,
      1430,
      5,
      42,
      0,
      0,
      1430,
      1431,
      5,
      2,
      0,
      0,
      1431,
      1432,
      3,
      244,
      122,
      0,
      1432,
      1433,
      5,
      3,
      0,
      0,
      1433,
      1434,
      5,
      67,
      0,
      0,
      1434,
      1435,
      3,
      126,
      63,
      0,
      1435,
      1473,
      1,
      0,
      0,
      0,
      1436,
      1437,
      5,
      98,
      0,
      0,
      1437,
      1438,
      5,
      77,
      0,
      0,
      1438,
      1439,
      5,
      2,
      0,
      0,
      1439,
      1440,
      3,
      244,
      122,
      0,
      1440,
      1441,
      5,
      3,
      0,
      0,
      1441,
      1442,
      5,
      67,
      0,
      0,
      1442,
      1443,
      3,
      126,
      63,
      0,
      1443,
      1473,
      1,
      0,
      0,
      0,
      1444,
      1445,
      5,
      98,
      0,
      0,
      1445,
      1446,
      5,
      101,
      0,
      0,
      1446,
      1447,
      5,
      67,
      0,
      0,
      1447,
      1473,
      3,
      126,
      63,
      0,
      1448,
      1449,
      5,
      98,
      0,
      0,
      1449,
      1450,
      5,
      102,
      0,
      0,
      1450,
      1451,
      5,
      2,
      0,
      0,
      1451,
      1452,
      3,
      244,
      122,
      0,
      1452,
      1453,
      5,
      3,
      0,
      0,
      1453,
      1454,
      5,
      67,
      0,
      0,
      1454,
      1455,
      3,
      126,
      63,
      0,
      1455,
      1473,
      1,
      0,
      0,
      0,
      1456,
      1457,
      5,
      98,
      0,
      0,
      1457,
      1458,
      5,
      123,
      0,
      0,
      1458,
      1459,
      5,
      2,
      0,
      0,
      1459,
      1460,
      3,
      244,
      122,
      0,
      1460,
      1461,
      5,
      3,
      0,
      0,
      1461,
      1462,
      5,
      67,
      0,
      0,
      1462,
      1463,
      3,
      126,
      63,
      0,
      1463,
      1473,
      1,
      0,
      0,
      0,
      1464,
      1465,
      5,
      98,
      0,
      0,
      1465,
      1466,
      5,
      129,
      0,
      0,
      1466,
      1467,
      5,
      2,
      0,
      0,
      1467,
      1468,
      3,
      244,
      122,
      0,
      1468,
      1469,
      5,
      3,
      0,
      0,
      1469,
      1470,
      5,
      67,
      0,
      0,
      1470,
      1471,
      3,
      126,
      63,
      0,
      1471,
      1473,
      1,
      0,
      0,
      0,
      1472,
      1428,
      1,
      0,
      0,
      0,
      1472,
      1436,
      1,
      0,
      0,
      0,
      1472,
      1444,
      1,
      0,
      0,
      0,
      1472,
      1448,
      1,
      0,
      0,
      0,
      1472,
      1456,
      1,
      0,
      0,
      0,
      1472,
      1464,
      1,
      0,
      0,
      0,
      1473,
      161,
      1,
      0,
      0,
      0,
      1474,
      1475,
      5,
      98,
      0,
      0,
      1475,
      1476,
      3,
      244,
      122,
      0,
      1476,
      1477,
      5,
      67,
      0,
      0,
      1477,
      1478,
      3,
      164,
      82,
      0,
      1478,
      163,
      1,
      0,
      0,
      0,
      1479,
      1484,
      3,
      126,
      63,
      0,
      1480,
      1481,
      5,
      11,
      0,
      0,
      1481,
      1483,
      3,
      126,
      63,
      0,
      1482,
      1480,
      1,
      0,
      0,
      0,
      1483,
      1486,
      1,
      0,
      0,
      0,
      1484,
      1482,
      1,
      0,
      0,
      0,
      1484,
      1485,
      1,
      0,
      0,
      0,
      1485,
      165,
      1,
      0,
      0,
      0,
      1486,
      1484,
      1,
      0,
      0,
      0,
      1487,
      1488,
      5,
      98,
      0,
      0,
      1488,
      1489,
      3,
      244,
      122,
      0,
      1489,
      1490,
      5,
      68,
      0,
      0,
      1490,
      1491,
      3,
      164,
      82,
      0,
      1491,
      167,
      1,
      0,
      0,
      0,
      1492,
      1493,
      5,
      95,
      0,
      0,
      1493,
      1494,
      3,
      244,
      122,
      0,
      1494,
      1496,
      5,
      11,
      0,
      0,
      1495,
      1497,
      5,
      4,
      0,
      0,
      1496,
      1495,
      1,
      0,
      0,
      0,
      1496,
      1497,
      1,
      0,
      0,
      0,
      1497,
      1498,
      1,
      0,
      0,
      0,
      1498,
      1499,
      3,
      244,
      122,
      0,
      1499,
      1500,
      5,
      11,
      0,
      0,
      1500,
      1503,
      3,
      244,
      122,
      0,
      1501,
      1502,
      5,
      11,
      0,
      0,
      1502,
      1504,
      3,
      244,
      122,
      0,
      1503,
      1501,
      1,
      0,
      0,
      0,
      1503,
      1504,
      1,
      0,
      0,
      0,
      1504,
      169,
      1,
      0,
      0,
      0,
      1505,
      1506,
      5,
      95,
      0,
      0,
      1506,
      1509,
      3,
      244,
      122,
      0,
      1507,
      1508,
      5,
      63,
      0,
      0,
      1508,
      1510,
      3,
      172,
      86,
      0,
      1509,
      1507,
      1,
      0,
      0,
      0,
      1509,
      1510,
      1,
      0,
      0,
      0,
      1510,
      1513,
      1,
      0,
      0,
      0,
      1511,
      1512,
      5,
      29,
      0,
      0,
      1512,
      1514,
      3,
      174,
      87,
      0,
      1513,
      1511,
      1,
      0,
      0,
      0,
      1513,
      1514,
      1,
      0,
      0,
      0,
      1514,
      1516,
      1,
      0,
      0,
      0,
      1515,
      1517,
      3,
      176,
      88,
      0,
      1516,
      1515,
      1,
      0,
      0,
      0,
      1516,
      1517,
      1,
      0,
      0,
      0,
      1517,
      1518,
      1,
      0,
      0,
      0,
      1518,
      1520,
      5,
      33,
      0,
      0,
      1519,
      1521,
      5,
      4,
      0,
      0,
      1520,
      1519,
      1,
      0,
      0,
      0,
      1520,
      1521,
      1,
      0,
      0,
      0,
      1521,
      1522,
      1,
      0,
      0,
      0,
      1522,
      1523,
      3,
      244,
      122,
      0,
      1523,
      1527,
      1,
      0,
      0,
      0,
      1524,
      1525,
      5,
      78,
      0,
      0,
      1525,
      1526,
      5,
      16,
      0,
      0,
      1526,
      1528,
      3,
      244,
      122,
      0,
      1527,
      1524,
      1,
      0,
      0,
      0,
      1527,
      1528,
      1,
      0,
      0,
      0,
      1528,
      171,
      1,
      0,
      0,
      0,
      1529,
      1530,
      7,
      6,
      0,
      0,
      1530,
      173,
      1,
      0,
      0,
      0,
      1531,
      1536,
      5,
      108,
      0,
      0,
      1532,
      1536,
      5,
      138,
      0,
      0,
      1533,
      1534,
      5,
      108,
      0,
      0,
      1534,
      1536,
      5,
      138,
      0,
      0,
      1535,
      1531,
      1,
      0,
      0,
      0,
      1535,
      1532,
      1,
      0,
      0,
      0,
      1535,
      1533,
      1,
      0,
      0,
      0,
      1536,
      175,
      1,
      0,
      0,
      0,
      1537,
      1546,
      5,
      118,
      0,
      0,
      1538,
      1539,
      5,
      83,
      0,
      0,
      1539,
      1546,
      5,
      108,
      0,
      0,
      1540,
      1541,
      5,
      83,
      0,
      0,
      1541,
      1546,
      5,
      138,
      0,
      0,
      1542,
      1543,
      5,
      83,
      0,
      0,
      1543,
      1544,
      5,
      108,
      0,
      0,
      1544,
      1546,
      5,
      138,
      0,
      0,
      1545,
      1537,
      1,
      0,
      0,
      0,
      1545,
      1538,
      1,
      0,
      0,
      0,
      1545,
      1540,
      1,
      0,
      0,
      0,
      1545,
      1542,
      1,
      0,
      0,
      0,
      1546,
      177,
      1,
      0,
      0,
      0,
      1547,
      1549,
      5,
      99,
      0,
      0,
      1548,
      1550,
      5,
      121,
      0,
      0,
      1549,
      1548,
      1,
      0,
      0,
      0,
      1549,
      1550,
      1,
      0,
      0,
      0,
      1550,
      1551,
      1,
      0,
      0,
      0,
      1551,
      1552,
      5,
      2,
      0,
      0,
      1552,
      1553,
      3,
      244,
      122,
      0,
      1553,
      1554,
      5,
      11,
      0,
      0,
      1554,
      1555,
      3,
      244,
      122,
      0,
      1555,
      1574,
      5,
      3,
      0,
      0,
      1556,
      1558,
      5,
      11,
      0,
      0,
      1557,
      1559,
      3,
      244,
      122,
      0,
      1558,
      1557,
      1,
      0,
      0,
      0,
      1558,
      1559,
      1,
      0,
      0,
      0,
      1559,
      1560,
      1,
      0,
      0,
      0,
      1560,
      1562,
      5,
      11,
      0,
      0,
      1561,
      1563,
      3,
      244,
      122,
      0,
      1562,
      1561,
      1,
      0,
      0,
      0,
      1562,
      1563,
      1,
      0,
      0,
      0,
      1563,
      1564,
      1,
      0,
      0,
      0,
      1564,
      1565,
      5,
      11,
      0,
      0,
      1565,
      1575,
      3,
      244,
      122,
      0,
      1566,
      1568,
      5,
      11,
      0,
      0,
      1567,
      1569,
      3,
      244,
      122,
      0,
      1568,
      1567,
      1,
      0,
      0,
      0,
      1568,
      1569,
      1,
      0,
      0,
      0,
      1569,
      1570,
      1,
      0,
      0,
      0,
      1570,
      1571,
      5,
      11,
      0,
      0,
      1571,
      1575,
      3,
      244,
      122,
      0,
      1572,
      1573,
      5,
      11,
      0,
      0,
      1573,
      1575,
      3,
      244,
      122,
      0,
      1574,
      1556,
      1,
      0,
      0,
      0,
      1574,
      1566,
      1,
      0,
      0,
      0,
      1574,
      1572,
      1,
      0,
      0,
      0,
      1574,
      1575,
      1,
      0,
      0,
      0,
      1575,
      179,
      1,
      0,
      0,
      0,
      1576,
      1577,
      5,
      100,
      0,
      0,
      1577,
      1578,
      3,
      244,
      122,
      0,
      1578,
      1579,
      5,
      11,
      0,
      0,
      1579,
      1580,
      3,
      244,
      122,
      0,
      1580,
      1586,
      1,
      0,
      0,
      0,
      1581,
      1582,
      5,
      100,
      0,
      0,
      1582,
      1583,
      5,
      132,
      0,
      0,
      1583,
      1586,
      3,
      250,
      125,
      0,
      1584,
      1586,
      5,
      100,
      0,
      0,
      1585,
      1576,
      1,
      0,
      0,
      0,
      1585,
      1581,
      1,
      0,
      0,
      0,
      1585,
      1584,
      1,
      0,
      0,
      0,
      1586,
      181,
      1,
      0,
      0,
      0,
      1587,
      1588,
      5,
      102,
      0,
      0,
      1588,
      1589,
      3,
      244,
      122,
      0,
      1589,
      183,
      1,
      0,
      0,
      0,
      1590,
      1592,
      5,
      104,
      0,
      0,
      1591,
      1593,
      5,
      121,
      0,
      0,
      1592,
      1591,
      1,
      0,
      0,
      0,
      1592,
      1593,
      1,
      0,
      0,
      0,
      1593,
      1594,
      1,
      0,
      0,
      0,
      1594,
      1595,
      5,
      2,
      0,
      0,
      1595,
      1596,
      3,
      244,
      122,
      0,
      1596,
      1597,
      5,
      11,
      0,
      0,
      1597,
      1598,
      3,
      244,
      122,
      0,
      1598,
      1601,
      5,
      3,
      0,
      0,
      1599,
      1600,
      5,
      11,
      0,
      0,
      1600,
      1602,
      3,
      244,
      122,
      0,
      1601,
      1599,
      1,
      0,
      0,
      0,
      1601,
      1602,
      1,
      0,
      0,
      0,
      1602,
      185,
      1,
      0,
      0,
      0,
      1603,
      1607,
      5,
      103,
      0,
      0,
      1604,
      1605,
      3,
      262,
      131,
      0,
      1605,
      1606,
      5,
      11,
      0,
      0,
      1606,
      1608,
      1,
      0,
      0,
      0,
      1607,
      1604,
      1,
      0,
      0,
      0,
      1607,
      1608,
      1,
      0,
      0,
      0,
      1608,
      1610,
      1,
      0,
      0,
      0,
      1609,
      1611,
      3,
      244,
      122,
      0,
      1610,
      1609,
      1,
      0,
      0,
      0,
      1610,
      1611,
      1,
      0,
      0,
      0,
      1611,
      1619,
      1,
      0,
      0,
      0,
      1612,
      1618,
      7,
      4,
      0,
      0,
      1613,
      1615,
      7,
      4,
      0,
      0,
      1614,
      1613,
      1,
      0,
      0,
      0,
      1614,
      1615,
      1,
      0,
      0,
      0,
      1615,
      1616,
      1,
      0,
      0,
      0,
      1616,
      1618,
      3,
      244,
      122,
      0,
      1617,
      1612,
      1,
      0,
      0,
      0,
      1617,
      1614,
      1,
      0,
      0,
      0,
      1618,
      1621,
      1,
      0,
      0,
      0,
      1619,
      1617,
      1,
      0,
      0,
      0,
      1619,
      1620,
      1,
      0,
      0,
      0,
      1620,
      187,
      1,
      0,
      0,
      0,
      1621,
      1619,
      1,
      0,
      0,
      0,
      1622,
      1626,
      5,
      103,
      0,
      0,
      1623,
      1624,
      3,
      262,
      131,
      0,
      1624,
      1625,
      5,
      11,
      0,
      0,
      1625,
      1627,
      1,
      0,
      0,
      0,
      1626,
      1623,
      1,
      0,
      0,
      0,
      1626,
      1627,
      1,
      0,
      0,
      0,
      1627,
      1628,
      1,
      0,
      0,
      0,
      1628,
      1629,
      5,
      132,
      0,
      0,
      1629,
      1630,
      3,
      244,
      122,
      0,
      1630,
      1632,
      5,
      12,
      0,
      0,
      1631,
      1633,
      3,
      244,
      122,
      0,
      1632,
      1631,
      1,
      0,
      0,
      0,
      1632,
      1633,
      1,
      0,
      0,
      0,
      1633,
      1641,
      1,
      0,
      0,
      0,
      1634,
      1640,
      7,
      4,
      0,
      0,
      1635,
      1637,
      7,
      4,
      0,
      0,
      1636,
      1635,
      1,
      0,
      0,
      0,
      1636,
      1637,
      1,
      0,
      0,
      0,
      1637,
      1638,
      1,
      0,
      0,
      0,
      1638,
      1640,
      3,
      244,
      122,
      0,
      1639,
      1634,
      1,
      0,
      0,
      0,
      1639,
      1636,
      1,
      0,
      0,
      0,
      1640,
      1643,
      1,
      0,
      0,
      0,
      1641,
      1639,
      1,
      0,
      0,
      0,
      1641,
      1642,
      1,
      0,
      0,
      0,
      1642,
      189,
      1,
      0,
      0,
      0,
      1643,
      1641,
      1,
      0,
      0,
      0,
      1644,
      1646,
      5,
      105,
      0,
      0,
      1645,
      1647,
      5,
      121,
      0,
      0,
      1646,
      1645,
      1,
      0,
      0,
      0,
      1646,
      1647,
      1,
      0,
      0,
      0,
      1647,
      1648,
      1,
      0,
      0,
      0,
      1648,
      1649,
      5,
      2,
      0,
      0,
      1649,
      1650,
      3,
      244,
      122,
      0,
      1650,
      1651,
      5,
      11,
      0,
      0,
      1651,
      1652,
      3,
      244,
      122,
      0,
      1652,
      1655,
      5,
      3,
      0,
      0,
      1653,
      1654,
      5,
      11,
      0,
      0,
      1654,
      1656,
      3,
      244,
      122,
      0,
      1655,
      1653,
      1,
      0,
      0,
      0,
      1655,
      1656,
      1,
      0,
      0,
      0,
      1656,
      191,
      1,
      0,
      0,
      0,
      1657,
      1659,
      5,
      106,
      0,
      0,
      1658,
      1660,
      5,
      121,
      0,
      0,
      1659,
      1658,
      1,
      0,
      0,
      0,
      1659,
      1660,
      1,
      0,
      0,
      0,
      1660,
      1661,
      1,
      0,
      0,
      0,
      1661,
      1662,
      5,
      2,
      0,
      0,
      1662,
      1663,
      3,
      244,
      122,
      0,
      1663,
      1664,
      5,
      11,
      0,
      0,
      1664,
      1665,
      3,
      244,
      122,
      0,
      1665,
      1666,
      5,
      3,
      0,
      0,
      1666,
      1667,
      5,
      11,
      0,
      0,
      1667,
      1670,
      3,
      250,
      125,
      0,
      1668,
      1669,
      5,
      11,
      0,
      0,
      1669,
      1671,
      7,
      7,
      0,
      0,
      1670,
      1668,
      1,
      0,
      0,
      0,
      1670,
      1671,
      1,
      0,
      0,
      0,
      1671,
      193,
      1,
      0,
      0,
      0,
      1672,
      1674,
      5,
      106,
      0,
      0,
      1673,
      1675,
      5,
      4,
      0,
      0,
      1674,
      1673,
      1,
      0,
      0,
      0,
      1674,
      1675,
      1,
      0,
      0,
      0,
      1675,
      1676,
      1,
      0,
      0,
      0,
      1676,
      1685,
      3,
      244,
      122,
      0,
      1677,
      1679,
      5,
      11,
      0,
      0,
      1678,
      1680,
      3,
      244,
      122,
      0,
      1679,
      1678,
      1,
      0,
      0,
      0,
      1679,
      1680,
      1,
      0,
      0,
      0,
      1680,
      1683,
      1,
      0,
      0,
      0,
      1681,
      1682,
      5,
      11,
      0,
      0,
      1682,
      1684,
      3,
      250,
      125,
      0,
      1683,
      1681,
      1,
      0,
      0,
      0,
      1683,
      1684,
      1,
      0,
      0,
      0,
      1684,
      1686,
      1,
      0,
      0,
      0,
      1685,
      1677,
      1,
      0,
      0,
      0,
      1685,
      1686,
      1,
      0,
      0,
      0,
      1686,
      195,
      1,
      0,
      0,
      0,
      1687,
      1688,
      5,
      108,
      0,
      0,
      1688,
      1693,
      3,
      250,
      125,
      0,
      1689,
      1690,
      5,
      11,
      0,
      0,
      1690,
      1692,
      3,
      250,
      125,
      0,
      1691,
      1689,
      1,
      0,
      0,
      0,
      1692,
      1695,
      1,
      0,
      0,
      0,
      1693,
      1691,
      1,
      0,
      0,
      0,
      1693,
      1694,
      1,
      0,
      0,
      0,
      1694,
      197,
      1,
      0,
      0,
      0,
      1695,
      1693,
      1,
      0,
      0,
      0,
      1696,
      1697,
      5,
      110,
      0,
      0,
      1697,
      199,
      1,
      0,
      0,
      0,
      1698,
      1701,
      5,
      111,
      0,
      0,
      1699,
      1702,
      5,
      91,
      0,
      0,
      1700,
      1702,
      3,
      126,
      63,
      0,
      1701,
      1699,
      1,
      0,
      0,
      0,
      1701,
      1700,
      1,
      0,
      0,
      0,
      1701,
      1702,
      1,
      0,
      0,
      0,
      1702,
      201,
      1,
      0,
      0,
      0,
      1703,
      1705,
      5,
      112,
      0,
      0,
      1704,
      1706,
      3,
      126,
      63,
      0,
      1705,
      1704,
      1,
      0,
      0,
      0,
      1705,
      1706,
      1,
      0,
      0,
      0,
      1706,
      203,
      1,
      0,
      0,
      0,
      1707,
      1708,
      5,
      113,
      0,
      0,
      1708,
      1709,
      3,
      250,
      125,
      0,
      1709,
      1710,
      5,
      16,
      0,
      0,
      1710,
      1711,
      3,
      244,
      122,
      0,
      1711,
      205,
      1,
      0,
      0,
      0,
      1712,
      1713,
      5,
      117,
      0,
      0,
      1713,
      1714,
      5,
      37,
      0,
      0,
      1714,
      1715,
      3,
      244,
      122,
      0,
      1715,
      1719,
      3,
      208,
      104,
      0,
      1716,
      1718,
      3,
      210,
      105,
      0,
      1717,
      1716,
      1,
      0,
      0,
      0,
      1718,
      1721,
      1,
      0,
      0,
      0,
      1719,
      1717,
      1,
      0,
      0,
      0,
      1719,
      1720,
      1,
      0,
      0,
      0,
      1720,
      1722,
      1,
      0,
      0,
      0,
      1721,
      1719,
      1,
      0,
      0,
      0,
      1722,
      1723,
      3,
      216,
      108,
      0,
      1723,
      207,
      1,
      0,
      0,
      0,
      1724,
      1728,
      5,
      1,
      0,
      0,
      1725,
      1728,
      3,
      198,
      99,
      0,
      1726,
      1728,
      5,
      143,
      0,
      0,
      1727,
      1724,
      1,
      0,
      0,
      0,
      1727,
      1725,
      1,
      0,
      0,
      0,
      1727,
      1726,
      1,
      0,
      0,
      0,
      1728,
      1731,
      1,
      0,
      0,
      0,
      1729,
      1727,
      1,
      0,
      0,
      0,
      1729,
      1730,
      1,
      0,
      0,
      0,
      1730,
      209,
      1,
      0,
      0,
      0,
      1731,
      1729,
      1,
      0,
      0,
      0,
      1732,
      1733,
      3,
      212,
      106,
      0,
      1733,
      1734,
      3,
      2,
      1,
      0,
      1734,
      211,
      1,
      0,
      0,
      0,
      1735,
      1736,
      5,
      37,
      0,
      0,
      1736,
      1741,
      3,
      214,
      107,
      0,
      1737,
      1738,
      5,
      11,
      0,
      0,
      1738,
      1740,
      3,
      214,
      107,
      0,
      1739,
      1737,
      1,
      0,
      0,
      0,
      1740,
      1743,
      1,
      0,
      0,
      0,
      1741,
      1739,
      1,
      0,
      0,
      0,
      1741,
      1742,
      1,
      0,
      0,
      0,
      1742,
      1747,
      1,
      0,
      0,
      0,
      1743,
      1741,
      1,
      0,
      0,
      0,
      1744,
      1745,
      5,
      37,
      0,
      0,
      1745,
      1747,
      5,
      56,
      0,
      0,
      1746,
      1735,
      1,
      0,
      0,
      0,
      1746,
      1744,
      1,
      0,
      0,
      0,
      1747,
      213,
      1,
      0,
      0,
      0,
      1748,
      1749,
      5,
      75,
      0,
      0,
      1749,
      1750,
      7,
      8,
      0,
      0,
      1750,
      1757,
      3,
      244,
      122,
      0,
      1751,
      1752,
      3,
      244,
      122,
      0,
      1752,
      1753,
      5,
      127,
      0,
      0,
      1753,
      1754,
      3,
      244,
      122,
      0,
      1754,
      1757,
      1,
      0,
      0,
      0,
      1755,
      1757,
      3,
      244,
      122,
      0,
      1756,
      1748,
      1,
      0,
      0,
      0,
      1756,
      1751,
      1,
      0,
      0,
      0,
      1756,
      1755,
      1,
      0,
      0,
      0,
      1757,
      215,
      1,
      0,
      0,
      0,
      1758,
      1760,
      3,
      4,
      2,
      0,
      1759,
      1758,
      1,
      0,
      0,
      0,
      1759,
      1760,
      1,
      0,
      0,
      0,
      1760,
      1761,
      1,
      0,
      0,
      0,
      1761,
      1762,
      5,
      60,
      0,
      0,
      1762,
      1763,
      5,
      117,
      0,
      0,
      1763,
      217,
      1,
      0,
      0,
      0,
      1764,
      1766,
      5,
      43,
      0,
      0,
      1765,
      1767,
      5,
      118,
      0,
      0,
      1766,
      1765,
      1,
      0,
      0,
      0,
      1766,
      1767,
      1,
      0,
      0,
      0,
      1767,
      1769,
      1,
      0,
      0,
      0,
      1768,
      1770,
      3,
      220,
      110,
      0,
      1769,
      1768,
      1,
      0,
      0,
      0,
      1769,
      1770,
      1,
      0,
      0,
      0,
      1770,
      1771,
      1,
      0,
      0,
      0,
      1771,
      1776,
      3,
      222,
      111,
      0,
      1772,
      1773,
      5,
      11,
      0,
      0,
      1773,
      1775,
      3,
      222,
      111,
      0,
      1774,
      1772,
      1,
      0,
      0,
      0,
      1775,
      1778,
      1,
      0,
      0,
      0,
      1776,
      1774,
      1,
      0,
      0,
      0,
      1776,
      1777,
      1,
      0,
      0,
      0,
      1777,
      1798,
      1,
      0,
      0,
      0,
      1778,
      1776,
      1,
      0,
      0,
      0,
      1779,
      1780,
      5,
      118,
      0,
      0,
      1780,
      1785,
      3,
      222,
      111,
      0,
      1781,
      1782,
      5,
      11,
      0,
      0,
      1782,
      1784,
      3,
      222,
      111,
      0,
      1783,
      1781,
      1,
      0,
      0,
      0,
      1784,
      1787,
      1,
      0,
      0,
      0,
      1785,
      1783,
      1,
      0,
      0,
      0,
      1785,
      1786,
      1,
      0,
      0,
      0,
      1786,
      1798,
      1,
      0,
      0,
      0,
      1787,
      1785,
      1,
      0,
      0,
      0,
      1788,
      1789,
      5,
      120,
      0,
      0,
      1789,
      1794,
      3,
      222,
      111,
      0,
      1790,
      1791,
      5,
      11,
      0,
      0,
      1791,
      1793,
      3,
      222,
      111,
      0,
      1792,
      1790,
      1,
      0,
      0,
      0,
      1793,
      1796,
      1,
      0,
      0,
      0,
      1794,
      1792,
      1,
      0,
      0,
      0,
      1794,
      1795,
      1,
      0,
      0,
      0,
      1795,
      1798,
      1,
      0,
      0,
      0,
      1796,
      1794,
      1,
      0,
      0,
      0,
      1797,
      1764,
      1,
      0,
      0,
      0,
      1797,
      1779,
      1,
      0,
      0,
      0,
      1797,
      1788,
      1,
      0,
      0,
      0,
      1798,
      219,
      1,
      0,
      0,
      0,
      1799,
      1801,
      5,
      5,
      0,
      0,
      1800,
      1802,
      5,
      141,
      0,
      0,
      1801,
      1800,
      1,
      0,
      0,
      0,
      1801,
      1802,
      1,
      0,
      0,
      0,
      1802,
      1803,
      1,
      0,
      0,
      0,
      1803,
      1804,
      5,
      5,
      0,
      0,
      1804,
      221,
      1,
      0,
      0,
      0,
      1805,
      1807,
      3,
      266,
      133,
      0,
      1806,
      1808,
      3,
      30,
      15,
      0,
      1807,
      1806,
      1,
      0,
      0,
      0,
      1807,
      1808,
      1,
      0,
      0,
      0,
      1808,
      1809,
      1,
      0,
      0,
      0,
      1809,
      1810,
      5,
      33,
      0,
      0,
      1810,
      1811,
      3,
      252,
      126,
      0,
      1811,
      1817,
      1,
      0,
      0,
      0,
      1812,
      1814,
      5,
      141,
      0,
      0,
      1813,
      1815,
      3,
      30,
      15,
      0,
      1814,
      1813,
      1,
      0,
      0,
      0,
      1814,
      1815,
      1,
      0,
      0,
      0,
      1815,
      1817,
      1,
      0,
      0,
      0,
      1816,
      1805,
      1,
      0,
      0,
      0,
      1816,
      1812,
      1,
      0,
      0,
      0,
      1817,
      223,
      1,
      0,
      0,
      0,
      1818,
      1819,
      5,
      114,
      0,
      0,
      1819,
      1838,
      3,
      244,
      122,
      0,
      1820,
      1822,
      5,
      11,
      0,
      0,
      1821,
      1823,
      3,
      244,
      122,
      0,
      1822,
      1821,
      1,
      0,
      0,
      0,
      1822,
      1823,
      1,
      0,
      0,
      0,
      1823,
      1824,
      1,
      0,
      0,
      0,
      1824,
      1826,
      5,
      11,
      0,
      0,
      1825,
      1827,
      3,
      244,
      122,
      0,
      1826,
      1825,
      1,
      0,
      0,
      0,
      1826,
      1827,
      1,
      0,
      0,
      0,
      1827,
      1828,
      1,
      0,
      0,
      0,
      1828,
      1829,
      5,
      11,
      0,
      0,
      1829,
      1839,
      3,
      244,
      122,
      0,
      1830,
      1832,
      5,
      11,
      0,
      0,
      1831,
      1833,
      3,
      244,
      122,
      0,
      1832,
      1831,
      1,
      0,
      0,
      0,
      1832,
      1833,
      1,
      0,
      0,
      0,
      1833,
      1834,
      1,
      0,
      0,
      0,
      1834,
      1835,
      5,
      11,
      0,
      0,
      1835,
      1839,
      3,
      244,
      122,
      0,
      1836,
      1837,
      5,
      11,
      0,
      0,
      1837,
      1839,
      3,
      244,
      122,
      0,
      1838,
      1820,
      1,
      0,
      0,
      0,
      1838,
      1830,
      1,
      0,
      0,
      0,
      1838,
      1836,
      1,
      0,
      0,
      0,
      1838,
      1839,
      1,
      0,
      0,
      0,
      1839,
      225,
      1,
      0,
      0,
      0,
      1840,
      1842,
      5,
      115,
      0,
      0,
      1841,
      1843,
      5,
      4,
      0,
      0,
      1842,
      1841,
      1,
      0,
      0,
      0,
      1842,
      1843,
      1,
      0,
      0,
      0,
      1843,
      1844,
      1,
      0,
      0,
      0,
      1844,
      1845,
      3,
      244,
      122,
      0,
      1845,
      1846,
      5,
      11,
      0,
      0,
      1846,
      1847,
      3,
      244,
      122,
      0,
      1847,
      227,
      1,
      0,
      0,
      0,
      1848,
      1849,
      5,
      122,
      0,
      0,
      1849,
      229,
      1,
      0,
      0,
      0,
      1850,
      1852,
      5,
      130,
      0,
      0,
      1851,
      1853,
      5,
      4,
      0,
      0,
      1852,
      1851,
      1,
      0,
      0,
      0,
      1852,
      1853,
      1,
      0,
      0,
      0,
      1853,
      1854,
      1,
      0,
      0,
      0,
      1854,
      1863,
      3,
      244,
      122,
      0,
      1855,
      1861,
      5,
      11,
      0,
      0,
      1856,
      1862,
      3,
      244,
      122,
      0,
      1857,
      1858,
      3,
      244,
      122,
      0,
      1858,
      1859,
      5,
      127,
      0,
      0,
      1859,
      1860,
      3,
      244,
      122,
      0,
      1860,
      1862,
      1,
      0,
      0,
      0,
      1861,
      1856,
      1,
      0,
      0,
      0,
      1861,
      1857,
      1,
      0,
      0,
      0,
      1862,
      1864,
      1,
      0,
      0,
      0,
      1863,
      1855,
      1,
      0,
      0,
      0,
      1863,
      1864,
      1,
      0,
      0,
      0,
      1864,
      231,
      1,
      0,
      0,
      0,
      1865,
      1892,
      5,
      133,
      0,
      0,
      1866,
      1868,
      5,
      133,
      0,
      0,
      1867,
      1869,
      5,
      114,
      0,
      0,
      1868,
      1867,
      1,
      0,
      0,
      0,
      1868,
      1869,
      1,
      0,
      0,
      0,
      1869,
      1870,
      1,
      0,
      0,
      0,
      1870,
      1871,
      5,
      2,
      0,
      0,
      1871,
      1872,
      3,
      244,
      122,
      0,
      1872,
      1873,
      5,
      11,
      0,
      0,
      1873,
      1874,
      3,
      244,
      122,
      0,
      1874,
      1875,
      5,
      3,
      0,
      0,
      1875,
      1876,
      5,
      8,
      0,
      0,
      1876,
      1877,
      5,
      2,
      0,
      0,
      1877,
      1878,
      3,
      244,
      122,
      0,
      1878,
      1879,
      5,
      11,
      0,
      0,
      1879,
      1880,
      3,
      244,
      122,
      0,
      1880,
      1889,
      5,
      3,
      0,
      0,
      1881,
      1883,
      5,
      11,
      0,
      0,
      1882,
      1884,
      3,
      244,
      122,
      0,
      1883,
      1882,
      1,
      0,
      0,
      0,
      1883,
      1884,
      1,
      0,
      0,
      0,
      1884,
      1885,
      1,
      0,
      0,
      0,
      1885,
      1886,
      5,
      11,
      0,
      0,
      1886,
      1890,
      3,
      244,
      122,
      0,
      1887,
      1888,
      5,
      11,
      0,
      0,
      1888,
      1890,
      3,
      244,
      122,
      0,
      1889,
      1881,
      1,
      0,
      0,
      0,
      1889,
      1887,
      1,
      0,
      0,
      0,
      1889,
      1890,
      1,
      0,
      0,
      0,
      1890,
      1892,
      1,
      0,
      0,
      0,
      1891,
      1865,
      1,
      0,
      0,
      0,
      1891,
      1866,
      1,
      0,
      0,
      0,
      1892,
      233,
      1,
      0,
      0,
      0,
      1893,
      1894,
      5,
      133,
      0,
      0,
      1894,
      1899,
      5,
      103,
      0,
      0,
      1895,
      1896,
      3,
      244,
      122,
      0,
      1896,
      1897,
      5,
      127,
      0,
      0,
      1897,
      1898,
      3,
      244,
      122,
      0,
      1898,
      1900,
      1,
      0,
      0,
      0,
      1899,
      1895,
      1,
      0,
      0,
      0,
      1899,
      1900,
      1,
      0,
      0,
      0,
      1900,
      235,
      1,
      0,
      0,
      0,
      1901,
      1902,
      5,
      135,
      0,
      0,
      1902,
      1903,
      3,
      244,
      122,
      0,
      1903,
      1904,
      3,
      2,
      1,
      0,
      1904,
      1905,
      5,
      134,
      0,
      0,
      1905,
      237,
      1,
      0,
      0,
      0,
      1906,
      1907,
      5,
      136,
      0,
      0,
      1907,
      1925,
      3,
      244,
      122,
      0,
      1908,
      1909,
      5,
      136,
      0,
      0,
      1909,
      1910,
      5,
      11,
      0,
      0,
      1910,
      1925,
      3,
      244,
      122,
      0,
      1911,
      1912,
      5,
      136,
      0,
      0,
      1912,
      1913,
      3,
      244,
      122,
      0,
      1913,
      1914,
      5,
      11,
      0,
      0,
      1914,
      1915,
      3,
      244,
      122,
      0,
      1915,
      1925,
      1,
      0,
      0,
      0,
      1916,
      1917,
      5,
      136,
      0,
      0,
      1917,
      1918,
      3,
      262,
      131,
      0,
      1918,
      1919,
      5,
      11,
      0,
      0,
      1919,
      1920,
      3,
      244,
      122,
      0,
      1920,
      1925,
      1,
      0,
      0,
      0,
      1921,
      1922,
      5,
      136,
      0,
      0,
      1922,
      1923,
      5,
      86,
      0,
      0,
      1923,
      1925,
      3,
      244,
      122,
      0,
      1924,
      1906,
      1,
      0,
      0,
      0,
      1924,
      1908,
      1,
      0,
      0,
      0,
      1924,
      1911,
      1,
      0,
      0,
      0,
      1924,
      1916,
      1,
      0,
      0,
      0,
      1924,
      1921,
      1,
      0,
      0,
      0,
      1925,
      239,
      1,
      0,
      0,
      0,
      1926,
      1942,
      5,
      137,
      0,
      0,
      1927,
      1929,
      5,
      114,
      0,
      0,
      1928,
      1927,
      1,
      0,
      0,
      0,
      1928,
      1929,
      1,
      0,
      0,
      0,
      1929,
      1930,
      1,
      0,
      0,
      0,
      1930,
      1931,
      5,
      2,
      0,
      0,
      1931,
      1932,
      3,
      244,
      122,
      0,
      1932,
      1933,
      5,
      11,
      0,
      0,
      1933,
      1934,
      3,
      244,
      122,
      0,
      1934,
      1935,
      5,
      3,
      0,
      0,
      1935,
      1936,
      5,
      8,
      0,
      0,
      1936,
      1937,
      5,
      2,
      0,
      0,
      1937,
      1938,
      3,
      244,
      122,
      0,
      1938,
      1939,
      5,
      11,
      0,
      0,
      1939,
      1940,
      3,
      244,
      122,
      0,
      1940,
      1941,
      5,
      3,
      0,
      0,
      1941,
      1943,
      1,
      0,
      0,
      0,
      1942,
      1928,
      1,
      0,
      0,
      0,
      1942,
      1943,
      1,
      0,
      0,
      0,
      1943,
      241,
      1,
      0,
      0,
      0,
      1944,
      1964,
      5,
      138,
      0,
      0,
      1945,
      1946,
      5,
      138,
      0,
      0,
      1946,
      1947,
      3,
      262,
      131,
      0,
      1947,
      1948,
      5,
      11,
      0,
      0,
      1948,
      1964,
      1,
      0,
      0,
      0,
      1949,
      1953,
      5,
      138,
      0,
      0,
      1950,
      1951,
      3,
      262,
      131,
      0,
      1951,
      1952,
      5,
      11,
      0,
      0,
      1952,
      1954,
      1,
      0,
      0,
      0,
      1953,
      1950,
      1,
      0,
      0,
      0,
      1953,
      1954,
      1,
      0,
      0,
      0,
      1954,
      1955,
      1,
      0,
      0,
      0,
      1955,
      1960,
      3,
      244,
      122,
      0,
      1956,
      1957,
      7,
      4,
      0,
      0,
      1957,
      1959,
      3,
      244,
      122,
      0,
      1958,
      1956,
      1,
      0,
      0,
      0,
      1959,
      1962,
      1,
      0,
      0,
      0,
      1960,
      1958,
      1,
      0,
      0,
      0,
      1960,
      1961,
      1,
      0,
      0,
      0,
      1961,
      1964,
      1,
      0,
      0,
      0,
      1962,
      1960,
      1,
      0,
      0,
      0,
      1963,
      1944,
      1,
      0,
      0,
      0,
      1963,
      1945,
      1,
      0,
      0,
      0,
      1963,
      1949,
      1,
      0,
      0,
      0,
      1964,
      243,
      1,
      0,
      0,
      0,
      1965,
      1966,
      6,
      122,
      -1,
      0,
      1966,
      1967,
      5,
      2,
      0,
      0,
      1967,
      1968,
      3,
      244,
      122,
      0,
      1968,
      1969,
      5,
      3,
      0,
      0,
      1969,
      1980,
      1,
      0,
      0,
      0,
      1970,
      1971,
      5,
      9,
      0,
      0,
      1971,
      1980,
      3,
      244,
      122,
      16,
      1972,
      1973,
      5,
      8,
      0,
      0,
      1973,
      1980,
      3,
      244,
      122,
      15,
      1974,
      1975,
      5,
      92,
      0,
      0,
      1975,
      1980,
      3,
      244,
      122,
      9,
      1976,
      1980,
      3,
      246,
      123,
      0,
      1977,
      1980,
      3,
      270,
      135,
      0,
      1978,
      1980,
      3,
      250,
      125,
      0,
      1979,
      1965,
      1,
      0,
      0,
      0,
      1979,
      1970,
      1,
      0,
      0,
      0,
      1979,
      1972,
      1,
      0,
      0,
      0,
      1979,
      1974,
      1,
      0,
      0,
      0,
      1979,
      1976,
      1,
      0,
      0,
      0,
      1979,
      1977,
      1,
      0,
      0,
      0,
      1979,
      1978,
      1,
      0,
      0,
      0,
      1980,
      2016,
      1,
      0,
      0,
      0,
      1981,
      1982,
      10,
      17,
      0,
      0,
      1982,
      1983,
      5,
      7,
      0,
      0,
      1983,
      2015,
      3,
      244,
      122,
      18,
      1984,
      1985,
      10,
      14,
      0,
      0,
      1985,
      1986,
      7,
      9,
      0,
      0,
      1986,
      2015,
      3,
      244,
      122,
      15,
      1987,
      1988,
      10,
      13,
      0,
      0,
      1988,
      1989,
      5,
      6,
      0,
      0,
      1989,
      2015,
      3,
      244,
      122,
      14,
      1990,
      1991,
      10,
      12,
      0,
      0,
      1991,
      1992,
      5,
      89,
      0,
      0,
      1992,
      2015,
      3,
      244,
      122,
      13,
      1993,
      1994,
      10,
      11,
      0,
      0,
      1994,
      1995,
      7,
      10,
      0,
      0,
      1995,
      2015,
      3,
      244,
      122,
      12,
      1996,
      1997,
      10,
      10,
      0,
      0,
      1997,
      1998,
      7,
      8,
      0,
      0,
      1998,
      2015,
      3,
      244,
      122,
      11,
      1999,
      2e3,
      10,
      8,
      0,
      0,
      2e3,
      2001,
      5,
      30,
      0,
      0,
      2001,
      2015,
      3,
      244,
      122,
      9,
      2002,
      2003,
      10,
      7,
      0,
      0,
      2003,
      2004,
      5,
      97,
      0,
      0,
      2004,
      2015,
      3,
      244,
      122,
      8,
      2005,
      2006,
      10,
      6,
      0,
      0,
      2006,
      2007,
      5,
      139,
      0,
      0,
      2007,
      2015,
      3,
      244,
      122,
      7,
      2008,
      2009,
      10,
      5,
      0,
      0,
      2009,
      2010,
      5,
      58,
      0,
      0,
      2010,
      2015,
      3,
      244,
      122,
      6,
      2011,
      2012,
      10,
      4,
      0,
      0,
      2012,
      2013,
      5,
      70,
      0,
      0,
      2013,
      2015,
      3,
      244,
      122,
      5,
      2014,
      1981,
      1,
      0,
      0,
      0,
      2014,
      1984,
      1,
      0,
      0,
      0,
      2014,
      1987,
      1,
      0,
      0,
      0,
      2014,
      1990,
      1,
      0,
      0,
      0,
      2014,
      1993,
      1,
      0,
      0,
      0,
      2014,
      1996,
      1,
      0,
      0,
      0,
      2014,
      1999,
      1,
      0,
      0,
      0,
      2014,
      2002,
      1,
      0,
      0,
      0,
      2014,
      2005,
      1,
      0,
      0,
      0,
      2014,
      2008,
      1,
      0,
      0,
      0,
      2014,
      2011,
      1,
      0,
      0,
      0,
      2015,
      2018,
      1,
      0,
      0,
      0,
      2016,
      2014,
      1,
      0,
      0,
      0,
      2016,
      2017,
      1,
      0,
      0,
      0,
      2017,
      245,
      1,
      0,
      0,
      0,
      2018,
      2016,
      1,
      0,
      0,
      0,
      2019,
      2020,
      5,
      72,
      0,
      0,
      2020,
      2021,
      5,
      2,
      0,
      0,
      2021,
      2027,
      3,
      244,
      122,
      0,
      2022,
      2024,
      5,
      11,
      0,
      0,
      2023,
      2025,
      5,
      4,
      0,
      0,
      2024,
      2023,
      1,
      0,
      0,
      0,
      2024,
      2025,
      1,
      0,
      0,
      0,
      2025,
      2026,
      1,
      0,
      0,
      0,
      2026,
      2028,
      3,
      244,
      122,
      0,
      2027,
      2022,
      1,
      0,
      0,
      0,
      2027,
      2028,
      1,
      0,
      0,
      0,
      2028,
      2029,
      1,
      0,
      0,
      0,
      2029,
      2030,
      5,
      3,
      0,
      0,
      2030,
      2088,
      1,
      0,
      0,
      0,
      2031,
      2032,
      5,
      74,
      0,
      0,
      2032,
      2034,
      5,
      2,
      0,
      0,
      2033,
      2035,
      5,
      4,
      0,
      0,
      2034,
      2033,
      1,
      0,
      0,
      0,
      2034,
      2035,
      1,
      0,
      0,
      0,
      2035,
      2036,
      1,
      0,
      0,
      0,
      2036,
      2037,
      3,
      244,
      122,
      0,
      2037,
      2038,
      5,
      3,
      0,
      0,
      2038,
      2088,
      1,
      0,
      0,
      0,
      2039,
      2040,
      5,
      78,
      0,
      0,
      2040,
      2041,
      5,
      2,
      0,
      0,
      2041,
      2042,
      3,
      244,
      122,
      0,
      2042,
      2043,
      5,
      3,
      0,
      0,
      2043,
      2088,
      1,
      0,
      0,
      0,
      2044,
      2045,
      5,
      88,
      0,
      0,
      2045,
      2046,
      5,
      2,
      0,
      0,
      2046,
      2047,
      3,
      244,
      122,
      0,
      2047,
      2048,
      5,
      11,
      0,
      0,
      2048,
      2051,
      3,
      244,
      122,
      0,
      2049,
      2050,
      5,
      11,
      0,
      0,
      2050,
      2052,
      3,
      244,
      122,
      0,
      2051,
      2049,
      1,
      0,
      0,
      0,
      2051,
      2052,
      1,
      0,
      0,
      0,
      2052,
      2053,
      1,
      0,
      0,
      0,
      2053,
      2054,
      5,
      3,
      0,
      0,
      2054,
      2088,
      1,
      0,
      0,
      0,
      2055,
      2056,
      5,
      101,
      0,
      0,
      2056,
      2057,
      5,
      2,
      0,
      0,
      2057,
      2058,
      3,
      244,
      122,
      0,
      2058,
      2059,
      5,
      3,
      0,
      0,
      2059,
      2088,
      1,
      0,
      0,
      0,
      2060,
      2061,
      5,
      102,
      0,
      0,
      2061,
      2062,
      5,
      2,
      0,
      0,
      2062,
      2063,
      3,
      244,
      122,
      0,
      2063,
      2064,
      5,
      3,
      0,
      0,
      2064,
      2088,
      1,
      0,
      0,
      0,
      2065,
      2066,
      5,
      114,
      0,
      0,
      2066,
      2067,
      5,
      2,
      0,
      0,
      2067,
      2068,
      3,
      244,
      122,
      0,
      2068,
      2069,
      5,
      11,
      0,
      0,
      2069,
      2072,
      3,
      244,
      122,
      0,
      2070,
      2071,
      5,
      11,
      0,
      0,
      2071,
      2073,
      3,
      244,
      122,
      0,
      2072,
      2070,
      1,
      0,
      0,
      0,
      2072,
      2073,
      1,
      0,
      0,
      0,
      2073,
      2074,
      1,
      0,
      0,
      0,
      2074,
      2075,
      5,
      3,
      0,
      0,
      2075,
      2088,
      1,
      0,
      0,
      0,
      2076,
      2077,
      5,
      115,
      0,
      0,
      2077,
      2078,
      5,
      2,
      0,
      0,
      2078,
      2079,
      3,
      244,
      122,
      0,
      2079,
      2080,
      5,
      3,
      0,
      0,
      2080,
      2088,
      1,
      0,
      0,
      0,
      2081,
      2082,
      5,
      123,
      0,
      0,
      2082,
      2083,
      5,
      2,
      0,
      0,
      2083,
      2084,
      3,
      244,
      122,
      0,
      2084,
      2085,
      5,
      3,
      0,
      0,
      2085,
      2088,
      1,
      0,
      0,
      0,
      2086,
      2088,
      5,
      129,
      0,
      0,
      2087,
      2019,
      1,
      0,
      0,
      0,
      2087,
      2031,
      1,
      0,
      0,
      0,
      2087,
      2039,
      1,
      0,
      0,
      0,
      2087,
      2044,
      1,
      0,
      0,
      0,
      2087,
      2055,
      1,
      0,
      0,
      0,
      2087,
      2060,
      1,
      0,
      0,
      0,
      2087,
      2065,
      1,
      0,
      0,
      0,
      2087,
      2076,
      1,
      0,
      0,
      0,
      2087,
      2081,
      1,
      0,
      0,
      0,
      2087,
      2086,
      1,
      0,
      0,
      0,
      2088,
      247,
      1,
      0,
      0,
      0,
      2089,
      2098,
      5,
      2,
      0,
      0,
      2090,
      2095,
      3,
      244,
      122,
      0,
      2091,
      2092,
      5,
      11,
      0,
      0,
      2092,
      2094,
      3,
      244,
      122,
      0,
      2093,
      2091,
      1,
      0,
      0,
      0,
      2094,
      2097,
      1,
      0,
      0,
      0,
      2095,
      2093,
      1,
      0,
      0,
      0,
      2095,
      2096,
      1,
      0,
      0,
      0,
      2096,
      2099,
      1,
      0,
      0,
      0,
      2097,
      2095,
      1,
      0,
      0,
      0,
      2098,
      2090,
      1,
      0,
      0,
      0,
      2098,
      2099,
      1,
      0,
      0,
      0,
      2099,
      2100,
      1,
      0,
      0,
      0,
      2100,
      2101,
      5,
      3,
      0,
      0,
      2101,
      249,
      1,
      0,
      0,
      0,
      2102,
      2108,
      7,
      2,
      0,
      0,
      2103,
      2106,
      3,
      248,
      124,
      0,
      2104,
      2105,
      5,
      21,
      0,
      0,
      2105,
      2107,
      5,
      141,
      0,
      0,
      2106,
      2104,
      1,
      0,
      0,
      0,
      2106,
      2107,
      1,
      0,
      0,
      0,
      2107,
      2109,
      1,
      0,
      0,
      0,
      2108,
      2103,
      1,
      0,
      0,
      0,
      2108,
      2109,
      1,
      0,
      0,
      0,
      2109,
      251,
      1,
      0,
      0,
      0,
      2110,
      2119,
      5,
      76,
      0,
      0,
      2111,
      2119,
      5,
      84,
      0,
      0,
      2112,
      2119,
      5,
      119,
      0,
      0,
      2113,
      2119,
      5,
      55,
      0,
      0,
      2114,
      2119,
      5,
      124,
      0,
      0,
      2115,
      2119,
      3,
      264,
      132,
      0,
      2116,
      2119,
      3,
      266,
      133,
      0,
      2117,
      2119,
      3,
      268,
      134,
      0,
      2118,
      2110,
      1,
      0,
      0,
      0,
      2118,
      2111,
      1,
      0,
      0,
      0,
      2118,
      2112,
      1,
      0,
      0,
      0,
      2118,
      2113,
      1,
      0,
      0,
      0,
      2118,
      2114,
      1,
      0,
      0,
      0,
      2118,
      2115,
      1,
      0,
      0,
      0,
      2118,
      2116,
      1,
      0,
      0,
      0,
      2118,
      2117,
      1,
      0,
      0,
      0,
      2119,
      253,
      1,
      0,
      0,
      0,
      2120,
      2128,
      5,
      76,
      0,
      0,
      2121,
      2128,
      5,
      84,
      0,
      0,
      2122,
      2128,
      5,
      119,
      0,
      0,
      2123,
      2128,
      5,
      55,
      0,
      0,
      2124,
      2128,
      5,
      124,
      0,
      0,
      2125,
      2128,
      3,
      266,
      133,
      0,
      2126,
      2128,
      3,
      268,
      134,
      0,
      2127,
      2120,
      1,
      0,
      0,
      0,
      2127,
      2121,
      1,
      0,
      0,
      0,
      2127,
      2122,
      1,
      0,
      0,
      0,
      2127,
      2123,
      1,
      0,
      0,
      0,
      2127,
      2124,
      1,
      0,
      0,
      0,
      2127,
      2125,
      1,
      0,
      0,
      0,
      2127,
      2126,
      1,
      0,
      0,
      0,
      2128,
      255,
      1,
      0,
      0,
      0,
      2129,
      2138,
      5,
      76,
      0,
      0,
      2130,
      2138,
      5,
      84,
      0,
      0,
      2131,
      2138,
      5,
      119,
      0,
      0,
      2132,
      2138,
      5,
      55,
      0,
      0,
      2133,
      2138,
      5,
      124,
      0,
      0,
      2134,
      2138,
      5,
      31,
      0,
      0,
      2135,
      2138,
      3,
      266,
      133,
      0,
      2136,
      2138,
      3,
      268,
      134,
      0,
      2137,
      2129,
      1,
      0,
      0,
      0,
      2137,
      2130,
      1,
      0,
      0,
      0,
      2137,
      2131,
      1,
      0,
      0,
      0,
      2137,
      2132,
      1,
      0,
      0,
      0,
      2137,
      2133,
      1,
      0,
      0,
      0,
      2137,
      2134,
      1,
      0,
      0,
      0,
      2137,
      2135,
      1,
      0,
      0,
      0,
      2137,
      2136,
      1,
      0,
      0,
      0,
      2138,
      257,
      1,
      0,
      0,
      0,
      2139,
      2140,
      7,
      11,
      0,
      0,
      2140,
      259,
      1,
      0,
      0,
      0,
      2141,
      2149,
      5,
      76,
      0,
      0,
      2142,
      2149,
      5,
      84,
      0,
      0,
      2143,
      2149,
      5,
      119,
      0,
      0,
      2144,
      2149,
      5,
      55,
      0,
      0,
      2145,
      2149,
      3,
      264,
      132,
      0,
      2146,
      2149,
      3,
      266,
      133,
      0,
      2147,
      2149,
      3,
      268,
      134,
      0,
      2148,
      2141,
      1,
      0,
      0,
      0,
      2148,
      2142,
      1,
      0,
      0,
      0,
      2148,
      2143,
      1,
      0,
      0,
      0,
      2148,
      2144,
      1,
      0,
      0,
      0,
      2148,
      2145,
      1,
      0,
      0,
      0,
      2148,
      2146,
      1,
      0,
      0,
      0,
      2148,
      2147,
      1,
      0,
      0,
      0,
      2149,
      261,
      1,
      0,
      0,
      0,
      2150,
      2151,
      5,
      4,
      0,
      0,
      2151,
      2152,
      3,
      244,
      122,
      0,
      2152,
      263,
      1,
      0,
      0,
      0,
      2153,
      2154,
      5,
      124,
      0,
      0,
      2154,
      2155,
      5,
      10,
      0,
      0,
      2155,
      2156,
      7,
      12,
      0,
      0,
      2156,
      265,
      1,
      0,
      0,
      0,
      2157,
      2158,
      5,
      141,
      0,
      0,
      2158,
      267,
      1,
      0,
      0,
      0,
      2159,
      2160,
      5,
      140,
      0,
      0,
      2160,
      269,
      1,
      0,
      0,
      0,
      2161,
      2169,
      5,
      25,
      0,
      0,
      2162,
      2169,
      5,
      26,
      0,
      0,
      2163,
      2165,
      7,
      13,
      0,
      0,
      2164,
      2166,
      7,
      14,
      0,
      0,
      2165,
      2164,
      1,
      0,
      0,
      0,
      2165,
      2166,
      1,
      0,
      0,
      0,
      2166,
      2169,
      1,
      0,
      0,
      0,
      2167,
      2169,
      5,
      27,
      0,
      0,
      2168,
      2161,
      1,
      0,
      0,
      0,
      2168,
      2162,
      1,
      0,
      0,
      0,
      2168,
      2163,
      1,
      0,
      0,
      0,
      2168,
      2167,
      1,
      0,
      0,
      0,
      2169,
      271,
      1,
      0,
      0,
      0,
      276,
      273,
      283,
      291,
      293,
      300,
      309,
      317,
      322,
      326,
      332,
      339,
      343,
      347,
      353,
      356,
      362,
      368,
      439,
      446,
      450,
      453,
      460,
      465,
      472,
      474,
      480,
      484,
      487,
      495,
      502,
      510,
      516,
      519,
      522,
      532,
      537,
      544,
      546,
      550,
      555,
      563,
      574,
      578,
      583,
      591,
      597,
      603,
      607,
      613,
      620,
      628,
      633,
      637,
      643,
      650,
      661,
      664,
      667,
      673,
      681,
      687,
      692,
      698,
      700,
      707,
      714,
      717,
      729,
      733,
      735,
      742,
      750,
      753,
      761,
      771,
      801,
      805,
      816,
      820,
      824,
      830,
      834,
      840,
      846,
      848,
      852,
      856,
      862,
      866,
      870,
      874,
      877,
      881,
      886,
      891,
      895,
      900,
      905,
      907,
      915,
      930,
      936,
      942,
      950,
      959,
      968,
      977,
      986,
      989,
      994,
      998,
      1005,
      1010,
      1017,
      1020,
      1024,
      1031,
      1033,
      1041,
      1049,
      1068,
      1074,
      1083,
      1092,
      1107,
      1112,
      1116,
      1120,
      1129,
      1141,
      1146,
      1150,
      1152,
      1162,
      1170,
      1177,
      1179,
      1186,
      1190,
      1194,
      1198,
      1205,
      1216,
      1219,
      1223,
      1238,
      1242,
      1250,
      1254,
      1263,
      1267,
      1273,
      1279,
      1282,
      1284,
      1291,
      1295,
      1304,
      1308,
      1312,
      1316,
      1320,
      1325,
      1329,
      1333,
      1338,
      1342,
      1347,
      1352,
      1356,
      1365,
      1367,
      1372,
      1375,
      1377,
      1385,
      1389,
      1392,
      1394,
      1409,
      1426,
      1472,
      1484,
      1496,
      1503,
      1509,
      1513,
      1516,
      1520,
      1527,
      1535,
      1545,
      1549,
      1558,
      1562,
      1568,
      1574,
      1585,
      1592,
      1601,
      1607,
      1610,
      1614,
      1617,
      1619,
      1626,
      1632,
      1636,
      1639,
      1641,
      1646,
      1655,
      1659,
      1670,
      1674,
      1679,
      1683,
      1685,
      1693,
      1701,
      1705,
      1719,
      1727,
      1729,
      1741,
      1746,
      1756,
      1759,
      1766,
      1769,
      1776,
      1785,
      1794,
      1797,
      1801,
      1807,
      1814,
      1816,
      1822,
      1826,
      1832,
      1838,
      1842,
      1852,
      1861,
      1863,
      1868,
      1883,
      1889,
      1891,
      1899,
      1924,
      1928,
      1942,
      1953,
      1960,
      1963,
      1979,
      2014,
      2016,
      2024,
      2027,
      2034,
      2051,
      2072,
      2087,
      2095,
      2098,
      2106,
      2108,
      2118,
      2127,
      2137,
      2148,
      2165,
      2168
    ];
    static __ATN;
    static get _ATN() {
      if (!_QBasicParser.__ATN) {
        _QBasicParser.__ATN = new ATNDeserializer().deserialize(_QBasicParser._serializedATN);
      }
      return _QBasicParser.__ATN;
    }
    static vocabulary = new Vocabulary(_QBasicParser.literalNames, _QBasicParser.symbolicNames, []);
    get vocabulary() {
      return _QBasicParser.vocabulary;
    }
    static decisionsToDFA = _QBasicParser._ATN.decisionToState.map((ds, index) => new DFA(ds, index));
  };
  var ProgramContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    EOF() {
      return this.getToken(QBasicParser.EOF, 0);
    }
    NL(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NL);
      } else {
        return this.getToken(QBasicParser.NL, i);
      }
    }
    statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(StatementContext);
      }
      return this.getRuleContext(i, StatementContext);
    }
    declare_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Declare_statementContext);
      }
      return this.getRuleContext(i, Declare_statementContext);
    }
    def_fn_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Def_fn_statementContext);
      }
      return this.getRuleContext(i, Def_fn_statementContext);
    }
    function_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Function_statementContext);
      }
      return this.getRuleContext(i, Function_statementContext);
    }
    if_block_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(If_block_statementContext);
      }
      return this.getRuleContext(i, If_block_statementContext);
    }
    option_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Option_statementContext);
      }
      return this.getRuleContext(i, Option_statementContext);
    }
    sub_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Sub_statementContext);
      }
      return this.getRuleContext(i, Sub_statementContext);
    }
    type_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Type_statementContext);
      }
      return this.getRuleContext(i, Type_statementContext);
    }
    label(i) {
      if (i === void 0) {
        return this.getRuleContexts(LabelContext);
      }
      return this.getRuleContext(i, LabelContext);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_program;
    }
    enterRule(listener) {
      if (listener.enterProgram) {
        listener.enterProgram(this);
      }
    }
    exitRule(listener) {
      if (listener.exitProgram) {
        listener.exitProgram(this);
      }
    }
  };
  var BlockContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(StatementContext);
      }
      return this.getRuleContext(i, StatementContext);
    }
    NL(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NL);
      } else {
        return this.getToken(QBasicParser.NL, i);
      }
    }
    if_block_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(If_block_statementContext);
      }
      return this.getRuleContext(i, If_block_statementContext);
    }
    label(i) {
      if (i === void 0) {
        return this.getRuleContexts(LabelContext);
      }
      return this.getRuleContext(i, LabelContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_block;
    }
    enterRule(listener) {
      if (listener.enterBlock) {
        listener.enterBlock(this);
      }
    }
    exitRule(listener) {
      if (listener.exitBlock) {
        listener.exitBlock(this);
      }
    }
  };
  var LabelContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    line_number() {
      return this.getRuleContext(0, Line_numberContext);
    }
    text_label() {
      return this.getRuleContext(0, Text_labelContext);
    }
    COLON() {
      return this.getToken(QBasicParser.COLON, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_label;
    }
    enterRule(listener) {
      if (listener.enterLabel) {
        listener.enterLabel(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLabel) {
        listener.exitLabel(this);
      }
    }
  };
  var Line_numberContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DIGITS() {
      return this.getToken(QBasicParser.DIGITS, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_line_number;
    }
    enterRule(listener) {
      if (listener.enterLine_number) {
        listener.enterLine_number(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLine_number) {
        listener.exitLine_number(this);
      }
    }
  };
  var Text_labelContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    untyped_fnid() {
      return this.getRuleContext(0, Untyped_fnidContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_text_label;
    }
    enterRule(listener) {
      if (listener.enterText_label) {
        listener.enterText_label(this);
      }
    }
    exitRule(listener) {
      if (listener.exitText_label) {
        listener.exitText_label(this);
      }
    }
  };
  var StatementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    assignment_statement() {
      return this.getRuleContext(0, Assignment_statementContext);
    }
    call_statement() {
      return this.getRuleContext(0, Call_statementContext);
    }
    call_absolute_statement() {
      return this.getRuleContext(0, Call_absolute_statementContext);
    }
    circle_statement() {
      return this.getRuleContext(0, Circle_statementContext);
    }
    clear_statement() {
      return this.getRuleContext(0, Clear_statementContext);
    }
    close_statement() {
      return this.getRuleContext(0, Close_statementContext);
    }
    color_statement() {
      return this.getRuleContext(0, Color_statementContext);
    }
    const_statement() {
      return this.getRuleContext(0, Const_statementContext);
    }
    data_statement() {
      return this.getRuleContext(0, Data_statementContext);
    }
    def_seg_statement() {
      return this.getRuleContext(0, Def_seg_statementContext);
    }
    deftype_statement() {
      return this.getRuleContext(0, Deftype_statementContext);
    }
    dim_statement() {
      return this.getRuleContext(0, Dim_statementContext);
    }
    do_loop_statement() {
      return this.getRuleContext(0, Do_loop_statementContext);
    }
    error_statement() {
      return this.getRuleContext(0, Error_statementContext);
    }
    event_control_statement() {
      return this.getRuleContext(0, Event_control_statementContext);
    }
    end_statement() {
      return this.getRuleContext(0, End_statementContext);
    }
    exit_statement() {
      return this.getRuleContext(0, Exit_statementContext);
    }
    field_statement() {
      return this.getRuleContext(0, Field_statementContext);
    }
    for_next_statement() {
      return this.getRuleContext(0, For_next_statementContext);
    }
    get_graphics_statement() {
      return this.getRuleContext(0, Get_graphics_statementContext);
    }
    get_io_statement() {
      return this.getRuleContext(0, Get_io_statementContext);
    }
    gosub_statement() {
      return this.getRuleContext(0, Gosub_statementContext);
    }
    goto_statement() {
      return this.getRuleContext(0, Goto_statementContext);
    }
    if_inline_statement() {
      return this.getRuleContext(0, If_inline_statementContext);
    }
    input_statement() {
      return this.getRuleContext(0, Input_statementContext);
    }
    ioctl_statement() {
      return this.getRuleContext(0, Ioctl_statementContext);
    }
    key_statement() {
      return this.getRuleContext(0, Key_statementContext);
    }
    line_statement() {
      return this.getRuleContext(0, Line_statementContext);
    }
    line_input_statement() {
      return this.getRuleContext(0, Line_input_statementContext);
    }
    locate_statement() {
      return this.getRuleContext(0, Locate_statementContext);
    }
    lock_statement() {
      return this.getRuleContext(0, Lock_statementContext);
    }
    lprint_statement() {
      return this.getRuleContext(0, Lprint_statementContext);
    }
    lprint_using_statement() {
      return this.getRuleContext(0, Lprint_using_statementContext);
    }
    lset_statement() {
      return this.getRuleContext(0, Lset_statementContext);
    }
    mid_statement() {
      return this.getRuleContext(0, Mid_statementContext);
    }
    name_statement() {
      return this.getRuleContext(0, Name_statementContext);
    }
    on_error_statement() {
      return this.getRuleContext(0, On_error_statementContext);
    }
    on_event_gosub_statement() {
      return this.getRuleContext(0, On_event_gosub_statementContext);
    }
    on_expr_gosub_statement() {
      return this.getRuleContext(0, On_expr_gosub_statementContext);
    }
    on_expr_goto_statement() {
      return this.getRuleContext(0, On_expr_goto_statementContext);
    }
    open_statement() {
      return this.getRuleContext(0, Open_statementContext);
    }
    open_legacy_statement() {
      return this.getRuleContext(0, Open_legacy_statementContext);
    }
    paint_statement() {
      return this.getRuleContext(0, Paint_statementContext);
    }
    palette_statement() {
      return this.getRuleContext(0, Palette_statementContext);
    }
    play_statement() {
      return this.getRuleContext(0, Play_statementContext);
    }
    preset_statement() {
      return this.getRuleContext(0, Preset_statementContext);
    }
    print_statement() {
      return this.getRuleContext(0, Print_statementContext);
    }
    print_using_statement() {
      return this.getRuleContext(0, Print_using_statementContext);
    }
    pset_statement() {
      return this.getRuleContext(0, Pset_statementContext);
    }
    put_graphics_statement() {
      return this.getRuleContext(0, Put_graphics_statementContext);
    }
    put_io_statement() {
      return this.getRuleContext(0, Put_io_statementContext);
    }
    read_statement() {
      return this.getRuleContext(0, Read_statementContext);
    }
    rem_statement() {
      return this.getRuleContext(0, Rem_statementContext);
    }
    resume_statement() {
      return this.getRuleContext(0, Resume_statementContext);
    }
    return_statement() {
      return this.getRuleContext(0, Return_statementContext);
    }
    rset_statement() {
      return this.getRuleContext(0, Rset_statementContext);
    }
    scope_statement() {
      return this.getRuleContext(0, Scope_statementContext);
    }
    screen_statement() {
      return this.getRuleContext(0, Screen_statementContext);
    }
    seek_statement() {
      return this.getRuleContext(0, Seek_statementContext);
    }
    select_case_statement() {
      return this.getRuleContext(0, Select_case_statementContext);
    }
    stop_statement() {
      return this.getRuleContext(0, Stop_statementContext);
    }
    unlock_statement() {
      return this.getRuleContext(0, Unlock_statementContext);
    }
    view_statement() {
      return this.getRuleContext(0, View_statementContext);
    }
    view_print_statement() {
      return this.getRuleContext(0, View_print_statementContext);
    }
    while_wend_statement() {
      return this.getRuleContext(0, While_wend_statementContext);
    }
    width_statement() {
      return this.getRuleContext(0, Width_statementContext);
    }
    window_statement() {
      return this.getRuleContext(0, Window_statementContext);
    }
    write_statement() {
      return this.getRuleContext(0, Write_statementContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_statement;
    }
    enterRule(listener) {
      if (listener.enterStatement) {
        listener.enterStatement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitStatement) {
        listener.exitStatement(this);
      }
    }
  };
  var Declare_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DECLARE() {
      return this.getToken(QBasicParser.DECLARE, 0);
    }
    SUB() {
      return this.getToken(QBasicParser.SUB, 0);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    FUNCTION() {
      return this.getToken(QBasicParser.FUNCTION, 0);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    declare_parameter_list() {
      return this.getRuleContext(0, Declare_parameter_listContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_declare_statement;
    }
    enterRule(listener) {
      if (listener.enterDeclare_statement) {
        listener.enterDeclare_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDeclare_statement) {
        listener.exitDeclare_statement(this);
      }
    }
  };
  var Declare_parameter_listContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    declare_parameter(i) {
      if (i === void 0) {
        return this.getRuleContexts(Declare_parameterContext);
      }
      return this.getRuleContext(i, Declare_parameterContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_declare_parameter_list;
    }
    enterRule(listener) {
      if (listener.enterDeclare_parameter_list) {
        listener.enterDeclare_parameter_list(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDeclare_parameter_list) {
        listener.exitDeclare_parameter_list(this);
      }
    }
  };
  var Declare_parameterContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    type_name_for_declare_parameter() {
      return this.getRuleContext(0, Type_name_for_declare_parameterContext);
    }
    array_declaration() {
      return this.getRuleContext(0, Array_declarationContext);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_declare_parameter;
    }
    enterRule(listener) {
      if (listener.enterDeclare_parameter) {
        listener.enterDeclare_parameter(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDeclare_parameter) {
        listener.exitDeclare_parameter(this);
      }
    }
  };
  var Def_fn_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DEF(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.DEF);
      } else {
        return this.getToken(QBasicParser.DEF, i);
      }
    }
    FNID() {
      return this.getToken(QBasicParser.FNID, 0);
    }
    FN() {
      return this.getToken(QBasicParser.FN, 0);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    block() {
      return this.getRuleContext(0, BlockContext);
    }
    END() {
      return this.getToken(QBasicParser.END, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    def_fn_parameter_list() {
      return this.getRuleContext(0, Def_fn_parameter_listContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_def_fn_statement;
    }
    enterRule(listener) {
      if (listener.enterDef_fn_statement) {
        listener.enterDef_fn_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDef_fn_statement) {
        listener.exitDef_fn_statement(this);
      }
    }
  };
  var Def_fn_parameter_listContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    def_fn_parameter(i) {
      if (i === void 0) {
        return this.getRuleContexts(Def_fn_parameterContext);
      }
      return this.getRuleContext(i, Def_fn_parameterContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_def_fn_parameter_list;
    }
    enterRule(listener) {
      if (listener.enterDef_fn_parameter_list) {
        listener.enterDef_fn_parameter_list(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDef_fn_parameter_list) {
        listener.exitDef_fn_parameter_list(this);
      }
    }
  };
  var Def_fn_parameterContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    type_name_for_def_fn_parameter() {
      return this.getRuleContext(0, Type_name_for_def_fn_parameterContext);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_def_fn_parameter;
    }
    enterRule(listener) {
      if (listener.enterDef_fn_parameter) {
        listener.enterDef_fn_parameter(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDef_fn_parameter) {
        listener.exitDef_fn_parameter(this);
      }
    }
  };
  var Function_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    FUNCTION() {
      return this.getToken(QBasicParser.FUNCTION, 0);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    block() {
      return this.getRuleContext(0, BlockContext);
    }
    end_function_statement() {
      return this.getRuleContext(0, End_function_statementContext);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    STATIC() {
      return this.getToken(QBasicParser.STATIC, 0);
    }
    parameter_list() {
      return this.getRuleContext(0, Parameter_listContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_function_statement;
    }
    enterRule(listener) {
      if (listener.enterFunction_statement) {
        listener.enterFunction_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitFunction_statement) {
        listener.exitFunction_statement(this);
      }
    }
  };
  var Parameter_listContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    parameter(i) {
      if (i === void 0) {
        return this.getRuleContexts(ParameterContext);
      }
      return this.getRuleContext(i, ParameterContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_parameter_list;
    }
    enterRule(listener) {
      if (listener.enterParameter_list) {
        listener.enterParameter_list(this);
      }
    }
    exitRule(listener) {
      if (listener.exitParameter_list) {
        listener.exitParameter_list(this);
      }
    }
  };
  var ParameterContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    type_name_for_parameter() {
      return this.getRuleContext(0, Type_name_for_parameterContext);
    }
    array_declaration() {
      return this.getRuleContext(0, Array_declarationContext);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_parameter;
    }
    enterRule(listener) {
      if (listener.enterParameter) {
        listener.enterParameter(this);
      }
    }
    exitRule(listener) {
      if (listener.exitParameter) {
        listener.exitParameter(this);
      }
    }
  };
  var Array_declarationContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    DIGITS() {
      return this.getToken(QBasicParser.DIGITS, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_array_declaration;
    }
    enterRule(listener) {
      if (listener.enterArray_declaration) {
        listener.enterArray_declaration(this);
      }
    }
    exitRule(listener) {
      if (listener.exitArray_declaration) {
        listener.exitArray_declaration(this);
      }
    }
  };
  var End_function_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    END() {
      return this.getToken(QBasicParser.END, 0);
    }
    FUNCTION() {
      return this.getToken(QBasicParser.FUNCTION, 0);
    }
    label() {
      return this.getRuleContext(0, LabelContext);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(StatementContext);
      }
      return this.getRuleContext(i, StatementContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_end_function_statement;
    }
    enterRule(listener) {
      if (listener.enterEnd_function_statement) {
        listener.enterEnd_function_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitEnd_function_statement) {
        listener.exitEnd_function_statement(this);
      }
    }
  };
  var If_block_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    IF() {
      return this.getToken(QBasicParser.IF, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    THEN() {
      return this.getToken(QBasicParser.THEN, 0);
    }
    NL() {
      return this.getToken(QBasicParser.NL, 0);
    }
    then_block() {
      return this.getRuleContext(0, Then_blockContext);
    }
    end_if_statement() {
      return this.getRuleContext(0, End_if_statementContext);
    }
    elseif_block_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Elseif_block_statementContext);
      }
      return this.getRuleContext(i, Elseif_block_statementContext);
    }
    else_block_statement() {
      return this.getRuleContext(0, Else_block_statementContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_if_block_statement;
    }
    enterRule(listener) {
      if (listener.enterIf_block_statement) {
        listener.enterIf_block_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitIf_block_statement) {
        listener.exitIf_block_statement(this);
      }
    }
  };
  var Elseif_block_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ELSEIF() {
      return this.getToken(QBasicParser.ELSEIF, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    THEN() {
      return this.getToken(QBasicParser.THEN, 0);
    }
    else_block() {
      return this.getRuleContext(0, Else_blockContext);
    }
    label() {
      return this.getRuleContext(0, LabelContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_elseif_block_statement;
    }
    enterRule(listener) {
      if (listener.enterElseif_block_statement) {
        listener.enterElseif_block_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitElseif_block_statement) {
        listener.exitElseif_block_statement(this);
      }
    }
  };
  var Else_block_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ELSE() {
      return this.getToken(QBasicParser.ELSE, 0);
    }
    else_block() {
      return this.getRuleContext(0, Else_blockContext);
    }
    label() {
      return this.getRuleContext(0, LabelContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_else_block_statement;
    }
    enterRule(listener) {
      if (listener.enterElse_block_statement) {
        listener.enterElse_block_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitElse_block_statement) {
        listener.exitElse_block_statement(this);
      }
    }
  };
  var End_if_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    END() {
      return this.getToken(QBasicParser.END, 0);
    }
    IF() {
      return this.getToken(QBasicParser.IF, 0);
    }
    label() {
      return this.getRuleContext(0, LabelContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_end_if_statement;
    }
    enterRule(listener) {
      if (listener.enterEnd_if_statement) {
        listener.enterEnd_if_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitEnd_if_statement) {
        listener.exitEnd_if_statement(this);
      }
    }
  };
  var Then_blockContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    NL(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NL);
      } else {
        return this.getToken(QBasicParser.NL, i);
      }
    }
    statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(StatementContext);
      }
      return this.getRuleContext(i, StatementContext);
    }
    if_block_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(If_block_statementContext);
      }
      return this.getRuleContext(i, If_block_statementContext);
    }
    label(i) {
      if (i === void 0) {
        return this.getRuleContexts(LabelContext);
      }
      return this.getRuleContext(i, LabelContext);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_then_block;
    }
    enterRule(listener) {
      if (listener.enterThen_block) {
        listener.enterThen_block(this);
      }
    }
    exitRule(listener) {
      if (listener.exitThen_block) {
        listener.exitThen_block(this);
      }
    }
  };
  var Else_blockContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(StatementContext);
      }
      return this.getRuleContext(i, StatementContext);
    }
    NL(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NL);
      } else {
        return this.getToken(QBasicParser.NL, i);
      }
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    if_block_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(If_block_statementContext);
      }
      return this.getRuleContext(i, If_block_statementContext);
    }
    label(i) {
      if (i === void 0) {
        return this.getRuleContexts(LabelContext);
      }
      return this.getRuleContext(i, LabelContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_else_block;
    }
    enterRule(listener) {
      if (listener.enterElse_block) {
        listener.enterElse_block(this);
      }
    }
    exitRule(listener) {
      if (listener.exitElse_block) {
        listener.exitElse_block(this);
      }
    }
  };
  var Option_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    OPTION() {
      return this.getToken(QBasicParser.OPTION, 0);
    }
    BASE() {
      return this.getToken(QBasicParser.BASE, 0);
    }
    DIGITS() {
      return this.getToken(QBasicParser.DIGITS, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_option_statement;
    }
    enterRule(listener) {
      if (listener.enterOption_statement) {
        listener.enterOption_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOption_statement) {
        listener.exitOption_statement(this);
      }
    }
  };
  var Sub_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    SUB() {
      return this.getToken(QBasicParser.SUB, 0);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    block() {
      return this.getRuleContext(0, BlockContext);
    }
    end_sub_statement() {
      return this.getRuleContext(0, End_sub_statementContext);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    STATIC() {
      return this.getToken(QBasicParser.STATIC, 0);
    }
    parameter_list() {
      return this.getRuleContext(0, Parameter_listContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_sub_statement;
    }
    enterRule(listener) {
      if (listener.enterSub_statement) {
        listener.enterSub_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitSub_statement) {
        listener.exitSub_statement(this);
      }
    }
  };
  var End_sub_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    END() {
      return this.getToken(QBasicParser.END, 0);
    }
    SUB() {
      return this.getToken(QBasicParser.SUB, 0);
    }
    label() {
      return this.getRuleContext(0, LabelContext);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(StatementContext);
      }
      return this.getRuleContext(i, StatementContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_end_sub_statement;
    }
    enterRule(listener) {
      if (listener.enterEnd_sub_statement) {
        listener.enterEnd_sub_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitEnd_sub_statement) {
        listener.exitEnd_sub_statement(this);
      }
    }
  };
  var Type_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    TYPE(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.TYPE);
      } else {
        return this.getToken(QBasicParser.TYPE, i);
      }
    }
    END() {
      return this.getToken(QBasicParser.END, 0);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    untyped_fnid() {
      return this.getRuleContext(0, Untyped_fnidContext);
    }
    rem_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Rem_statementContext);
      }
      return this.getRuleContext(i, Rem_statementContext);
    }
    NL(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NL);
      } else {
        return this.getToken(QBasicParser.NL, i);
      }
    }
    type_element(i) {
      if (i === void 0) {
        return this.getRuleContexts(Type_elementContext);
      }
      return this.getRuleContext(i, Type_elementContext);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_type_statement;
    }
    enterRule(listener) {
      if (listener.enterType_statement) {
        listener.enterType_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitType_statement) {
        listener.exitType_statement(this);
      }
    }
  };
  var Type_elementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    type_name_for_type_element() {
      return this.getRuleContext(0, Type_name_for_type_elementContext);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    untyped_fnid() {
      return this.getRuleContext(0, Untyped_fnidContext);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    NL(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NL);
      } else {
        return this.getToken(QBasicParser.NL, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_type_element;
    }
    enterRule(listener) {
      if (listener.enterType_element) {
        listener.enterType_element(this);
      }
    }
    exitRule(listener) {
      if (listener.exitType_element) {
        listener.exitType_element(this);
      }
    }
  };
  var Assignment_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    LET() {
      return this.getToken(QBasicParser.LET, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_assignment_statement;
    }
    enterRule(listener) {
      if (listener.enterAssignment_statement) {
        listener.enterAssignment_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitAssignment_statement) {
        listener.exitAssignment_statement(this);
      }
    }
  };
  var Call_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    CALL() {
      return this.getToken(QBasicParser.CALL, 0);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    call_argument_list() {
      return this.getRuleContext(0, Call_argument_listContext);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_call_statement;
    }
    enterRule(listener) {
      if (listener.enterCall_statement) {
        listener.enterCall_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCall_statement) {
        listener.exitCall_statement(this);
      }
    }
  };
  var Call_argument_listContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    call_argument(i) {
      if (i === void 0) {
        return this.getRuleContexts(Call_argumentContext);
      }
      return this.getRuleContext(i, Call_argumentContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_call_argument_list;
    }
    enterRule(listener) {
      if (listener.enterCall_argument_list) {
        listener.enterCall_argument_list(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCall_argument_list) {
        listener.exitCall_argument_list(this);
      }
    }
  };
  var Call_argumentContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    args_or_indices() {
      return this.getRuleContext(0, Args_or_indicesContext);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_call_argument;
    }
    enterRule(listener) {
      if (listener.enterCall_argument) {
        listener.enterCall_argument(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCall_argument) {
        listener.exitCall_argument(this);
      }
    }
  };
  var Call_absolute_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    CALL() {
      return this.getToken(QBasicParser.CALL, 0);
    }
    ABSOLUTE() {
      return this.getToken(QBasicParser.ABSOLUTE, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    call_absolute_argument_list() {
      return this.getRuleContext(0, Call_absolute_argument_listContext);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_call_absolute_statement;
    }
    enterRule(listener) {
      if (listener.enterCall_absolute_statement) {
        listener.enterCall_absolute_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCall_absolute_statement) {
        listener.exitCall_absolute_statement(this);
      }
    }
  };
  var Call_absolute_argument_listContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_call_absolute_argument_list;
    }
    enterRule(listener) {
      if (listener.enterCall_absolute_argument_list) {
        listener.enterCall_absolute_argument_list(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCall_absolute_argument_list) {
        listener.exitCall_absolute_argument_list(this);
      }
    }
  };
  var Error_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ERROR() {
      return this.getToken(QBasicParser.ERROR, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_error_statement;
    }
    enterRule(listener) {
      if (listener.enterError_statement) {
        listener.enterError_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitError_statement) {
        listener.exitError_statement(this);
      }
    }
  };
  var Event_control_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    COM() {
      return this.getToken(QBasicParser.COM, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    ON() {
      return this.getToken(QBasicParser.ON, 0);
    }
    OFF() {
      return this.getToken(QBasicParser.OFF, 0);
    }
    STOP() {
      return this.getToken(QBasicParser.STOP, 0);
    }
    KEY() {
      return this.getToken(QBasicParser.KEY, 0);
    }
    PEN() {
      return this.getToken(QBasicParser.PEN, 0);
    }
    PLAY() {
      return this.getToken(QBasicParser.PLAY, 0);
    }
    STRIG() {
      return this.getToken(QBasicParser.STRIG, 0);
    }
    TIMER() {
      return this.getToken(QBasicParser.TIMER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_event_control_statement;
    }
    enterRule(listener) {
      if (listener.enterEvent_control_statement) {
        listener.enterEvent_control_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitEvent_control_statement) {
        listener.exitEvent_control_statement(this);
      }
    }
  };
  var Circle_statementContext = class extends ParserRuleContext {
    _x;
    _y;
    _radius;
    _color;
    _start;
    _end;
    _aspect;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    CIRCLE() {
      return this.getToken(QBasicParser.CIRCLE, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    STEP() {
      return this.getToken(QBasicParser.STEP, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_circle_statement;
    }
    enterRule(listener) {
      if (listener.enterCircle_statement) {
        listener.enterCircle_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCircle_statement) {
        listener.exitCircle_statement(this);
      }
    }
  };
  var Clear_statementContext = class extends ParserRuleContext {
    _stacksize;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    CLEAR() {
      return this.getToken(QBasicParser.CLEAR, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_clear_statement;
    }
    enterRule(listener) {
      if (listener.enterClear_statement) {
        listener.enterClear_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitClear_statement) {
        listener.exitClear_statement(this);
      }
    }
  };
  var Close_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    CLOSE() {
      return this.getToken(QBasicParser.CLOSE, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    NUMBER(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NUMBER);
      } else {
        return this.getToken(QBasicParser.NUMBER, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_close_statement;
    }
    enterRule(listener) {
      if (listener.enterClose_statement) {
        listener.enterClose_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitClose_statement) {
        listener.exitClose_statement(this);
      }
    }
  };
  var Color_statementContext = class extends ParserRuleContext {
    _arg1;
    _arg2;
    _arg3;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    COLOR() {
      return this.getToken(QBasicParser.COLOR, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_color_statement;
    }
    enterRule(listener) {
      if (listener.enterColor_statement) {
        listener.enterColor_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitColor_statement) {
        listener.exitColor_statement(this);
      }
    }
  };
  var Const_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    CONST() {
      return this.getToken(QBasicParser.CONST, 0);
    }
    const_assignment(i) {
      if (i === void 0) {
        return this.getRuleContexts(Const_assignmentContext);
      }
      return this.getRuleContext(i, Const_assignmentContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_const_statement;
    }
    enterRule(listener) {
      if (listener.enterConst_statement) {
        listener.enterConst_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitConst_statement) {
        listener.exitConst_statement(this);
      }
    }
  };
  var Const_assignmentContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    const_expr() {
      return this.getRuleContext(0, Const_exprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_const_assignment;
    }
    enterRule(listener) {
      if (listener.enterConst_assignment) {
        listener.enterConst_assignment(this);
      }
    }
    exitRule(listener) {
      if (listener.exitConst_assignment) {
        listener.exitConst_assignment(this);
      }
    }
  };
  var Const_exprContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_const_expr;
    }
    enterRule(listener) {
      if (listener.enterConst_expr) {
        listener.enterConst_expr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitConst_expr) {
        listener.exitConst_expr(this);
      }
    }
  };
  var Data_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DATA() {
      return this.getToken(QBasicParser.DATA, 0);
    }
    data_item(i) {
      if (i === void 0) {
        return this.getRuleContexts(Data_itemContext);
      }
      return this.getRuleContext(i, Data_itemContext);
    }
    DATA_COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.DATA_COMMA);
      } else {
        return this.getToken(QBasicParser.DATA_COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_data_statement;
    }
    enterRule(listener) {
      if (listener.enterData_statement) {
        listener.enterData_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitData_statement) {
        listener.exitData_statement(this);
      }
    }
  };
  var Data_itemContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DATA_QUOTED() {
      return this.getToken(QBasicParser.DATA_QUOTED, 0);
    }
    DATA_UNQUOTED() {
      return this.getToken(QBasicParser.DATA_UNQUOTED, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_data_item;
    }
    enterRule(listener) {
      if (listener.enterData_item) {
        listener.enterData_item(this);
      }
    }
    exitRule(listener) {
      if (listener.exitData_item) {
        listener.exitData_item(this);
      }
    }
  };
  var Def_seg_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DEF() {
      return this.getToken(QBasicParser.DEF, 0);
    }
    SEG() {
      return this.getToken(QBasicParser.SEG, 0);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_def_seg_statement;
    }
    enterRule(listener) {
      if (listener.enterDef_seg_statement) {
        listener.enterDef_seg_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDef_seg_statement) {
        listener.exitDef_seg_statement(this);
      }
    }
  };
  var Deftype_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DEFINT() {
      return this.getToken(QBasicParser.DEFINT, 0);
    }
    letter_range(i) {
      if (i === void 0) {
        return this.getRuleContexts(Letter_rangeContext);
      }
      return this.getRuleContext(i, Letter_rangeContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    DEFLNG() {
      return this.getToken(QBasicParser.DEFLNG, 0);
    }
    DEFSNG() {
      return this.getToken(QBasicParser.DEFSNG, 0);
    }
    DEFDBL() {
      return this.getToken(QBasicParser.DEFDBL, 0);
    }
    DEFSTR() {
      return this.getToken(QBasicParser.DEFSTR, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_deftype_statement;
    }
    enterRule(listener) {
      if (listener.enterDeftype_statement) {
        listener.enterDeftype_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDeftype_statement) {
        listener.exitDeftype_statement(this);
      }
    }
  };
  var Letter_rangeContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ID(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.ID);
      } else {
        return this.getToken(QBasicParser.ID, i);
      }
    }
    FNID(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.FNID);
      } else {
        return this.getToken(QBasicParser.FNID, i);
      }
    }
    MINUS() {
      return this.getToken(QBasicParser.MINUS, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_letter_range;
    }
    enterRule(listener) {
      if (listener.enterLetter_range) {
        listener.enterLetter_range(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLetter_range) {
        listener.exitLetter_range(this);
      }
    }
  };
  var Dim_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DIM() {
      return this.getToken(QBasicParser.DIM, 0);
    }
    dim_variable(i) {
      if (i === void 0) {
        return this.getRuleContexts(Dim_variableContext);
      }
      return this.getRuleContext(i, Dim_variableContext);
    }
    SHARED() {
      return this.getToken(QBasicParser.SHARED, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    REDIM() {
      return this.getToken(QBasicParser.REDIM, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_dim_statement;
    }
    enterRule(listener) {
      if (listener.enterDim_statement) {
        listener.enterDim_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDim_statement) {
        listener.exitDim_statement(this);
      }
    }
  };
  var Dim_variableContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    type_name() {
      return this.getRuleContext(0, Type_nameContext);
    }
    dim_array_bounds() {
      return this.getRuleContext(0, Dim_array_boundsContext);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_dim_variable;
    }
    enterRule(listener) {
      if (listener.enterDim_variable) {
        listener.enterDim_variable(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDim_variable) {
        listener.exitDim_variable(this);
      }
    }
  };
  var Dim_array_boundsContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    dim_subscript(i) {
      if (i === void 0) {
        return this.getRuleContexts(Dim_subscriptContext);
      }
      return this.getRuleContext(i, Dim_subscriptContext);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_dim_array_bounds;
    }
    enterRule(listener) {
      if (listener.enterDim_array_bounds) {
        listener.enterDim_array_bounds(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDim_array_bounds) {
        listener.exitDim_array_bounds(this);
      }
    }
  };
  var Dim_subscriptContext = class extends ParserRuleContext {
    _lower;
    _upper;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    TO() {
      return this.getToken(QBasicParser.TO, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_dim_subscript;
    }
    enterRule(listener) {
      if (listener.enterDim_subscript) {
        listener.enterDim_subscript(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDim_subscript) {
        listener.exitDim_subscript(this);
      }
    }
  };
  var Do_loop_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    block() {
      return this.getRuleContext(0, BlockContext);
    }
    LOOP() {
      return this.getToken(QBasicParser.LOOP, 0);
    }
    DO() {
      return this.getToken(QBasicParser.DO, 0);
    }
    do_condition() {
      return this.getRuleContext(0, Do_conditionContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_do_loop_statement;
    }
    enterRule(listener) {
      if (listener.enterDo_loop_statement) {
        listener.enterDo_loop_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDo_loop_statement) {
        listener.exitDo_loop_statement(this);
      }
    }
  };
  var Do_conditionContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    WHILE() {
      return this.getToken(QBasicParser.WHILE, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    UNTIL() {
      return this.getToken(QBasicParser.UNTIL, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_do_condition;
    }
    enterRule(listener) {
      if (listener.enterDo_condition) {
        listener.enterDo_condition(this);
      }
    }
    exitRule(listener) {
      if (listener.exitDo_condition) {
        listener.exitDo_condition(this);
      }
    }
  };
  var End_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    END() {
      return this.getToken(QBasicParser.END, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_end_statement;
    }
    enterRule(listener) {
      if (listener.enterEnd_statement) {
        listener.enterEnd_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitEnd_statement) {
        listener.exitEnd_statement(this);
      }
    }
  };
  var Exit_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    EXIT() {
      return this.getToken(QBasicParser.EXIT, 0);
    }
    DEF() {
      return this.getToken(QBasicParser.DEF, 0);
    }
    DO() {
      return this.getToken(QBasicParser.DO, 0);
    }
    FOR() {
      return this.getToken(QBasicParser.FOR, 0);
    }
    FUNCTION() {
      return this.getToken(QBasicParser.FUNCTION, 0);
    }
    SUB() {
      return this.getToken(QBasicParser.SUB, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_exit_statement;
    }
    enterRule(listener) {
      if (listener.enterExit_statement) {
        listener.enterExit_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitExit_statement) {
        listener.exitExit_statement(this);
      }
    }
  };
  var Field_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    FIELD() {
      return this.getToken(QBasicParser.FIELD, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    field_assignment(i) {
      if (i === void 0) {
        return this.getRuleContexts(Field_assignmentContext);
      }
      return this.getRuleContext(i, Field_assignmentContext);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_field_statement;
    }
    enterRule(listener) {
      if (listener.enterField_statement) {
        listener.enterField_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitField_statement) {
        listener.exitField_statement(this);
      }
    }
  };
  var Field_assignmentContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_field_assignment;
    }
    enterRule(listener) {
      if (listener.enterField_assignment) {
        listener.enterField_assignment(this);
      }
    }
    exitRule(listener) {
      if (listener.exitField_assignment) {
        listener.exitField_assignment(this);
      }
    }
  };
  var For_next_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    FOR() {
      return this.getToken(QBasicParser.FOR, 0);
    }
    ID(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.ID);
      } else {
        return this.getToken(QBasicParser.ID, i);
      }
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    TO() {
      return this.getToken(QBasicParser.TO, 0);
    }
    block() {
      return this.getRuleContext(0, BlockContext);
    }
    NEXT() {
      return this.getToken(QBasicParser.NEXT, 0);
    }
    NEXT_WITH_MANDATORY_ID() {
      return this.getToken(QBasicParser.NEXT_WITH_MANDATORY_ID, 0);
    }
    STEP() {
      return this.getToken(QBasicParser.STEP, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_for_next_statement;
    }
    enterRule(listener) {
      if (listener.enterFor_next_statement) {
        listener.enterFor_next_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitFor_next_statement) {
        listener.exitFor_next_statement(this);
      }
    }
  };
  var Get_graphics_statementContext = class extends ParserRuleContext {
    _x1;
    _y1;
    _x2;
    _y2;
    _arrayname;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    GET() {
      return this.getToken(QBasicParser.GET, 0);
    }
    LEFT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.LEFT_PAREN);
      } else {
        return this.getToken(QBasicParser.LEFT_PAREN, i);
      }
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.RIGHT_PAREN);
      } else {
        return this.getToken(QBasicParser.RIGHT_PAREN, i);
      }
    }
    MINUS() {
      return this.getToken(QBasicParser.MINUS, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    STEP(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.STEP);
      } else {
        return this.getToken(QBasicParser.STEP, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_get_graphics_statement;
    }
    enterRule(listener) {
      if (listener.enterGet_graphics_statement) {
        listener.enterGet_graphics_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitGet_graphics_statement) {
        listener.exitGet_graphics_statement(this);
      }
    }
  };
  var Get_io_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    GET() {
      return this.getToken(QBasicParser.GET, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_get_io_statement;
    }
    enterRule(listener) {
      if (listener.enterGet_io_statement) {
        listener.enterGet_io_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitGet_io_statement) {
        listener.exitGet_io_statement(this);
      }
    }
  };
  var Gosub_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    GOSUB() {
      return this.getToken(QBasicParser.GOSUB, 0);
    }
    target() {
      return this.getRuleContext(0, TargetContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_gosub_statement;
    }
    enterRule(listener) {
      if (listener.enterGosub_statement) {
        listener.enterGosub_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitGosub_statement) {
        listener.exitGosub_statement(this);
      }
    }
  };
  var Goto_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    GOTO() {
      return this.getToken(QBasicParser.GOTO, 0);
    }
    target() {
      return this.getRuleContext(0, TargetContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_goto_statement;
    }
    enterRule(listener) {
      if (listener.enterGoto_statement) {
        listener.enterGoto_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitGoto_statement) {
        listener.exitGoto_statement(this);
      }
    }
  };
  var TargetContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    line_number() {
      return this.getRuleContext(0, Line_numberContext);
    }
    text_label() {
      return this.getRuleContext(0, Text_labelContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_target;
    }
    enterRule(listener) {
      if (listener.enterTarget) {
        listener.enterTarget(this);
      }
    }
    exitRule(listener) {
      if (listener.exitTarget) {
        listener.exitTarget(this);
      }
    }
  };
  var If_inline_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    IF() {
      return this.getToken(QBasicParser.IF, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    THEN() {
      return this.getToken(QBasicParser.THEN, 0);
    }
    if_inline_action(i) {
      if (i === void 0) {
        return this.getRuleContexts(If_inline_actionContext);
      }
      return this.getRuleContext(i, If_inline_actionContext);
    }
    ELSE() {
      return this.getToken(QBasicParser.ELSE, 0);
    }
    goto_statement() {
      return this.getRuleContext(0, Goto_statementContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_if_inline_statement;
    }
    enterRule(listener) {
      if (listener.enterIf_inline_statement) {
        listener.enterIf_inline_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitIf_inline_statement) {
        listener.exitIf_inline_statement(this);
      }
    }
  };
  var If_inline_actionContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(StatementContext);
      }
      return this.getRuleContext(i, StatementContext);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    line_number() {
      return this.getRuleContext(0, Line_numberContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_if_inline_action;
    }
    enterRule(listener) {
      if (listener.enterIf_inline_action) {
        listener.enterIf_inline_action(this);
      }
    }
    exitRule(listener) {
      if (listener.exitIf_inline_action) {
        listener.exitIf_inline_action(this);
      }
    }
  };
  var Input_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    INPUT() {
      return this.getToken(QBasicParser.INPUT, 0);
    }
    variable_or_function_call(i) {
      if (i === void 0) {
        return this.getRuleContexts(Variable_or_function_callContext);
      }
      return this.getRuleContext(i, Variable_or_function_callContext);
    }
    SEMICOLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.SEMICOLON);
      } else {
        return this.getToken(QBasicParser.SEMICOLON, i);
      }
    }
    STRING_LITERAL() {
      return this.getToken(QBasicParser.STRING_LITERAL, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    file_number() {
      return this.getRuleContext(0, File_numberContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_input_statement;
    }
    enterRule(listener) {
      if (listener.enterInput_statement) {
        listener.enterInput_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitInput_statement) {
        listener.exitInput_statement(this);
      }
    }
  };
  var Ioctl_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    IOCTL() {
      return this.getToken(QBasicParser.IOCTL, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_ioctl_statement;
    }
    enterRule(listener) {
      if (listener.enterIoctl_statement) {
        listener.enterIoctl_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitIoctl_statement) {
        listener.exitIoctl_statement(this);
      }
    }
  };
  var Key_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    KEY() {
      return this.getToken(QBasicParser.KEY, 0);
    }
    LIST() {
      return this.getToken(QBasicParser.LIST, 0);
    }
    ON() {
      return this.getToken(QBasicParser.ON, 0);
    }
    OFF() {
      return this.getToken(QBasicParser.OFF, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_key_statement;
    }
    enterRule(listener) {
      if (listener.enterKey_statement) {
        listener.enterKey_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitKey_statement) {
        listener.exitKey_statement(this);
      }
    }
  };
  var Line_statementContext = class extends ParserRuleContext {
    _x1;
    _y1;
    _x2;
    _y2;
    _color;
    _box;
    _style;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LINE() {
      return this.getToken(QBasicParser.LINE, 0);
    }
    MINUS() {
      return this.getToken(QBasicParser.MINUS, 0);
    }
    LEFT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.LEFT_PAREN);
      } else {
        return this.getToken(QBasicParser.LEFT_PAREN, i);
      }
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.RIGHT_PAREN);
      } else {
        return this.getToken(QBasicParser.RIGHT_PAREN, i);
      }
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    STEP(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.STEP);
      } else {
        return this.getToken(QBasicParser.STEP, i);
      }
    }
    box_style() {
      return this.getRuleContext(0, Box_styleContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_line_statement;
    }
    enterRule(listener) {
      if (listener.enterLine_statement) {
        listener.enterLine_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLine_statement) {
        listener.exitLine_statement(this);
      }
    }
  };
  var Box_styleContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_box_style;
    }
    enterRule(listener) {
      if (listener.enterBox_style) {
        listener.enterBox_style(this);
      }
    }
    exitRule(listener) {
      if (listener.exitBox_style) {
        listener.exitBox_style(this);
      }
    }
  };
  var Line_input_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LINE() {
      return this.getToken(QBasicParser.LINE, 0);
    }
    INPUT() {
      return this.getToken(QBasicParser.INPUT, 0);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    SEMICOLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.SEMICOLON);
      } else {
        return this.getToken(QBasicParser.SEMICOLON, i);
      }
    }
    STRING_LITERAL() {
      return this.getToken(QBasicParser.STRING_LITERAL, 0);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    file_number() {
      return this.getRuleContext(0, File_numberContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_line_input_statement;
    }
    enterRule(listener) {
      if (listener.enterLine_input_statement) {
        listener.enterLine_input_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLine_input_statement) {
        listener.exitLine_input_statement(this);
      }
    }
  };
  var Locate_statementContext = class extends ParserRuleContext {
    _row;
    _column;
    _cursor;
    _start;
    _stop;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LOCATE() {
      return this.getToken(QBasicParser.LOCATE, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_locate_statement;
    }
    enterRule(listener) {
      if (listener.enterLocate_statement) {
        listener.enterLocate_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLocate_statement) {
        listener.exitLocate_statement(this);
      }
    }
  };
  var Lock_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LOCK() {
      return this.getToken(QBasicParser.LOCK, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    TO() {
      return this.getToken(QBasicParser.TO, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_lock_statement;
    }
    enterRule(listener) {
      if (listener.enterLock_statement) {
        listener.enterLock_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLock_statement) {
        listener.exitLock_statement(this);
      }
    }
  };
  var Lprint_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LPRINT() {
      return this.getToken(QBasicParser.LPRINT, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    SEMICOLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.SEMICOLON);
      } else {
        return this.getToken(QBasicParser.SEMICOLON, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_lprint_statement;
    }
    enterRule(listener) {
      if (listener.enterLprint_statement) {
        listener.enterLprint_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLprint_statement) {
        listener.exitLprint_statement(this);
      }
    }
  };
  var Lprint_using_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LPRINT() {
      return this.getToken(QBasicParser.LPRINT, 0);
    }
    USING() {
      return this.getToken(QBasicParser.USING, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    SEMICOLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.SEMICOLON);
      } else {
        return this.getToken(QBasicParser.SEMICOLON, i);
      }
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_lprint_using_statement;
    }
    enterRule(listener) {
      if (listener.enterLprint_using_statement) {
        listener.enterLprint_using_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLprint_using_statement) {
        listener.exitLprint_using_statement(this);
      }
    }
  };
  var Lset_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LSET() {
      return this.getToken(QBasicParser.LSET, 0);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_lset_statement;
    }
    enterRule(listener) {
      if (listener.enterLset_statement) {
        listener.enterLset_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLset_statement) {
        listener.exitLset_statement(this);
      }
    }
  };
  var Mid_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    MID_STRING() {
      return this.getToken(QBasicParser.MID_STRING, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_mid_statement;
    }
    enterRule(listener) {
      if (listener.enterMid_statement) {
        listener.enterMid_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitMid_statement) {
        listener.exitMid_statement(this);
      }
    }
  };
  var Name_statementContext = class extends ParserRuleContext {
    _oldspec;
    _newspec;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    NAME() {
      return this.getToken(QBasicParser.NAME, 0);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_name_statement;
    }
    enterRule(listener) {
      if (listener.enterName_statement) {
        listener.enterName_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitName_statement) {
        listener.exitName_statement(this);
      }
    }
  };
  var On_error_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ON() {
      return this.getToken(QBasicParser.ON, 0);
    }
    ERROR() {
      return this.getToken(QBasicParser.ERROR, 0);
    }
    GOTO() {
      return this.getToken(QBasicParser.GOTO, 0);
    }
    target() {
      return this.getRuleContext(0, TargetContext);
    }
    RESUME() {
      return this.getToken(QBasicParser.RESUME, 0);
    }
    NEXT() {
      return this.getToken(QBasicParser.NEXT, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_on_error_statement;
    }
    enterRule(listener) {
      if (listener.enterOn_error_statement) {
        listener.enterOn_error_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOn_error_statement) {
        listener.exitOn_error_statement(this);
      }
    }
  };
  var On_event_gosub_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ON() {
      return this.getToken(QBasicParser.ON, 0);
    }
    COM() {
      return this.getToken(QBasicParser.COM, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    GOSUB() {
      return this.getToken(QBasicParser.GOSUB, 0);
    }
    target() {
      return this.getRuleContext(0, TargetContext);
    }
    KEY() {
      return this.getToken(QBasicParser.KEY, 0);
    }
    PEN() {
      return this.getToken(QBasicParser.PEN, 0);
    }
    PLAY() {
      return this.getToken(QBasicParser.PLAY, 0);
    }
    STRIG() {
      return this.getToken(QBasicParser.STRIG, 0);
    }
    TIMER() {
      return this.getToken(QBasicParser.TIMER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_on_event_gosub_statement;
    }
    enterRule(listener) {
      if (listener.enterOn_event_gosub_statement) {
        listener.enterOn_event_gosub_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOn_event_gosub_statement) {
        listener.exitOn_event_gosub_statement(this);
      }
    }
  };
  var On_expr_gosub_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ON() {
      return this.getToken(QBasicParser.ON, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    GOSUB() {
      return this.getToken(QBasicParser.GOSUB, 0);
    }
    target_list() {
      return this.getRuleContext(0, Target_listContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_on_expr_gosub_statement;
    }
    enterRule(listener) {
      if (listener.enterOn_expr_gosub_statement) {
        listener.enterOn_expr_gosub_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOn_expr_gosub_statement) {
        listener.exitOn_expr_gosub_statement(this);
      }
    }
  };
  var Target_listContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    target(i) {
      if (i === void 0) {
        return this.getRuleContexts(TargetContext);
      }
      return this.getRuleContext(i, TargetContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_target_list;
    }
    enterRule(listener) {
      if (listener.enterTarget_list) {
        listener.enterTarget_list(this);
      }
    }
    exitRule(listener) {
      if (listener.exitTarget_list) {
        listener.exitTarget_list(this);
      }
    }
  };
  var On_expr_goto_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ON() {
      return this.getToken(QBasicParser.ON, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    GOTO() {
      return this.getToken(QBasicParser.GOTO, 0);
    }
    target_list() {
      return this.getRuleContext(0, Target_listContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_on_expr_goto_statement;
    }
    enterRule(listener) {
      if (listener.enterOn_expr_goto_statement) {
        listener.enterOn_expr_goto_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOn_expr_goto_statement) {
        listener.exitOn_expr_goto_statement(this);
      }
    }
  };
  var Open_legacy_statementContext = class extends ParserRuleContext {
    _openmode;
    _filenum;
    _file;
    _reclen;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    OPEN() {
      return this.getToken(QBasicParser.OPEN, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_open_legacy_statement;
    }
    enterRule(listener) {
      if (listener.enterOpen_legacy_statement) {
        listener.enterOpen_legacy_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOpen_legacy_statement) {
        listener.exitOpen_legacy_statement(this);
      }
    }
  };
  var Open_statementContext = class extends ParserRuleContext {
    _file;
    _filenum;
    _reclen;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    OPEN() {
      return this.getToken(QBasicParser.OPEN, 0);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    FOR() {
      return this.getToken(QBasicParser.FOR, 0);
    }
    open_mode() {
      return this.getRuleContext(0, Open_modeContext);
    }
    ACCESS() {
      return this.getToken(QBasicParser.ACCESS, 0);
    }
    open_access() {
      return this.getRuleContext(0, Open_accessContext);
    }
    open_lock() {
      return this.getRuleContext(0, Open_lockContext);
    }
    LEN() {
      return this.getToken(QBasicParser.LEN, 0);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_open_statement;
    }
    enterRule(listener) {
      if (listener.enterOpen_statement) {
        listener.enterOpen_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOpen_statement) {
        listener.exitOpen_statement(this);
      }
    }
  };
  var Open_modeContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    OUTPUT() {
      return this.getToken(QBasicParser.OUTPUT, 0);
    }
    INPUT() {
      return this.getToken(QBasicParser.INPUT, 0);
    }
    APPEND() {
      return this.getToken(QBasicParser.APPEND, 0);
    }
    RANDOM() {
      return this.getToken(QBasicParser.RANDOM, 0);
    }
    BINARY() {
      return this.getToken(QBasicParser.BINARY, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_open_mode;
    }
    enterRule(listener) {
      if (listener.enterOpen_mode) {
        listener.enterOpen_mode(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOpen_mode) {
        listener.exitOpen_mode(this);
      }
    }
  };
  var Open_accessContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    READ() {
      return this.getToken(QBasicParser.READ, 0);
    }
    WRITE() {
      return this.getToken(QBasicParser.WRITE, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_open_access;
    }
    enterRule(listener) {
      if (listener.enterOpen_access) {
        listener.enterOpen_access(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOpen_access) {
        listener.exitOpen_access(this);
      }
    }
  };
  var Open_lockContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    SHARED() {
      return this.getToken(QBasicParser.SHARED, 0);
    }
    LOCK() {
      return this.getToken(QBasicParser.LOCK, 0);
    }
    READ() {
      return this.getToken(QBasicParser.READ, 0);
    }
    WRITE() {
      return this.getToken(QBasicParser.WRITE, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_open_lock;
    }
    enterRule(listener) {
      if (listener.enterOpen_lock) {
        listener.enterOpen_lock(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOpen_lock) {
        listener.exitOpen_lock(this);
      }
    }
  };
  var Paint_statementContext = class extends ParserRuleContext {
    _x;
    _y;
    _color_tile;
    _bordercolor;
    _background;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PAINT() {
      return this.getToken(QBasicParser.PAINT, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    STEP() {
      return this.getToken(QBasicParser.STEP, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_paint_statement;
    }
    enterRule(listener) {
      if (listener.enterPaint_statement) {
        listener.enterPaint_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPaint_statement) {
        listener.exitPaint_statement(this);
      }
    }
  };
  var Palette_statementContext = class extends ParserRuleContext {
    _attribute;
    _color;
    _arrayname;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PALETTE() {
      return this.getToken(QBasicParser.PALETTE, 0);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    USING() {
      return this.getToken(QBasicParser.USING, 0);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_palette_statement;
    }
    enterRule(listener) {
      if (listener.enterPalette_statement) {
        listener.enterPalette_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPalette_statement) {
        listener.exitPalette_statement(this);
      }
    }
  };
  var Play_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PLAY() {
      return this.getToken(QBasicParser.PLAY, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_play_statement;
    }
    enterRule(listener) {
      if (listener.enterPlay_statement) {
        listener.enterPlay_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPlay_statement) {
        listener.exitPlay_statement(this);
      }
    }
  };
  var Preset_statementContext = class extends ParserRuleContext {
    _x;
    _y;
    _color;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PRESET() {
      return this.getToken(QBasicParser.PRESET, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    STEP() {
      return this.getToken(QBasicParser.STEP, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_preset_statement;
    }
    enterRule(listener) {
      if (listener.enterPreset_statement) {
        listener.enterPreset_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPreset_statement) {
        listener.exitPreset_statement(this);
      }
    }
  };
  var Print_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PRINT() {
      return this.getToken(QBasicParser.PRINT, 0);
    }
    file_number() {
      return this.getRuleContext(0, File_numberContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    SEMICOLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.SEMICOLON);
      } else {
        return this.getToken(QBasicParser.SEMICOLON, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_print_statement;
    }
    enterRule(listener) {
      if (listener.enterPrint_statement) {
        listener.enterPrint_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPrint_statement) {
        listener.exitPrint_statement(this);
      }
    }
  };
  var Print_using_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PRINT() {
      return this.getToken(QBasicParser.PRINT, 0);
    }
    USING() {
      return this.getToken(QBasicParser.USING, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    SEMICOLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.SEMICOLON);
      } else {
        return this.getToken(QBasicParser.SEMICOLON, i);
      }
    }
    file_number() {
      return this.getRuleContext(0, File_numberContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_print_using_statement;
    }
    enterRule(listener) {
      if (listener.enterPrint_using_statement) {
        listener.enterPrint_using_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPrint_using_statement) {
        listener.exitPrint_using_statement(this);
      }
    }
  };
  var Pset_statementContext = class extends ParserRuleContext {
    _x;
    _y;
    _color;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PSET() {
      return this.getToken(QBasicParser.PSET, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    STEP() {
      return this.getToken(QBasicParser.STEP, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_pset_statement;
    }
    enterRule(listener) {
      if (listener.enterPset_statement) {
        listener.enterPset_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPset_statement) {
        listener.exitPset_statement(this);
      }
    }
  };
  var Put_graphics_statementContext = class extends ParserRuleContext {
    _x1;
    _y1;
    _arrayname;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PUT() {
      return this.getToken(QBasicParser.PUT, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    STEP() {
      return this.getToken(QBasicParser.STEP, 0);
    }
    AND() {
      return this.getToken(QBasicParser.AND, 0);
    }
    OR() {
      return this.getToken(QBasicParser.OR, 0);
    }
    PSET() {
      return this.getToken(QBasicParser.PSET, 0);
    }
    PRESET() {
      return this.getToken(QBasicParser.PRESET, 0);
    }
    XOR() {
      return this.getToken(QBasicParser.XOR, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_put_graphics_statement;
    }
    enterRule(listener) {
      if (listener.enterPut_graphics_statement) {
        listener.enterPut_graphics_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPut_graphics_statement) {
        listener.exitPut_graphics_statement(this);
      }
    }
  };
  var Put_io_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PUT() {
      return this.getToken(QBasicParser.PUT, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_put_io_statement;
    }
    enterRule(listener) {
      if (listener.enterPut_io_statement) {
        listener.enterPut_io_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPut_io_statement) {
        listener.exitPut_io_statement(this);
      }
    }
  };
  var Read_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    READ() {
      return this.getToken(QBasicParser.READ, 0);
    }
    variable_or_function_call(i) {
      if (i === void 0) {
        return this.getRuleContexts(Variable_or_function_callContext);
      }
      return this.getRuleContext(i, Variable_or_function_callContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_read_statement;
    }
    enterRule(listener) {
      if (listener.enterRead_statement) {
        listener.enterRead_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitRead_statement) {
        listener.exitRead_statement(this);
      }
    }
  };
  var Rem_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    REM() {
      return this.getToken(QBasicParser.REM, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_rem_statement;
    }
    enterRule(listener) {
      if (listener.enterRem_statement) {
        listener.enterRem_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitRem_statement) {
        listener.exitRem_statement(this);
      }
    }
  };
  var Resume_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    RESUME() {
      return this.getToken(QBasicParser.RESUME, 0);
    }
    NEXT() {
      return this.getToken(QBasicParser.NEXT, 0);
    }
    target() {
      return this.getRuleContext(0, TargetContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_resume_statement;
    }
    enterRule(listener) {
      if (listener.enterResume_statement) {
        listener.enterResume_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitResume_statement) {
        listener.exitResume_statement(this);
      }
    }
  };
  var Return_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    RETURN() {
      return this.getToken(QBasicParser.RETURN, 0);
    }
    target() {
      return this.getRuleContext(0, TargetContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_return_statement;
    }
    enterRule(listener) {
      if (listener.enterReturn_statement) {
        listener.enterReturn_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitReturn_statement) {
        listener.exitReturn_statement(this);
      }
    }
  };
  var Rset_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    RSET() {
      return this.getToken(QBasicParser.RSET, 0);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_rset_statement;
    }
    enterRule(listener) {
      if (listener.enterRset_statement) {
        listener.enterRset_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitRset_statement) {
        listener.exitRset_statement(this);
      }
    }
  };
  var Select_case_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    SELECT() {
      return this.getToken(QBasicParser.SELECT, 0);
    }
    CASE() {
      return this.getToken(QBasicParser.CASE, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    before_first_case() {
      return this.getRuleContext(0, Before_first_caseContext);
    }
    end_select_statement() {
      return this.getRuleContext(0, End_select_statementContext);
    }
    case_block(i) {
      if (i === void 0) {
        return this.getRuleContexts(Case_blockContext);
      }
      return this.getRuleContext(i, Case_blockContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_select_case_statement;
    }
    enterRule(listener) {
      if (listener.enterSelect_case_statement) {
        listener.enterSelect_case_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitSelect_case_statement) {
        listener.exitSelect_case_statement(this);
      }
    }
  };
  var Before_first_caseContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    COLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COLON);
      } else {
        return this.getToken(QBasicParser.COLON, i);
      }
    }
    rem_statement(i) {
      if (i === void 0) {
        return this.getRuleContexts(Rem_statementContext);
      }
      return this.getRuleContext(i, Rem_statementContext);
    }
    NL(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.NL);
      } else {
        return this.getToken(QBasicParser.NL, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_before_first_case;
    }
    enterRule(listener) {
      if (listener.enterBefore_first_case) {
        listener.enterBefore_first_case(this);
      }
    }
    exitRule(listener) {
      if (listener.exitBefore_first_case) {
        listener.exitBefore_first_case(this);
      }
    }
  };
  var Case_blockContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    case_statement() {
      return this.getRuleContext(0, Case_statementContext);
    }
    block() {
      return this.getRuleContext(0, BlockContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_case_block;
    }
    enterRule(listener) {
      if (listener.enterCase_block) {
        listener.enterCase_block(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCase_block) {
        listener.exitCase_block(this);
      }
    }
  };
  var Case_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    CASE() {
      return this.getToken(QBasicParser.CASE, 0);
    }
    case_expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(Case_exprContext);
      }
      return this.getRuleContext(i, Case_exprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    ELSE() {
      return this.getToken(QBasicParser.ELSE, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_case_statement;
    }
    enterRule(listener) {
      if (listener.enterCase_statement) {
        listener.enterCase_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCase_statement) {
        listener.exitCase_statement(this);
      }
    }
  };
  var Case_exprContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    IS() {
      return this.getToken(QBasicParser.IS, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    LT() {
      return this.getToken(QBasicParser.LT, 0);
    }
    LE() {
      return this.getToken(QBasicParser.LE, 0);
    }
    GT() {
      return this.getToken(QBasicParser.GT, 0);
    }
    GE() {
      return this.getToken(QBasicParser.GE, 0);
    }
    NE() {
      return this.getToken(QBasicParser.NE, 0);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    TO() {
      return this.getToken(QBasicParser.TO, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_case_expr;
    }
    enterRule(listener) {
      if (listener.enterCase_expr) {
        listener.enterCase_expr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitCase_expr) {
        listener.exitCase_expr(this);
      }
    }
  };
  var End_select_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    END() {
      return this.getToken(QBasicParser.END, 0);
    }
    SELECT() {
      return this.getToken(QBasicParser.SELECT, 0);
    }
    label() {
      return this.getRuleContext(0, LabelContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_end_select_statement;
    }
    enterRule(listener) {
      if (listener.enterEnd_select_statement) {
        listener.enterEnd_select_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitEnd_select_statement) {
        listener.exitEnd_select_statement(this);
      }
    }
  };
  var Scope_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    COMMON() {
      return this.getToken(QBasicParser.COMMON, 0);
    }
    scope_variable(i) {
      if (i === void 0) {
        return this.getRuleContexts(Scope_variableContext);
      }
      return this.getRuleContext(i, Scope_variableContext);
    }
    SHARED() {
      return this.getToken(QBasicParser.SHARED, 0);
    }
    block_name() {
      return this.getRuleContext(0, Block_nameContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    STATIC() {
      return this.getToken(QBasicParser.STATIC, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_scope_statement;
    }
    enterRule(listener) {
      if (listener.enterScope_statement) {
        listener.enterScope_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitScope_statement) {
        listener.exitScope_statement(this);
      }
    }
  };
  var Block_nameContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    DIVIDE(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.DIVIDE);
      } else {
        return this.getToken(QBasicParser.DIVIDE, i);
      }
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_block_name;
    }
    enterRule(listener) {
      if (listener.enterBlock_name) {
        listener.enterBlock_name(this);
      }
    }
    exitRule(listener) {
      if (listener.exitBlock_name) {
        listener.exitBlock_name(this);
      }
    }
  };
  var Scope_variableContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    AS() {
      return this.getToken(QBasicParser.AS, 0);
    }
    type_name() {
      return this.getRuleContext(0, Type_nameContext);
    }
    array_declaration() {
      return this.getRuleContext(0, Array_declarationContext);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_scope_variable;
    }
    enterRule(listener) {
      if (listener.enterScope_variable) {
        listener.enterScope_variable(this);
      }
    }
    exitRule(listener) {
      if (listener.exitScope_variable) {
        listener.exitScope_variable(this);
      }
    }
  };
  var Screen_statementContext = class extends ParserRuleContext {
    _screenmode;
    _colorswitch;
    _activepage;
    _visualpage;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    SCREEN() {
      return this.getToken(QBasicParser.SCREEN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_screen_statement;
    }
    enterRule(listener) {
      if (listener.enterScreen_statement) {
        listener.enterScreen_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitScreen_statement) {
        listener.exitScreen_statement(this);
      }
    }
  };
  var Seek_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    SEEK() {
      return this.getToken(QBasicParser.SEEK, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_seek_statement;
    }
    enterRule(listener) {
      if (listener.enterSeek_statement) {
        listener.enterSeek_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitSeek_statement) {
        listener.exitSeek_statement(this);
      }
    }
  };
  var Stop_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    STOP() {
      return this.getToken(QBasicParser.STOP, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_stop_statement;
    }
    enterRule(listener) {
      if (listener.enterStop_statement) {
        listener.enterStop_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitStop_statement) {
        listener.exitStop_statement(this);
      }
    }
  };
  var Unlock_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    UNLOCK() {
      return this.getToken(QBasicParser.UNLOCK, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    TO() {
      return this.getToken(QBasicParser.TO, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_unlock_statement;
    }
    enterRule(listener) {
      if (listener.enterUnlock_statement) {
        listener.enterUnlock_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitUnlock_statement) {
        listener.exitUnlock_statement(this);
      }
    }
  };
  var View_statementContext = class extends ParserRuleContext {
    _x1;
    _y1;
    _x2;
    _y2;
    _color;
    _border;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    VIEW() {
      return this.getToken(QBasicParser.VIEW, 0);
    }
    LEFT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.LEFT_PAREN);
      } else {
        return this.getToken(QBasicParser.LEFT_PAREN, i);
      }
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.RIGHT_PAREN);
      } else {
        return this.getToken(QBasicParser.RIGHT_PAREN, i);
      }
    }
    MINUS() {
      return this.getToken(QBasicParser.MINUS, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    SCREEN() {
      return this.getToken(QBasicParser.SCREEN, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_view_statement;
    }
    enterRule(listener) {
      if (listener.enterView_statement) {
        listener.enterView_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitView_statement) {
        listener.exitView_statement(this);
      }
    }
  };
  var View_print_statementContext = class extends ParserRuleContext {
    _toprow;
    _bottomrow;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    VIEW() {
      return this.getToken(QBasicParser.VIEW, 0);
    }
    PRINT() {
      return this.getToken(QBasicParser.PRINT, 0);
    }
    TO() {
      return this.getToken(QBasicParser.TO, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_view_print_statement;
    }
    enterRule(listener) {
      if (listener.enterView_print_statement) {
        listener.enterView_print_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitView_print_statement) {
        listener.exitView_print_statement(this);
      }
    }
  };
  var While_wend_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    WHILE() {
      return this.getToken(QBasicParser.WHILE, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    block() {
      return this.getRuleContext(0, BlockContext);
    }
    WEND() {
      return this.getToken(QBasicParser.WEND, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_while_wend_statement;
    }
    enterRule(listener) {
      if (listener.enterWhile_wend_statement) {
        listener.enterWhile_wend_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitWhile_wend_statement) {
        listener.exitWhile_wend_statement(this);
      }
    }
  };
  var Width_statementContext = class extends ParserRuleContext {
    _columns;
    _lines;
    _width;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    WIDTH() {
      return this.getToken(QBasicParser.WIDTH, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA() {
      return this.getToken(QBasicParser.COMMA, 0);
    }
    file_number() {
      return this.getRuleContext(0, File_numberContext);
    }
    LPRINT() {
      return this.getToken(QBasicParser.LPRINT, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_width_statement;
    }
    enterRule(listener) {
      if (listener.enterWidth_statement) {
        listener.enterWidth_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitWidth_statement) {
        listener.exitWidth_statement(this);
      }
    }
  };
  var Window_statementContext = class extends ParserRuleContext {
    _x1;
    _y1;
    _x2;
    _y2;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    WINDOW() {
      return this.getToken(QBasicParser.WINDOW, 0);
    }
    LEFT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.LEFT_PAREN);
      } else {
        return this.getToken(QBasicParser.LEFT_PAREN, i);
      }
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    RIGHT_PAREN(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.RIGHT_PAREN);
      } else {
        return this.getToken(QBasicParser.RIGHT_PAREN, i);
      }
    }
    MINUS() {
      return this.getToken(QBasicParser.MINUS, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    SCREEN() {
      return this.getToken(QBasicParser.SCREEN, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_window_statement;
    }
    enterRule(listener) {
      if (listener.enterWindow_statement) {
        listener.enterWindow_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitWindow_statement) {
        listener.exitWindow_statement(this);
      }
    }
  };
  var Write_statementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    WRITE() {
      return this.getToken(QBasicParser.WRITE, 0);
    }
    file_number() {
      return this.getRuleContext(0, File_numberContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    SEMICOLON(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.SEMICOLON);
      } else {
        return this.getToken(QBasicParser.SEMICOLON, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_write_statement;
    }
    enterRule(listener) {
      if (listener.enterWrite_statement) {
        listener.enterWrite_statement(this);
      }
    }
    exitRule(listener) {
      if (listener.exitWrite_statement) {
        listener.exitWrite_statement(this);
      }
    }
  };
  var ExprContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    get ruleIndex() {
      return QBasicParser.RULE_expr;
    }
    copyFrom(ctx) {
      super.copyFrom(ctx);
    }
  };
  var AndExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    AND() {
      return this.getToken(QBasicParser.AND, 0);
    }
    enterRule(listener) {
      if (listener.enterAndExpr) {
        listener.enterAndExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitAndExpr) {
        listener.exitAndExpr(this);
      }
    }
  };
  var ValueExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    literal() {
      return this.getRuleContext(0, LiteralContext);
    }
    enterRule(listener) {
      if (listener.enterValueExpr) {
        listener.enterValueExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitValueExpr) {
        listener.exitValueExpr(this);
      }
    }
  };
  var ComparisonExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    EQ() {
      return this.getToken(QBasicParser.EQ, 0);
    }
    GT() {
      return this.getToken(QBasicParser.GT, 0);
    }
    LT() {
      return this.getToken(QBasicParser.LT, 0);
    }
    NE() {
      return this.getToken(QBasicParser.NE, 0);
    }
    LE() {
      return this.getToken(QBasicParser.LE, 0);
    }
    GE() {
      return this.getToken(QBasicParser.GE, 0);
    }
    enterRule(listener) {
      if (listener.enterComparisonExpr) {
        listener.enterComparisonExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitComparisonExpr) {
        listener.exitComparisonExpr(this);
      }
    }
  };
  var XorExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    XOR() {
      return this.getToken(QBasicParser.XOR, 0);
    }
    enterRule(listener) {
      if (listener.enterXorExpr) {
        listener.enterXorExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitXorExpr) {
        listener.exitXorExpr(this);
      }
    }
  };
  var PlusMinusExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    PLUS() {
      return this.getToken(QBasicParser.PLUS, 0);
    }
    MINUS() {
      return this.getToken(QBasicParser.MINUS, 0);
    }
    enterRule(listener) {
      if (listener.enterPlusMinusExpr) {
        listener.enterPlusMinusExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitPlusMinusExpr) {
        listener.exitPlusMinusExpr(this);
      }
    }
  };
  var OrExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    OR() {
      return this.getToken(QBasicParser.OR, 0);
    }
    enterRule(listener) {
      if (listener.enterOrExpr) {
        listener.enterOrExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitOrExpr) {
        listener.exitOrExpr(this);
      }
    }
  };
  var VarCallExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    variable_or_function_call() {
      return this.getRuleContext(0, Variable_or_function_callContext);
    }
    enterRule(listener) {
      if (listener.enterVarCallExpr) {
        listener.enterVarCallExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitVarCallExpr) {
        listener.exitVarCallExpr(this);
      }
    }
  };
  var ImpExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    IMP() {
      return this.getToken(QBasicParser.IMP, 0);
    }
    enterRule(listener) {
      if (listener.enterImpExpr) {
        listener.enterImpExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitImpExpr) {
        listener.exitImpExpr(this);
      }
    }
  };
  var ExponentExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    EXP() {
      return this.getToken(QBasicParser.EXP, 0);
    }
    enterRule(listener) {
      if (listener.enterExponentExpr) {
        listener.enterExponentExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitExponentExpr) {
        listener.exitExponentExpr(this);
      }
    }
  };
  var UnaryPlusExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    PLUS() {
      return this.getToken(QBasicParser.PLUS, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    enterRule(listener) {
      if (listener.enterUnaryPlusExpr) {
        listener.enterUnaryPlusExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitUnaryPlusExpr) {
        listener.exitUnaryPlusExpr(this);
      }
    }
  };
  var NotExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    NOT() {
      return this.getToken(QBasicParser.NOT, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    enterRule(listener) {
      if (listener.enterNotExpr) {
        listener.enterNotExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitNotExpr) {
        listener.exitNotExpr(this);
      }
    }
  };
  var ModExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    MOD() {
      return this.getToken(QBasicParser.MOD, 0);
    }
    enterRule(listener) {
      if (listener.enterModExpr) {
        listener.enterModExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitModExpr) {
        listener.exitModExpr(this);
      }
    }
  };
  var ParenExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    enterRule(listener) {
      if (listener.enterParenExpr) {
        listener.enterParenExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitParenExpr) {
        listener.exitParenExpr(this);
      }
    }
  };
  var MultiplyDivideExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    TIMES() {
      return this.getToken(QBasicParser.TIMES, 0);
    }
    DIVIDE() {
      return this.getToken(QBasicParser.DIVIDE, 0);
    }
    enterRule(listener) {
      if (listener.enterMultiplyDivideExpr) {
        listener.enterMultiplyDivideExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitMultiplyDivideExpr) {
        listener.exitMultiplyDivideExpr(this);
      }
    }
  };
  var IntegerDivideExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    INTEGER_DIVIDE() {
      return this.getToken(QBasicParser.INTEGER_DIVIDE, 0);
    }
    enterRule(listener) {
      if (listener.enterIntegerDivideExpr) {
        listener.enterIntegerDivideExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitIntegerDivideExpr) {
        listener.exitIntegerDivideExpr(this);
      }
    }
  };
  var BuiltinExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    builtin_function() {
      return this.getRuleContext(0, Builtin_functionContext);
    }
    enterRule(listener) {
      if (listener.enterBuiltinExpr) {
        listener.enterBuiltinExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitBuiltinExpr) {
        listener.exitBuiltinExpr(this);
      }
    }
  };
  var EqvExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    EQV() {
      return this.getToken(QBasicParser.EQV, 0);
    }
    enterRule(listener) {
      if (listener.enterEqvExpr) {
        listener.enterEqvExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitEqvExpr) {
        listener.exitEqvExpr(this);
      }
    }
  };
  var UnaryMinusExprContext = class extends ExprContext {
    constructor(ctx) {
      super(ctx.parent, ctx.invokingState);
      super.copyFrom(ctx);
    }
    MINUS() {
      return this.getToken(QBasicParser.MINUS, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    enterRule(listener) {
      if (listener.enterUnaryMinusExpr) {
        listener.enterUnaryMinusExpr(this);
      }
    }
    exitRule(listener) {
      if (listener.exitUnaryMinusExpr) {
        listener.exitUnaryMinusExpr(this);
      }
    }
  };
  var Builtin_functionContext = class extends ParserRuleContext {
    _n;
    _filenumber;
    _row;
    _column;
    _colorflag;
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    INPUT_STRING() {
      return this.getToken(QBasicParser.INPUT_STRING, 0);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    IOCTL_STRING() {
      return this.getToken(QBasicParser.IOCTL_STRING, 0);
    }
    LEN() {
      return this.getToken(QBasicParser.LEN, 0);
    }
    MID_STRING() {
      return this.getToken(QBasicParser.MID_STRING, 0);
    }
    PEN() {
      return this.getToken(QBasicParser.PEN, 0);
    }
    PLAY() {
      return this.getToken(QBasicParser.PLAY, 0);
    }
    SCREEN() {
      return this.getToken(QBasicParser.SCREEN, 0);
    }
    SEEK() {
      return this.getToken(QBasicParser.SEEK, 0);
    }
    STRIG() {
      return this.getToken(QBasicParser.STRIG, 0);
    }
    TIMER() {
      return this.getToken(QBasicParser.TIMER, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_builtin_function;
    }
    enterRule(listener) {
      if (listener.enterBuiltin_function) {
        listener.enterBuiltin_function(this);
      }
    }
    exitRule(listener) {
      if (listener.exitBuiltin_function) {
        listener.exitBuiltin_function(this);
      }
    }
  };
  var Args_or_indicesContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    LEFT_PAREN() {
      return this.getToken(QBasicParser.LEFT_PAREN, 0);
    }
    RIGHT_PAREN() {
      return this.getToken(QBasicParser.RIGHT_PAREN, 0);
    }
    expr(i) {
      if (i === void 0) {
        return this.getRuleContexts(ExprContext);
      }
      return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.COMMA);
      } else {
        return this.getToken(QBasicParser.COMMA, i);
      }
    }
    get ruleIndex() {
      return QBasicParser.RULE_args_or_indices;
    }
    enterRule(listener) {
      if (listener.enterArgs_or_indices) {
        listener.enterArgs_or_indices(this);
      }
    }
    exitRule(listener) {
      if (listener.exitArgs_or_indices) {
        listener.exitArgs_or_indices(this);
      }
    }
  };
  var Variable_or_function_callContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ID(i) {
      if (i === void 0) {
        return this.getTokens(QBasicParser.ID);
      } else {
        return this.getToken(QBasicParser.ID, i);
      }
    }
    FNID() {
      return this.getToken(QBasicParser.FNID, 0);
    }
    args_or_indices() {
      return this.getRuleContext(0, Args_or_indicesContext);
    }
    DOT() {
      return this.getToken(QBasicParser.DOT, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_variable_or_function_call;
    }
    enterRule(listener) {
      if (listener.enterVariable_or_function_call) {
        listener.enterVariable_or_function_call(this);
      }
    }
    exitRule(listener) {
      if (listener.exitVariable_or_function_call) {
        listener.exitVariable_or_function_call(this);
      }
    }
  };
  var Type_nameContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    INTEGER() {
      return this.getToken(QBasicParser.INTEGER, 0);
    }
    LONG() {
      return this.getToken(QBasicParser.LONG, 0);
    }
    SINGLE() {
      return this.getToken(QBasicParser.SINGLE, 0);
    }
    DOUBLE() {
      return this.getToken(QBasicParser.DOUBLE, 0);
    }
    STRING() {
      return this.getToken(QBasicParser.STRING, 0);
    }
    fixed_string() {
      return this.getRuleContext(0, Fixed_stringContext);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    untyped_fnid() {
      return this.getRuleContext(0, Untyped_fnidContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_type_name;
    }
    enterRule(listener) {
      if (listener.enterType_name) {
        listener.enterType_name(this);
      }
    }
    exitRule(listener) {
      if (listener.exitType_name) {
        listener.exitType_name(this);
      }
    }
  };
  var Type_name_for_parameterContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    INTEGER() {
      return this.getToken(QBasicParser.INTEGER, 0);
    }
    LONG() {
      return this.getToken(QBasicParser.LONG, 0);
    }
    SINGLE() {
      return this.getToken(QBasicParser.SINGLE, 0);
    }
    DOUBLE() {
      return this.getToken(QBasicParser.DOUBLE, 0);
    }
    STRING() {
      return this.getToken(QBasicParser.STRING, 0);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    untyped_fnid() {
      return this.getRuleContext(0, Untyped_fnidContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_type_name_for_parameter;
    }
    enterRule(listener) {
      if (listener.enterType_name_for_parameter) {
        listener.enterType_name_for_parameter(this);
      }
    }
    exitRule(listener) {
      if (listener.exitType_name_for_parameter) {
        listener.exitType_name_for_parameter(this);
      }
    }
  };
  var Type_name_for_declare_parameterContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    INTEGER() {
      return this.getToken(QBasicParser.INTEGER, 0);
    }
    LONG() {
      return this.getToken(QBasicParser.LONG, 0);
    }
    SINGLE() {
      return this.getToken(QBasicParser.SINGLE, 0);
    }
    DOUBLE() {
      return this.getToken(QBasicParser.DOUBLE, 0);
    }
    STRING() {
      return this.getToken(QBasicParser.STRING, 0);
    }
    ANY() {
      return this.getToken(QBasicParser.ANY, 0);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    untyped_fnid() {
      return this.getRuleContext(0, Untyped_fnidContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_type_name_for_declare_parameter;
    }
    enterRule(listener) {
      if (listener.enterType_name_for_declare_parameter) {
        listener.enterType_name_for_declare_parameter(this);
      }
    }
    exitRule(listener) {
      if (listener.exitType_name_for_declare_parameter) {
        listener.exitType_name_for_declare_parameter(this);
      }
    }
  };
  var Type_name_for_def_fn_parameterContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    INTEGER() {
      return this.getToken(QBasicParser.INTEGER, 0);
    }
    LONG() {
      return this.getToken(QBasicParser.LONG, 0);
    }
    SINGLE() {
      return this.getToken(QBasicParser.SINGLE, 0);
    }
    DOUBLE() {
      return this.getToken(QBasicParser.DOUBLE, 0);
    }
    STRING() {
      return this.getToken(QBasicParser.STRING, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_type_name_for_def_fn_parameter;
    }
    enterRule(listener) {
      if (listener.enterType_name_for_def_fn_parameter) {
        listener.enterType_name_for_def_fn_parameter(this);
      }
    }
    exitRule(listener) {
      if (listener.exitType_name_for_def_fn_parameter) {
        listener.exitType_name_for_def_fn_parameter(this);
      }
    }
  };
  var Type_name_for_type_elementContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    INTEGER() {
      return this.getToken(QBasicParser.INTEGER, 0);
    }
    LONG() {
      return this.getToken(QBasicParser.LONG, 0);
    }
    SINGLE() {
      return this.getToken(QBasicParser.SINGLE, 0);
    }
    DOUBLE() {
      return this.getToken(QBasicParser.DOUBLE, 0);
    }
    fixed_string() {
      return this.getRuleContext(0, Fixed_stringContext);
    }
    untyped_id() {
      return this.getRuleContext(0, Untyped_idContext);
    }
    untyped_fnid() {
      return this.getRuleContext(0, Untyped_fnidContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_type_name_for_type_element;
    }
    enterRule(listener) {
      if (listener.enterType_name_for_type_element) {
        listener.enterType_name_for_type_element(this);
      }
    }
    exitRule(listener) {
      if (listener.exitType_name_for_type_element) {
        listener.exitType_name_for_type_element(this);
      }
    }
  };
  var File_numberContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    NUMBER() {
      return this.getToken(QBasicParser.NUMBER, 0);
    }
    expr() {
      return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
      return QBasicParser.RULE_file_number;
    }
    enterRule(listener) {
      if (listener.enterFile_number) {
        listener.enterFile_number(this);
      }
    }
    exitRule(listener) {
      if (listener.exitFile_number) {
        listener.exitFile_number(this);
      }
    }
  };
  var Fixed_stringContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    STRING() {
      return this.getToken(QBasicParser.STRING, 0);
    }
    TIMES() {
      return this.getToken(QBasicParser.TIMES, 0);
    }
    DIGITS() {
      return this.getToken(QBasicParser.DIGITS, 0);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_fixed_string;
    }
    enterRule(listener) {
      if (listener.enterFixed_string) {
        listener.enterFixed_string(this);
      }
    }
    exitRule(listener) {
      if (listener.exitFixed_string) {
        listener.exitFixed_string(this);
      }
    }
  };
  var Untyped_idContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    ID() {
      return this.getToken(QBasicParser.ID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_untyped_id;
    }
    enterRule(listener) {
      if (listener.enterUntyped_id) {
        listener.enterUntyped_id(this);
      }
    }
    exitRule(listener) {
      if (listener.exitUntyped_id) {
        listener.exitUntyped_id(this);
      }
    }
  };
  var Untyped_fnidContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    FNID() {
      return this.getToken(QBasicParser.FNID, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_untyped_fnid;
    }
    enterRule(listener) {
      if (listener.enterUntyped_fnid) {
        listener.enterUntyped_fnid(this);
      }
    }
    exitRule(listener) {
      if (listener.exitUntyped_fnid) {
        listener.exitUntyped_fnid(this);
      }
    }
  };
  var LiteralContext = class extends ParserRuleContext {
    constructor(parent, invokingState) {
      super(parent, invokingState);
    }
    PROBABLY_SINGLE_PRECISION_NUMBER() {
      return this.getToken(QBasicParser.PROBABLY_SINGLE_PRECISION_NUMBER, 0);
    }
    DOUBLE_PRECISION_NUMBER() {
      return this.getToken(QBasicParser.DOUBLE_PRECISION_NUMBER, 0);
    }
    DIGITS() {
      return this.getToken(QBasicParser.DIGITS, 0);
    }
    HEX() {
      return this.getToken(QBasicParser.HEX, 0);
    }
    OCTAL() {
      return this.getToken(QBasicParser.OCTAL, 0);
    }
    PERCENT() {
      return this.getToken(QBasicParser.PERCENT, 0);
    }
    AMP() {
      return this.getToken(QBasicParser.AMP, 0);
    }
    STRING_LITERAL() {
      return this.getToken(QBasicParser.STRING_LITERAL, 0);
    }
    get ruleIndex() {
      return QBasicParser.RULE_literal;
    }
    enterRule(listener) {
      if (listener.enterLiteral) {
        listener.enterLiteral(this);
      }
    }
    exitRule(listener) {
      if (listener.exitLiteral) {
        listener.exitLiteral(this);
      }
    }
  };

  // build/QBasicParserListener.ts
  var QBasicParserListener = class {
    /**
     * Enter a parse tree produced by `QBasicParser.program`.
     * @param ctx the parse tree
     */
    enterProgram;
    /**
     * Exit a parse tree produced by `QBasicParser.program`.
     * @param ctx the parse tree
     */
    exitProgram;
    /**
     * Enter a parse tree produced by `QBasicParser.block`.
     * @param ctx the parse tree
     */
    enterBlock;
    /**
     * Exit a parse tree produced by `QBasicParser.block`.
     * @param ctx the parse tree
     */
    exitBlock;
    /**
     * Enter a parse tree produced by `QBasicParser.label`.
     * @param ctx the parse tree
     */
    enterLabel;
    /**
     * Exit a parse tree produced by `QBasicParser.label`.
     * @param ctx the parse tree
     */
    exitLabel;
    /**
     * Enter a parse tree produced by `QBasicParser.line_number`.
     * @param ctx the parse tree
     */
    enterLine_number;
    /**
     * Exit a parse tree produced by `QBasicParser.line_number`.
     * @param ctx the parse tree
     */
    exitLine_number;
    /**
     * Enter a parse tree produced by `QBasicParser.text_label`.
     * @param ctx the parse tree
     */
    enterText_label;
    /**
     * Exit a parse tree produced by `QBasicParser.text_label`.
     * @param ctx the parse tree
     */
    exitText_label;
    /**
     * Enter a parse tree produced by `QBasicParser.statement`.
     * @param ctx the parse tree
     */
    enterStatement;
    /**
     * Exit a parse tree produced by `QBasicParser.statement`.
     * @param ctx the parse tree
     */
    exitStatement;
    /**
     * Enter a parse tree produced by `QBasicParser.declare_statement`.
     * @param ctx the parse tree
     */
    enterDeclare_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.declare_statement`.
     * @param ctx the parse tree
     */
    exitDeclare_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.declare_parameter_list`.
     * @param ctx the parse tree
     */
    enterDeclare_parameter_list;
    /**
     * Exit a parse tree produced by `QBasicParser.declare_parameter_list`.
     * @param ctx the parse tree
     */
    exitDeclare_parameter_list;
    /**
     * Enter a parse tree produced by `QBasicParser.declare_parameter`.
     * @param ctx the parse tree
     */
    enterDeclare_parameter;
    /**
     * Exit a parse tree produced by `QBasicParser.declare_parameter`.
     * @param ctx the parse tree
     */
    exitDeclare_parameter;
    /**
     * Enter a parse tree produced by `QBasicParser.def_fn_statement`.
     * @param ctx the parse tree
     */
    enterDef_fn_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.def_fn_statement`.
     * @param ctx the parse tree
     */
    exitDef_fn_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.def_fn_parameter_list`.
     * @param ctx the parse tree
     */
    enterDef_fn_parameter_list;
    /**
     * Exit a parse tree produced by `QBasicParser.def_fn_parameter_list`.
     * @param ctx the parse tree
     */
    exitDef_fn_parameter_list;
    /**
     * Enter a parse tree produced by `QBasicParser.def_fn_parameter`.
     * @param ctx the parse tree
     */
    enterDef_fn_parameter;
    /**
     * Exit a parse tree produced by `QBasicParser.def_fn_parameter`.
     * @param ctx the parse tree
     */
    exitDef_fn_parameter;
    /**
     * Enter a parse tree produced by `QBasicParser.function_statement`.
     * @param ctx the parse tree
     */
    enterFunction_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.function_statement`.
     * @param ctx the parse tree
     */
    exitFunction_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.parameter_list`.
     * @param ctx the parse tree
     */
    enterParameter_list;
    /**
     * Exit a parse tree produced by `QBasicParser.parameter_list`.
     * @param ctx the parse tree
     */
    exitParameter_list;
    /**
     * Enter a parse tree produced by `QBasicParser.parameter`.
     * @param ctx the parse tree
     */
    enterParameter;
    /**
     * Exit a parse tree produced by `QBasicParser.parameter`.
     * @param ctx the parse tree
     */
    exitParameter;
    /**
     * Enter a parse tree produced by `QBasicParser.array_declaration`.
     * @param ctx the parse tree
     */
    enterArray_declaration;
    /**
     * Exit a parse tree produced by `QBasicParser.array_declaration`.
     * @param ctx the parse tree
     */
    exitArray_declaration;
    /**
     * Enter a parse tree produced by `QBasicParser.end_function_statement`.
     * @param ctx the parse tree
     */
    enterEnd_function_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.end_function_statement`.
     * @param ctx the parse tree
     */
    exitEnd_function_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.if_block_statement`.
     * @param ctx the parse tree
     */
    enterIf_block_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.if_block_statement`.
     * @param ctx the parse tree
     */
    exitIf_block_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.elseif_block_statement`.
     * @param ctx the parse tree
     */
    enterElseif_block_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.elseif_block_statement`.
     * @param ctx the parse tree
     */
    exitElseif_block_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.else_block_statement`.
     * @param ctx the parse tree
     */
    enterElse_block_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.else_block_statement`.
     * @param ctx the parse tree
     */
    exitElse_block_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.end_if_statement`.
     * @param ctx the parse tree
     */
    enterEnd_if_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.end_if_statement`.
     * @param ctx the parse tree
     */
    exitEnd_if_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.then_block`.
     * @param ctx the parse tree
     */
    enterThen_block;
    /**
     * Exit a parse tree produced by `QBasicParser.then_block`.
     * @param ctx the parse tree
     */
    exitThen_block;
    /**
     * Enter a parse tree produced by `QBasicParser.else_block`.
     * @param ctx the parse tree
     */
    enterElse_block;
    /**
     * Exit a parse tree produced by `QBasicParser.else_block`.
     * @param ctx the parse tree
     */
    exitElse_block;
    /**
     * Enter a parse tree produced by `QBasicParser.option_statement`.
     * @param ctx the parse tree
     */
    enterOption_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.option_statement`.
     * @param ctx the parse tree
     */
    exitOption_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.sub_statement`.
     * @param ctx the parse tree
     */
    enterSub_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.sub_statement`.
     * @param ctx the parse tree
     */
    exitSub_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.end_sub_statement`.
     * @param ctx the parse tree
     */
    enterEnd_sub_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.end_sub_statement`.
     * @param ctx the parse tree
     */
    exitEnd_sub_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.type_statement`.
     * @param ctx the parse tree
     */
    enterType_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.type_statement`.
     * @param ctx the parse tree
     */
    exitType_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.type_element`.
     * @param ctx the parse tree
     */
    enterType_element;
    /**
     * Exit a parse tree produced by `QBasicParser.type_element`.
     * @param ctx the parse tree
     */
    exitType_element;
    /**
     * Enter a parse tree produced by `QBasicParser.assignment_statement`.
     * @param ctx the parse tree
     */
    enterAssignment_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.assignment_statement`.
     * @param ctx the parse tree
     */
    exitAssignment_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.call_statement`.
     * @param ctx the parse tree
     */
    enterCall_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.call_statement`.
     * @param ctx the parse tree
     */
    exitCall_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.call_argument_list`.
     * @param ctx the parse tree
     */
    enterCall_argument_list;
    /**
     * Exit a parse tree produced by `QBasicParser.call_argument_list`.
     * @param ctx the parse tree
     */
    exitCall_argument_list;
    /**
     * Enter a parse tree produced by `QBasicParser.call_argument`.
     * @param ctx the parse tree
     */
    enterCall_argument;
    /**
     * Exit a parse tree produced by `QBasicParser.call_argument`.
     * @param ctx the parse tree
     */
    exitCall_argument;
    /**
     * Enter a parse tree produced by `QBasicParser.call_absolute_statement`.
     * @param ctx the parse tree
     */
    enterCall_absolute_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.call_absolute_statement`.
     * @param ctx the parse tree
     */
    exitCall_absolute_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.call_absolute_argument_list`.
     * @param ctx the parse tree
     */
    enterCall_absolute_argument_list;
    /**
     * Exit a parse tree produced by `QBasicParser.call_absolute_argument_list`.
     * @param ctx the parse tree
     */
    exitCall_absolute_argument_list;
    /**
     * Enter a parse tree produced by `QBasicParser.error_statement`.
     * @param ctx the parse tree
     */
    enterError_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.error_statement`.
     * @param ctx the parse tree
     */
    exitError_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.event_control_statement`.
     * @param ctx the parse tree
     */
    enterEvent_control_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.event_control_statement`.
     * @param ctx the parse tree
     */
    exitEvent_control_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.circle_statement`.
     * @param ctx the parse tree
     */
    enterCircle_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.circle_statement`.
     * @param ctx the parse tree
     */
    exitCircle_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.clear_statement`.
     * @param ctx the parse tree
     */
    enterClear_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.clear_statement`.
     * @param ctx the parse tree
     */
    exitClear_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.close_statement`.
     * @param ctx the parse tree
     */
    enterClose_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.close_statement`.
     * @param ctx the parse tree
     */
    exitClose_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.color_statement`.
     * @param ctx the parse tree
     */
    enterColor_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.color_statement`.
     * @param ctx the parse tree
     */
    exitColor_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.const_statement`.
     * @param ctx the parse tree
     */
    enterConst_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.const_statement`.
     * @param ctx the parse tree
     */
    exitConst_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.const_assignment`.
     * @param ctx the parse tree
     */
    enterConst_assignment;
    /**
     * Exit a parse tree produced by `QBasicParser.const_assignment`.
     * @param ctx the parse tree
     */
    exitConst_assignment;
    /**
     * Enter a parse tree produced by `QBasicParser.const_expr`.
     * @param ctx the parse tree
     */
    enterConst_expr;
    /**
     * Exit a parse tree produced by `QBasicParser.const_expr`.
     * @param ctx the parse tree
     */
    exitConst_expr;
    /**
     * Enter a parse tree produced by `QBasicParser.data_statement`.
     * @param ctx the parse tree
     */
    enterData_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.data_statement`.
     * @param ctx the parse tree
     */
    exitData_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.data_item`.
     * @param ctx the parse tree
     */
    enterData_item;
    /**
     * Exit a parse tree produced by `QBasicParser.data_item`.
     * @param ctx the parse tree
     */
    exitData_item;
    /**
     * Enter a parse tree produced by `QBasicParser.def_seg_statement`.
     * @param ctx the parse tree
     */
    enterDef_seg_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.def_seg_statement`.
     * @param ctx the parse tree
     */
    exitDef_seg_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.deftype_statement`.
     * @param ctx the parse tree
     */
    enterDeftype_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.deftype_statement`.
     * @param ctx the parse tree
     */
    exitDeftype_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.letter_range`.
     * @param ctx the parse tree
     */
    enterLetter_range;
    /**
     * Exit a parse tree produced by `QBasicParser.letter_range`.
     * @param ctx the parse tree
     */
    exitLetter_range;
    /**
     * Enter a parse tree produced by `QBasicParser.dim_statement`.
     * @param ctx the parse tree
     */
    enterDim_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.dim_statement`.
     * @param ctx the parse tree
     */
    exitDim_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.dim_variable`.
     * @param ctx the parse tree
     */
    enterDim_variable;
    /**
     * Exit a parse tree produced by `QBasicParser.dim_variable`.
     * @param ctx the parse tree
     */
    exitDim_variable;
    /**
     * Enter a parse tree produced by `QBasicParser.dim_array_bounds`.
     * @param ctx the parse tree
     */
    enterDim_array_bounds;
    /**
     * Exit a parse tree produced by `QBasicParser.dim_array_bounds`.
     * @param ctx the parse tree
     */
    exitDim_array_bounds;
    /**
     * Enter a parse tree produced by `QBasicParser.dim_subscript`.
     * @param ctx the parse tree
     */
    enterDim_subscript;
    /**
     * Exit a parse tree produced by `QBasicParser.dim_subscript`.
     * @param ctx the parse tree
     */
    exitDim_subscript;
    /**
     * Enter a parse tree produced by `QBasicParser.do_loop_statement`.
     * @param ctx the parse tree
     */
    enterDo_loop_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.do_loop_statement`.
     * @param ctx the parse tree
     */
    exitDo_loop_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.do_condition`.
     * @param ctx the parse tree
     */
    enterDo_condition;
    /**
     * Exit a parse tree produced by `QBasicParser.do_condition`.
     * @param ctx the parse tree
     */
    exitDo_condition;
    /**
     * Enter a parse tree produced by `QBasicParser.end_statement`.
     * @param ctx the parse tree
     */
    enterEnd_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.end_statement`.
     * @param ctx the parse tree
     */
    exitEnd_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.exit_statement`.
     * @param ctx the parse tree
     */
    enterExit_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.exit_statement`.
     * @param ctx the parse tree
     */
    exitExit_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.field_statement`.
     * @param ctx the parse tree
     */
    enterField_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.field_statement`.
     * @param ctx the parse tree
     */
    exitField_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.field_assignment`.
     * @param ctx the parse tree
     */
    enterField_assignment;
    /**
     * Exit a parse tree produced by `QBasicParser.field_assignment`.
     * @param ctx the parse tree
     */
    exitField_assignment;
    /**
     * Enter a parse tree produced by `QBasicParser.for_next_statement`.
     * @param ctx the parse tree
     */
    enterFor_next_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.for_next_statement`.
     * @param ctx the parse tree
     */
    exitFor_next_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.get_graphics_statement`.
     * @param ctx the parse tree
     */
    enterGet_graphics_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.get_graphics_statement`.
     * @param ctx the parse tree
     */
    exitGet_graphics_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.get_io_statement`.
     * @param ctx the parse tree
     */
    enterGet_io_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.get_io_statement`.
     * @param ctx the parse tree
     */
    exitGet_io_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.gosub_statement`.
     * @param ctx the parse tree
     */
    enterGosub_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.gosub_statement`.
     * @param ctx the parse tree
     */
    exitGosub_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.goto_statement`.
     * @param ctx the parse tree
     */
    enterGoto_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.goto_statement`.
     * @param ctx the parse tree
     */
    exitGoto_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.target`.
     * @param ctx the parse tree
     */
    enterTarget;
    /**
     * Exit a parse tree produced by `QBasicParser.target`.
     * @param ctx the parse tree
     */
    exitTarget;
    /**
     * Enter a parse tree produced by `QBasicParser.if_inline_statement`.
     * @param ctx the parse tree
     */
    enterIf_inline_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.if_inline_statement`.
     * @param ctx the parse tree
     */
    exitIf_inline_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.if_inline_action`.
     * @param ctx the parse tree
     */
    enterIf_inline_action;
    /**
     * Exit a parse tree produced by `QBasicParser.if_inline_action`.
     * @param ctx the parse tree
     */
    exitIf_inline_action;
    /**
     * Enter a parse tree produced by `QBasicParser.input_statement`.
     * @param ctx the parse tree
     */
    enterInput_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.input_statement`.
     * @param ctx the parse tree
     */
    exitInput_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.ioctl_statement`.
     * @param ctx the parse tree
     */
    enterIoctl_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.ioctl_statement`.
     * @param ctx the parse tree
     */
    exitIoctl_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.key_statement`.
     * @param ctx the parse tree
     */
    enterKey_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.key_statement`.
     * @param ctx the parse tree
     */
    exitKey_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.line_statement`.
     * @param ctx the parse tree
     */
    enterLine_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.line_statement`.
     * @param ctx the parse tree
     */
    exitLine_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.box_style`.
     * @param ctx the parse tree
     */
    enterBox_style;
    /**
     * Exit a parse tree produced by `QBasicParser.box_style`.
     * @param ctx the parse tree
     */
    exitBox_style;
    /**
     * Enter a parse tree produced by `QBasicParser.line_input_statement`.
     * @param ctx the parse tree
     */
    enterLine_input_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.line_input_statement`.
     * @param ctx the parse tree
     */
    exitLine_input_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.locate_statement`.
     * @param ctx the parse tree
     */
    enterLocate_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.locate_statement`.
     * @param ctx the parse tree
     */
    exitLocate_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.lock_statement`.
     * @param ctx the parse tree
     */
    enterLock_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.lock_statement`.
     * @param ctx the parse tree
     */
    exitLock_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.lprint_statement`.
     * @param ctx the parse tree
     */
    enterLprint_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.lprint_statement`.
     * @param ctx the parse tree
     */
    exitLprint_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.lprint_using_statement`.
     * @param ctx the parse tree
     */
    enterLprint_using_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.lprint_using_statement`.
     * @param ctx the parse tree
     */
    exitLprint_using_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.lset_statement`.
     * @param ctx the parse tree
     */
    enterLset_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.lset_statement`.
     * @param ctx the parse tree
     */
    exitLset_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.mid_statement`.
     * @param ctx the parse tree
     */
    enterMid_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.mid_statement`.
     * @param ctx the parse tree
     */
    exitMid_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.name_statement`.
     * @param ctx the parse tree
     */
    enterName_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.name_statement`.
     * @param ctx the parse tree
     */
    exitName_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.on_error_statement`.
     * @param ctx the parse tree
     */
    enterOn_error_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.on_error_statement`.
     * @param ctx the parse tree
     */
    exitOn_error_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.on_event_gosub_statement`.
     * @param ctx the parse tree
     */
    enterOn_event_gosub_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.on_event_gosub_statement`.
     * @param ctx the parse tree
     */
    exitOn_event_gosub_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.on_expr_gosub_statement`.
     * @param ctx the parse tree
     */
    enterOn_expr_gosub_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.on_expr_gosub_statement`.
     * @param ctx the parse tree
     */
    exitOn_expr_gosub_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.target_list`.
     * @param ctx the parse tree
     */
    enterTarget_list;
    /**
     * Exit a parse tree produced by `QBasicParser.target_list`.
     * @param ctx the parse tree
     */
    exitTarget_list;
    /**
     * Enter a parse tree produced by `QBasicParser.on_expr_goto_statement`.
     * @param ctx the parse tree
     */
    enterOn_expr_goto_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.on_expr_goto_statement`.
     * @param ctx the parse tree
     */
    exitOn_expr_goto_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.open_legacy_statement`.
     * @param ctx the parse tree
     */
    enterOpen_legacy_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.open_legacy_statement`.
     * @param ctx the parse tree
     */
    exitOpen_legacy_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.open_statement`.
     * @param ctx the parse tree
     */
    enterOpen_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.open_statement`.
     * @param ctx the parse tree
     */
    exitOpen_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.open_mode`.
     * @param ctx the parse tree
     */
    enterOpen_mode;
    /**
     * Exit a parse tree produced by `QBasicParser.open_mode`.
     * @param ctx the parse tree
     */
    exitOpen_mode;
    /**
     * Enter a parse tree produced by `QBasicParser.open_access`.
     * @param ctx the parse tree
     */
    enterOpen_access;
    /**
     * Exit a parse tree produced by `QBasicParser.open_access`.
     * @param ctx the parse tree
     */
    exitOpen_access;
    /**
     * Enter a parse tree produced by `QBasicParser.open_lock`.
     * @param ctx the parse tree
     */
    enterOpen_lock;
    /**
     * Exit a parse tree produced by `QBasicParser.open_lock`.
     * @param ctx the parse tree
     */
    exitOpen_lock;
    /**
     * Enter a parse tree produced by `QBasicParser.paint_statement`.
     * @param ctx the parse tree
     */
    enterPaint_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.paint_statement`.
     * @param ctx the parse tree
     */
    exitPaint_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.palette_statement`.
     * @param ctx the parse tree
     */
    enterPalette_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.palette_statement`.
     * @param ctx the parse tree
     */
    exitPalette_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.play_statement`.
     * @param ctx the parse tree
     */
    enterPlay_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.play_statement`.
     * @param ctx the parse tree
     */
    exitPlay_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.preset_statement`.
     * @param ctx the parse tree
     */
    enterPreset_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.preset_statement`.
     * @param ctx the parse tree
     */
    exitPreset_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.print_statement`.
     * @param ctx the parse tree
     */
    enterPrint_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.print_statement`.
     * @param ctx the parse tree
     */
    exitPrint_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.print_using_statement`.
     * @param ctx the parse tree
     */
    enterPrint_using_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.print_using_statement`.
     * @param ctx the parse tree
     */
    exitPrint_using_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.pset_statement`.
     * @param ctx the parse tree
     */
    enterPset_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.pset_statement`.
     * @param ctx the parse tree
     */
    exitPset_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.put_graphics_statement`.
     * @param ctx the parse tree
     */
    enterPut_graphics_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.put_graphics_statement`.
     * @param ctx the parse tree
     */
    exitPut_graphics_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.put_io_statement`.
     * @param ctx the parse tree
     */
    enterPut_io_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.put_io_statement`.
     * @param ctx the parse tree
     */
    exitPut_io_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.read_statement`.
     * @param ctx the parse tree
     */
    enterRead_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.read_statement`.
     * @param ctx the parse tree
     */
    exitRead_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.rem_statement`.
     * @param ctx the parse tree
     */
    enterRem_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.rem_statement`.
     * @param ctx the parse tree
     */
    exitRem_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.resume_statement`.
     * @param ctx the parse tree
     */
    enterResume_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.resume_statement`.
     * @param ctx the parse tree
     */
    exitResume_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.return_statement`.
     * @param ctx the parse tree
     */
    enterReturn_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.return_statement`.
     * @param ctx the parse tree
     */
    exitReturn_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.rset_statement`.
     * @param ctx the parse tree
     */
    enterRset_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.rset_statement`.
     * @param ctx the parse tree
     */
    exitRset_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.select_case_statement`.
     * @param ctx the parse tree
     */
    enterSelect_case_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.select_case_statement`.
     * @param ctx the parse tree
     */
    exitSelect_case_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.before_first_case`.
     * @param ctx the parse tree
     */
    enterBefore_first_case;
    /**
     * Exit a parse tree produced by `QBasicParser.before_first_case`.
     * @param ctx the parse tree
     */
    exitBefore_first_case;
    /**
     * Enter a parse tree produced by `QBasicParser.case_block`.
     * @param ctx the parse tree
     */
    enterCase_block;
    /**
     * Exit a parse tree produced by `QBasicParser.case_block`.
     * @param ctx the parse tree
     */
    exitCase_block;
    /**
     * Enter a parse tree produced by `QBasicParser.case_statement`.
     * @param ctx the parse tree
     */
    enterCase_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.case_statement`.
     * @param ctx the parse tree
     */
    exitCase_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.case_expr`.
     * @param ctx the parse tree
     */
    enterCase_expr;
    /**
     * Exit a parse tree produced by `QBasicParser.case_expr`.
     * @param ctx the parse tree
     */
    exitCase_expr;
    /**
     * Enter a parse tree produced by `QBasicParser.end_select_statement`.
     * @param ctx the parse tree
     */
    enterEnd_select_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.end_select_statement`.
     * @param ctx the parse tree
     */
    exitEnd_select_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.scope_statement`.
     * @param ctx the parse tree
     */
    enterScope_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.scope_statement`.
     * @param ctx the parse tree
     */
    exitScope_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.block_name`.
     * @param ctx the parse tree
     */
    enterBlock_name;
    /**
     * Exit a parse tree produced by `QBasicParser.block_name`.
     * @param ctx the parse tree
     */
    exitBlock_name;
    /**
     * Enter a parse tree produced by `QBasicParser.scope_variable`.
     * @param ctx the parse tree
     */
    enterScope_variable;
    /**
     * Exit a parse tree produced by `QBasicParser.scope_variable`.
     * @param ctx the parse tree
     */
    exitScope_variable;
    /**
     * Enter a parse tree produced by `QBasicParser.screen_statement`.
     * @param ctx the parse tree
     */
    enterScreen_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.screen_statement`.
     * @param ctx the parse tree
     */
    exitScreen_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.seek_statement`.
     * @param ctx the parse tree
     */
    enterSeek_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.seek_statement`.
     * @param ctx the parse tree
     */
    exitSeek_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.stop_statement`.
     * @param ctx the parse tree
     */
    enterStop_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.stop_statement`.
     * @param ctx the parse tree
     */
    exitStop_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.unlock_statement`.
     * @param ctx the parse tree
     */
    enterUnlock_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.unlock_statement`.
     * @param ctx the parse tree
     */
    exitUnlock_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.view_statement`.
     * @param ctx the parse tree
     */
    enterView_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.view_statement`.
     * @param ctx the parse tree
     */
    exitView_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.view_print_statement`.
     * @param ctx the parse tree
     */
    enterView_print_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.view_print_statement`.
     * @param ctx the parse tree
     */
    exitView_print_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.while_wend_statement`.
     * @param ctx the parse tree
     */
    enterWhile_wend_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.while_wend_statement`.
     * @param ctx the parse tree
     */
    exitWhile_wend_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.width_statement`.
     * @param ctx the parse tree
     */
    enterWidth_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.width_statement`.
     * @param ctx the parse tree
     */
    exitWidth_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.window_statement`.
     * @param ctx the parse tree
     */
    enterWindow_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.window_statement`.
     * @param ctx the parse tree
     */
    exitWindow_statement;
    /**
     * Enter a parse tree produced by `QBasicParser.write_statement`.
     * @param ctx the parse tree
     */
    enterWrite_statement;
    /**
     * Exit a parse tree produced by `QBasicParser.write_statement`.
     * @param ctx the parse tree
     */
    exitWrite_statement;
    /**
     * Enter a parse tree produced by the `AndExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterAndExpr;
    /**
     * Exit a parse tree produced by the `AndExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitAndExpr;
    /**
     * Enter a parse tree produced by the `ValueExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterValueExpr;
    /**
     * Exit a parse tree produced by the `ValueExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitValueExpr;
    /**
     * Enter a parse tree produced by the `ComparisonExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterComparisonExpr;
    /**
     * Exit a parse tree produced by the `ComparisonExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitComparisonExpr;
    /**
     * Enter a parse tree produced by the `XorExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterXorExpr;
    /**
     * Exit a parse tree produced by the `XorExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitXorExpr;
    /**
     * Enter a parse tree produced by the `PlusMinusExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterPlusMinusExpr;
    /**
     * Exit a parse tree produced by the `PlusMinusExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitPlusMinusExpr;
    /**
     * Enter a parse tree produced by the `OrExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterOrExpr;
    /**
     * Exit a parse tree produced by the `OrExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitOrExpr;
    /**
     * Enter a parse tree produced by the `VarCallExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterVarCallExpr;
    /**
     * Exit a parse tree produced by the `VarCallExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitVarCallExpr;
    /**
     * Enter a parse tree produced by the `ImpExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterImpExpr;
    /**
     * Exit a parse tree produced by the `ImpExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitImpExpr;
    /**
     * Enter a parse tree produced by the `ExponentExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterExponentExpr;
    /**
     * Exit a parse tree produced by the `ExponentExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitExponentExpr;
    /**
     * Enter a parse tree produced by the `UnaryPlusExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterUnaryPlusExpr;
    /**
     * Exit a parse tree produced by the `UnaryPlusExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitUnaryPlusExpr;
    /**
     * Enter a parse tree produced by the `NotExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterNotExpr;
    /**
     * Exit a parse tree produced by the `NotExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitNotExpr;
    /**
     * Enter a parse tree produced by the `ModExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterModExpr;
    /**
     * Exit a parse tree produced by the `ModExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitModExpr;
    /**
     * Enter a parse tree produced by the `ParenExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterParenExpr;
    /**
     * Exit a parse tree produced by the `ParenExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitParenExpr;
    /**
     * Enter a parse tree produced by the `MultiplyDivideExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterMultiplyDivideExpr;
    /**
     * Exit a parse tree produced by the `MultiplyDivideExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitMultiplyDivideExpr;
    /**
     * Enter a parse tree produced by the `IntegerDivideExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterIntegerDivideExpr;
    /**
     * Exit a parse tree produced by the `IntegerDivideExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitIntegerDivideExpr;
    /**
     * Enter a parse tree produced by the `BuiltinExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterBuiltinExpr;
    /**
     * Exit a parse tree produced by the `BuiltinExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitBuiltinExpr;
    /**
     * Enter a parse tree produced by the `EqvExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterEqvExpr;
    /**
     * Exit a parse tree produced by the `EqvExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitEqvExpr;
    /**
     * Enter a parse tree produced by the `UnaryMinusExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    enterUnaryMinusExpr;
    /**
     * Exit a parse tree produced by the `UnaryMinusExpr`
     * labeled alternative in `QBasicParser.expr`.
     * @param ctx the parse tree
     */
    exitUnaryMinusExpr;
    /**
     * Enter a parse tree produced by `QBasicParser.builtin_function`.
     * @param ctx the parse tree
     */
    enterBuiltin_function;
    /**
     * Exit a parse tree produced by `QBasicParser.builtin_function`.
     * @param ctx the parse tree
     */
    exitBuiltin_function;
    /**
     * Enter a parse tree produced by `QBasicParser.args_or_indices`.
     * @param ctx the parse tree
     */
    enterArgs_or_indices;
    /**
     * Exit a parse tree produced by `QBasicParser.args_or_indices`.
     * @param ctx the parse tree
     */
    exitArgs_or_indices;
    /**
     * Enter a parse tree produced by `QBasicParser.variable_or_function_call`.
     * @param ctx the parse tree
     */
    enterVariable_or_function_call;
    /**
     * Exit a parse tree produced by `QBasicParser.variable_or_function_call`.
     * @param ctx the parse tree
     */
    exitVariable_or_function_call;
    /**
     * Enter a parse tree produced by `QBasicParser.type_name`.
     * @param ctx the parse tree
     */
    enterType_name;
    /**
     * Exit a parse tree produced by `QBasicParser.type_name`.
     * @param ctx the parse tree
     */
    exitType_name;
    /**
     * Enter a parse tree produced by `QBasicParser.type_name_for_parameter`.
     * @param ctx the parse tree
     */
    enterType_name_for_parameter;
    /**
     * Exit a parse tree produced by `QBasicParser.type_name_for_parameter`.
     * @param ctx the parse tree
     */
    exitType_name_for_parameter;
    /**
     * Enter a parse tree produced by `QBasicParser.type_name_for_declare_parameter`.
     * @param ctx the parse tree
     */
    enterType_name_for_declare_parameter;
    /**
     * Exit a parse tree produced by `QBasicParser.type_name_for_declare_parameter`.
     * @param ctx the parse tree
     */
    exitType_name_for_declare_parameter;
    /**
     * Enter a parse tree produced by `QBasicParser.type_name_for_def_fn_parameter`.
     * @param ctx the parse tree
     */
    enterType_name_for_def_fn_parameter;
    /**
     * Exit a parse tree produced by `QBasicParser.type_name_for_def_fn_parameter`.
     * @param ctx the parse tree
     */
    exitType_name_for_def_fn_parameter;
    /**
     * Enter a parse tree produced by `QBasicParser.type_name_for_type_element`.
     * @param ctx the parse tree
     */
    enterType_name_for_type_element;
    /**
     * Exit a parse tree produced by `QBasicParser.type_name_for_type_element`.
     * @param ctx the parse tree
     */
    exitType_name_for_type_element;
    /**
     * Enter a parse tree produced by `QBasicParser.file_number`.
     * @param ctx the parse tree
     */
    enterFile_number;
    /**
     * Exit a parse tree produced by `QBasicParser.file_number`.
     * @param ctx the parse tree
     */
    exitFile_number;
    /**
     * Enter a parse tree produced by `QBasicParser.fixed_string`.
     * @param ctx the parse tree
     */
    enterFixed_string;
    /**
     * Exit a parse tree produced by `QBasicParser.fixed_string`.
     * @param ctx the parse tree
     */
    exitFixed_string;
    /**
     * Enter a parse tree produced by `QBasicParser.untyped_id`.
     * @param ctx the parse tree
     */
    enterUntyped_id;
    /**
     * Exit a parse tree produced by `QBasicParser.untyped_id`.
     * @param ctx the parse tree
     */
    exitUntyped_id;
    /**
     * Enter a parse tree produced by `QBasicParser.untyped_fnid`.
     * @param ctx the parse tree
     */
    enterUntyped_fnid;
    /**
     * Exit a parse tree produced by `QBasicParser.untyped_fnid`.
     * @param ctx the parse tree
     */
    exitUntyped_fnid;
    /**
     * Enter a parse tree produced by `QBasicParser.literal`.
     * @param ctx the parse tree
     */
    enterLiteral;
    /**
     * Exit a parse tree produced by `QBasicParser.literal`.
     * @param ctx the parse tree
     */
    exitLiteral;
    visitTerminal(node) {
    }
    visitErrorNode(node) {
    }
    enterEveryRule(node) {
    }
    exitEveryRule(node) {
    }
  };

  // src/Interpreter.ts
  var Interpreter = class extends QBasicParserListener {
    constructor() {
      super();
    }
    run(text) {
      const textWithNewline = text.endsWith("\n") ? text : text + "\n";
      const inputStream = CharStream.fromString(textWithNewline);
      const lexer = new QBasicLexer(inputStream);
      const tokenStream = new CommonTokenStream(lexer);
      const parser = new QBasicParser(tokenStream);
      parser.addParseListener(this);
      parser.program();
    }
    exprStack = [];
    exitPrint_statement = (ctx) => {
      console.log(this.exprStack.pop());
    };
    exitPlusMinusExpr = (ctx) => {
      const a = this.exprStack.pop();
      const op = ctx.getChild(1).getText();
      const b = this.exprStack.pop();
      this.exprStack.push(op == "+" ? a + b : a - b);
    };
    exitValueExpr = (ctx) => {
      const value = ctx.getText();
      if (value.startsWith('"') && value.endsWith('"')) {
        this.exprStack.push(value.substring(1, value.length - 1));
        return;
      }
      this.exprStack.push(+value);
    };
  };

  // src/Shell.ts
  var Shell = class {
    root;
    codePane;
    interpreter;
    constructor(root) {
      this.root = root;
      this.interpreter = new Interpreter();
      this.codePane = root.querySelector(".code-pane");
      const runButton = root.querySelector(".run-button");
      runButton.addEventListener("click", () => this.run());
    }
    run() {
      const text = this.codePane.innerText;
      this.interpreter.run(text);
    }
  };
  document.addEventListener("DOMContentLoaded", () => {
    const shell = new Shell(document.querySelector(".shell"));
  });
})();
//# sourceMappingURL=bundle.js.map
