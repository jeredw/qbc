<!doctype html>
<html>
<head>
<title>qbasic.run - Help</title>
<link rel="preload" href="/WebPlus_IBM_VGA_8x16.woff" as="font" type="font/woff" crossorigin />
<link href="help.css" rel="stylesheet">
</head>
<body>
<p>If you are reading this, you must truly need help.  I'll do my best.
<p>
  <a href="#quick-start">Quick Start</a>
  <a href="#types">Builtin Types</a>
  <a href="#values">Literal Values</a>
  <a href="#arith-ops">Arithmetic Operators</a>
  <a href="#comparison-ops">Comparison Operators</a>
  <a href="#logic-ops">Logical Operators</a>
  <a href="#conversions">Type Conversions</a>
  <a href="#user-types">User-defined Types</a>
  <a href="#constants">Named Constants</a>
  <a href="#variables">Variables</a>
  <a href="#arrays">Arrays</a>
  <a href="#encodings">Character Encodings</a>
  <a href="#precision">Precision</a>

<p>These books written by actual technical writers are really good, though
somewhat dated and presuming less general technical knowledge and perhaps more
nicotine and hairspray use than are now the norm.
<ul>
<li><a target="_blank"
href="https://www.pcjs.org/documents/books/mspl13/basic/qblang/">Microsoft
QuickBASIC: Language Reference</a>
<li><a target="_blank"
href="https://www.pcjs.org/documents/books/mspl13/basic/qbprog/">Microsoft
QuickBASIC: Programming in BASIC</a>
</ul>

<h2 id="quick-start">Quick Start</h2>

<p>Here's a simple program so you can see what we're dealing with.

<pre>
' This is a procedure (a subroutine) named PrintKey.
' It takes one string parameter k$ and shows its value on
' the screen.
SUB PrintKey (k$)
  PRINT "You pressed "; k$
END SUB

DO
  ' Call the builtin function INKEY$ to read whatever key
  ' is pending from the keyboard.
  k$ = INKEY$
  IF k$ <> "" THEN
    ' If key is not empty, call our subroutine to display it.
    PrintKey k$
  END IF
' Loop until a key is pressed.
LOOP WHILE k$ = ""
</pre>

<p>QBasic is a <a class="keyword" href="#types">statically typed</a> procedural
language with block structure and two levels of scope. Global variables exist
the entire time a program is running, and are only visible outside procedures.
Local variables are allocated on a stack each time a procedure is called, and
only exist during that call.

<p>Variables are implicitly defined the first time they are used, but can also
be declared before use. Variable declarations can change default scope behavior.
Globals can be made visible by declaring them <a class="keyword"
href="#shared">SHARED</a> with all
procedures or within specific procedures. Locals declared <a class="keyword"
href="#static">STATIC</a> persist after procedure calls. Globals declared <a
class="keyword" href="#common">COMMON</a> can persist after a program finishes,
by being passed to another program (no, really).

<p>By default, procedure parameters are passed by reference.

<pre>
' Increment adds 1 to its integer parameter.
SUB Increment (i%)
  ' This i% refers to the global j%, so modifying it
  ' will also modify j%
  i% = i% + 1
END SUB

j% = 41
Increment j%
PRINT j%  ' Prints 42.
</pre>

<p>Procedures defined with <a class="keyword" href="#function">FUNCTION</a>
return a value instead of just modifying their parameters.

<pre>
' Increment% returns its integer parameter's value + 1.
FUNCTION Increment% (i%)
  ' Return by assigning to the function name.
  Increment% = i% + 1
END FUNCTION

PRINT Increment(41)  ' Prints 42.
</pre>

<p>QBasic also supports some older procedure constructs <a class="keyword"
href="#deffn">DEF FN</a> and <a class="keyword" href="#gosub">GOSUB</a>.</p>
<p>Older BASICs use line numbers and <a class="keyword" href="#goto">GOTO</a>
statements heavily, but QBasic prefers block structured programming constructs
like <a class="keyword" href="#blockif">IF...END IF</a>, <a class="keyword"
href="#blockdo">DO...LOOP</a>, <a class="keyword"
href="#for">FOR...NEXT</a>.

<pre>
FOR i = 1 to 10
  IF foo THEN
    ' Do this if foo is true ...
  ELSE IF bar THEN
    ' Otherwise, do this if bar is true ...
  ELSE
    ' Otherwise, do this ...
  END IF
NEXT i
</pre>

<h3 id="types">Builtin Types</h3>

<p>All values in QBasic programs have an associated type which is determined at
compile time.

<table>
  <tr>
    <th>Type name</th>
    <th>Sigil</th>
    <th>Range</th>
    <th>Size</th>
  </tr>
  <tr>
    <td><code>INTEGER</code></td>
    <td>%</td>
    <td>
      16-bit signed integer<br>
      -32768 to 32767
    </td>
    <td>2 bytes</td>
  </tr>
  <tr>
    <td><code>LONG</code></td>
    <td>&</td>
    <td>32-bit signed integer<br>
      -2147483648 to 2147483647</td>
    <td>4 bytes</td>
  </tr>
  <tr>
    <td><code>SINGLE</code></td>
    <td>!</td>
    <td>
      Single-precision float<br>
      -3.402823e+38 to 3.402823e+38
    </td>
    <td>4 bytes</td>
  </tr>
  <tr>
    <td><code>DOUBLE</code></td>
    <td>#</td>
    <td>Double-precision float</td>
    <td>8 bytes</td>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td>$</td>
    <td>Variable length string<br>up to 32767 bytes</td>
    <td>?</td>
  </tr>
  <tr>
    <td><code>STRING * n%</code></td>
    <td>$</td>
    <td>Fixed length string</td>
    <td>n% bytes</td>
  </tr>
</table>

<p id="sigil">A value's type can be specified by putting a sigil character after it.

<pre>
PRINT 320& * 200&  ' Impossibly huge 32-bit numbers.
</pre>

<h3 id="values">Literal values</h3>

<p>QBasic operates on signed integers, floating point numbers (floats), and
strings.

<p>A base ten number with no decimal point and no sigil is read as the smallest
type that fits it: an integer, a long, or a double.  But note -32768 is read as
a long, and -2147483648 as a double.  Integers can be given in hex by prefixing
them with <code>&H</code> and octal by prefixing them with <code>&O</code>.
Hex and octal numbers are implicitly signed, so &HFFFF = -1%.  To get 65535, you
have to use &HFFFF&.

<p>Numbers with a decimal point like 3.14 or numbers in scientific notation like
6.02E23 are floats.  Decimals are read as singles if they have 7 or fewer
digits, else doubles.  Scientific notation numbers are singles if they use E to
mark the exponent, and doubles if they use D.  If you try to write an E-number
with more than 7 digits, QBasic changes E to D when you press enter.

<pre>
PRINT 42        ' integer
PRINT 32768     ' long
PRINT 3.142857  ' single
PRINT 6.02e23   ' single
PRINT 6.02d23   ' double
</pre>

<p>Strings are groups of bytes which may either be binary data or text.
Variable-length strings are stored along with a 16-bit integer length, so they
may include NUL characters.

<pre>
s$ = "I am a string."
' To put quotes in a string, use CHR$(34).
t$ = CHR$(34) + "I say," + CHR$(34) + " he said."
' Strings can contain arbitrary bytes.
u$ = CHR$(0) + CHR$(26)
</pre>

<p>The + operator concatenates two strings into a new string.

<p>See this note for more details about how qbasic.run handles <a class="keyword"
href="#encodings">character encodings</a>.

<h3 id="arith-ops">Arithmetic Operators</h3>

<table>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Result Type</th>
  </tr>
  <tr>
    <td><code>a + b</code></td>
    <td>Addition</td>
    <td>Most precise of a or b</td>
  </tr>
  <tr>
    <td><code>a - b</code></td>
    <td>Subtraction</td>
    <td>Most precise of a or b</td>
  </tr>
  <tr>
    <td><code>a * b</code></td>
    <td>Multiplication</td>
    <td>Most precise of a or b</td>
  </tr>
  <tr>
    <td><code>a / b</code></td>
    <td>Floating point division</td>
    <td>a or b DOUBLE -> DOUBLE<br>
        otherwise SINGLE</td>
  </tr>
  <tr>
    <td><code>a \ b</code></td>
    <td>Integer division</td>
    <td>a and b INTEGER -> INTEGER<br>
        otherwise LONG</td>
  </tr>
  <tr>
    <td><code>a MOD b</code></td>
    <td>Integer remainder</td>
    <td>a and b INTEGER -> INTEGER<br>
        otherwise LONG</td>
  </tr>
  <tr>
    <td><code>a ^ b</code></td>
    <td>Floating point exponent</td>
    <td>a or b DOUBLE -> DOUBLE<br>
        otherwise SINGLE</td>
  </tr>
  <tr>
    <td><code>-a</code></td>
    <td>Negation</td>
    <td>a</td>
  </tr>
</table>

<p>(For "most precise", DOUBLE > SINGLE > LONG > INTEGER.)

<p>Arithmetic precision is determined by operand types, which can be confusing.

<pre>
PRINT 320 * 200  ' Overflow error!
</pre>

<p>A runtime error occurs if math operations overflow.  In the example above,
320 and 200 are both 16-bit signed integers, but their product 64000 > 32767.
Similarly, there are runtime errors for division by zero and 0 ^ -k.

<p>If operands do not have the correct types, QBasic automatically converts them
first.  For example, this means double operands for integer division must fit in
a long.

<pre>
PRINT 2147483648# \ 2#  ' Overflow error!
</pre>

There are a few more details about qbasic.run artihmetic <a class="keyword"
href="#precision">precision</a>.

<h3 id="comparison-ops">Comparison Operators</h3>

<table>
  <tr>
    <th>Operator</th>
    <th>Description</th>
  </tr>
  <tr></tr>
    <td><code>a = b</code></td>
    <td>Equals</td>
  </tr>
  <tr>
    <td><code>a &lt; b</code></td>
    <td>Less than</td>
  </tr>
  <tr>
    <td><code>a &lt;= b</code></td>
    <td>Less than or equal</td>
  </tr>
  <tr>
    <td><code>a &lt;&gt; b</code></td>
    <td>Not equals</td>
  </tr>
  <tr>
    <td><code>a &gt;= b</code></td>
    <td>Greater than or equal</td>
  </tr>
  <tr>
    <td><code>a &gt; b</code></td>
    <td>Greater than</td>
  </tr>
</table>

<p>a and b must both be numeric types or both be strings.  String comparison is
lexicographic: a &lt; b if the first differing character code is lower in a
than b or a is a prefix of b.

<p>The result is an integer 0 for false and -1 for true.

<h3 id="logic-ops">Logical Operators</h3>

<table>
  <tr>
    <th>Operator</th>
    <th>Description</th>
  </tr>
  <tr></tr>
    <td><code>a AND b</code></td>
    <td>a & b</td>
  </tr>
  <tr>
    <td><code>a OR b</code></td>
    <td>a | b</td>
  </tr>
  <tr>
    <td><code>a XOR b</code></td>
    <td>a ^ b</td>
  </tr>
  <tr>
    <td><code>a EQV b</code></td>
    <td>~(a ^ b)</td>
  </tr>
  <tr>
    <td><code>a IMP b</code></td>
    <td>~a | b</td>
  </tr>
  <tr>
    <td><code>NOT a</code></td>
    <td>~a</td>
  </tr>
</table>

<p>These are really just arithmetic operations.  The result is an integer or
long following the same rules as for <a class="keyword"
href="#arith-ops">division</a>.

<h3 id="conversions">Type Conversions</h3>

<p>Arithmetic operators automatically <a class="keyword"
href="#arith-ops">convert</a> operand types when necessary.

<p>Builtin functions and procedures expect certain parameter types.  QBasic
tries to convert numeric parameters to the expected numeric type, and tries to
convert results to the expected type for assignments.  A runtime error occurs if
a conversion is illegal.

<p>Some builtin functions are polymorphic.  For example <a class="keyword"
href="#abs">ABS</a> accepts any numeric type and returns a value of the same
type.  And <a class="keyword" href="#sin">ATN</a> returns a double if its
argument is a double, otherwise single.  User-defined procedures are not
polymorphic.

<p>Conversion functions
  <a class="keyword" href="#cint">CINT</a>
  <a class="keyword" href="#clng">CLNG</a>
  <a class="keyword" href="#csng">CSNG</a>
  <a class="keyword" href="#cdbl">CDBL</a>
explicitly convert a value to a desired type.

<h3 id="user-types">User-defined Types</h3>

<p>The <code>TYPE</code> statement lets you define your own types as
compositions of <a class="keyword" href="#types">builtin types</a> and other
user-defined types. Types consist of named elements. All elements must be of a
fixed size.</p>

<pre>
' A Pet has a name up to 20 characters long.
TYPE Pet
  Name AS STRING * 20
END TYPE

' A Person has a name up to 40 characters long,
' an age which is presumed to be less than 32768,
' a height as a single precision float in cm,
' and a dog.
TYPE Person
  Name   AS STRING * 40
  Age    AS INTEGER
  Height AS SINGLE
  Dog    AS Pet
END TYPE

' The variable Joe has type Person.
DIM Joe AS Person

' Use variable dot element to refer to type elements.
Joe.Name = "Joe"
Joe.Age  = 22
Joe.Height = 182.88
Joe.Dog.Name = "Milo"
</pre>

<p>A type element can be accessed using the syntax <code>var.element</code>.
Note that element names cannot include periods or sigils, and elements cannot be
arrays.

<h3 id="constants">Named Constants</h3>

<p>A constant is a name for a <a class="keyword" href="#values">value</a>
defined at compile time.  Constants can be used in arithmetic expressions
anywhere a value would be used.  A constant's type is automatically inferred
from its value, or given by an explicit <a class="keyword"
href="#sigil">sigil</a>.

<pre>
CONST False = 0
CONST True = NOT False
CONST Pi! = 3.14159
</pre>

Constants can be defined using arithmetic expressions involving values and other
constants, but not function calls.

<pre>
' You can use arithmetic to define constants.
CONST W = 80, H = 25, Area = W * H
' This fails at compile time with "Invalid constant".
CONST Angle = ATN(1)
</pre>

<p>A name used for a constant cannot also be used for a variable or procedure,
and each constant name can only have one type.

<pre>
CONST W% = 80
' This is a "Duplicate definition" error, because W is
' already reserved for the value 80.
CONST W$ = "Hello"
' Ditto.
W% = 40
' Ditto.
SUB W: END SUB
</pre>

<p>Constants defined in a procedure body are local to that procedure.

<pre>
CONST k% = 42, k2% = 1
SUB foo
  CONST k% = 50, k3% = 5
  ' Prints 50, 1.
  ' The local k% takes precedence over global k%,
  ' but k2% is looked up from global scope.
  PRINT k%, k2%
END SUB
' Prints 42, 0 because CONST k3% is not in scope here.
' So this k3% is an implicit variable definition.
PRINT k%, k3%
foo
</pre>

<h3 id="variables">Variables</h3>

<p>A variable is a name for a <a class="keyword" href="#values">value</a> or an
<a class="keyword" href="#arrays">array</a> of values in memory. Variable names
must start with a letter and may include letters, periods, and numbers.

<pre>
x = 2
Thing42% = 1
i.am.a.variable = 42
</pre>

<p>Every variable has a <a class="keyword" href="#type">type</a> defined at
compile time. A variable's type can be specified by putting a <a class="keyword"
href="#sigil">sigil</a> after its name, so <code>p&</code> means a 32-bit signed
integer <code>p</code>.  <code>p&</code> and <code>p$</code> are different
variables, and it is valid to use both in the same program.

<p>Variables can also be declared to have some type using declaration statements
<a class="keyword" href="#dim">DIM</a>
<a class="keyword" href="#common">COMMON</a>
<a class="keyword" href="#static">STATIC</a>
<a class="keyword" href="#shared">SHARED</a> with <code>AS</code> syntax.
For example, <code>DIM x AS INTEGER</code> declares
<code>x</code> without any sigil to be a 16-bit signed integer. After an AS
declaration, the name <code>x</code> can only have integer type.

<pre>
DIM x as INTEGER
PRINT x   ' Ok, prints an integer named x.
PRINT x%  ' Ditto.
' Since the name x has been declared as an integer, can't have
' other variables named x with a different type anymore.
PRINT x$  ' Error: Duplicate definition.
</pre>

<p>If a variable name has no sigil and no AS-declared type, its type is
determined by the current <a class="keyword" href="#deftype">DEFtype</a>.

<h3 id="arrays">Arrays</h3>

<p>Arrays are groups of values with the same type.  A variable refers to an
array of its type when it is followed by indices in parentheses.

<pre>
FOR i = 0 TO 2
  ' Define the ith element of the array x.
  ' The array is created implicitly when first used, and has
  ' values of whatever type x has.
  x(i) = i
NEXT i
' Sum the first, second, and third elements of x.
PRINT x(0) + x(1) + x(2)
</pre>

<p>Note that the same name can refer to both an array variable and a normal
variable with one value (a "scalar" variable).

<pre>
' q and q() are different variables.
q = 42
q(2) = 10
PRINT q, q(2)
</pre>

<p>Arrays can have multiple dimensions with an index per dimension.

<pre>
m(1, 2) = 55
n(0, 3, 6) = 6
</pre>

<p>Array indices usually start at 0, although this can be changed with <a
class="keyword" href="#option">OPTION BASE</a>. Implicitly defined arrays have a
maximum index of 10 in each dimension. You can specify bounds for each dimension
with <a class="keyword" href="#dim">DIM</a>.

<pre>
' Define a 2d array x% of integer values.
' First dimension has indices ranging from -5 to 5
' Second dimension has indices ranging from 0 to 32
DIM x%(-5 TO 5, 32)
x%(-5, 0) = 30
x%(4, 32) = 30
</pre>

<p>AS type declarations for a name apply to both array and scalar variables with
that name.

<pre>
DIM x AS INTEGER
x = 42
' x(2) implicitly defines an integer array.
x(2) = 10
' Illegal because x$ is not an integer.
x$(2) = "nope"

DIM y(10) AS STRING
' This is ok, because y has string type.
y$ = "ok"
' Illegal because y% is not a string.
y% = 42
</pre>

<h3 id="array-allocation">Array Allocation</h3>

<h3 id="encodings">Character Encodings</h3>

<p>MS-DOS files like QBasic programs mostly use <a target="_blank"
href="https://en.wikipedia.org/wiki/Code_page_437">CP437 ASCII</a> encoding.

<p>qbasic.run represents strings using Unicode internally so that debuggers and
other tools see intelligible strings, while QBasic code still sees the original
CP437 code points.  For example, CP437 character 1 (☺︎) is stored in memory as
U+263A WHITE SMILING FACE.  Since JavaScript strings use UTF-16, this doesn't
cost much.

<p>When you open a program, the shell usually guesses it is CP437 encoded and
translates it to Unicode to deal with funky characters like ☺ or ░▒▓.  But if
the program is already valid UTF-8, the shell first tries to load it without
doing any translation - so you can edit programs with modern tools, save them as
UTF-8, and reload them later.  This heuristic mostly works fine since extended
ASCII isn't likely to be valid UTF-8, and nonprintable characters 1-31 aren't
recognized code points.

<p>DOS used &H0D &H0A for new lines in text files, while Unix uses just &H0A.
qbasic.run will parse either &H0D &H0A or just &H0A as a newline, but writes
&H0A.

<h3 id="precision">Precision</h3>

<p>Semantically JavaScript does all math with doubles, so qbasic.run uses
doubles.  It tries to match single precision results by internally rounding to
the nearest single-precision values using <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround">Math.fround()</a>.
But this is not exact.

<p>When floats must be converted to integers for arithmetic, halfway cases
are rounded to the nearest even number.  This is different than standard
JavaScript rounding which rounds halfway cases up.  qbasic.run rounds correctly.

<pre>
  print 3.5 \ 1  ' 4
  print 2.5 \ 1  ' 2
</pre>

</body>
</html>