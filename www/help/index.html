<!doctype html>
<html>
<head>
<title>qbasic.run - Help</title>
<link rel="preload" href="/WebPlus_IBM_VGA_8x16.woff" as="font" type="font/woff" crossorigin />
<link href="help.css" rel="stylesheet">
</head>
<body>
<p>If you are reading this, you must truly need help.  I'll do my best.
<p>These books written by actual technical writers are really good, though
somewhat dated and presuming less general technical knowledge and perhaps more
nicotine and hairspray use than are now the norm.
<ul>
<li><a target="_blank"
href="https://www.pcjs.org/documents/books/mspl13/basic/qblang/">Microsoft
QuickBASIC: Language Reference</a>
<li><a target="_blank"
href="https://www.pcjs.org/documents/books/mspl13/basic/qbprog/">Microsoft
QuickBASIC: Programming in BASIC</a>
</ul>

<p><a href="#quickstart">Quick Start</a>

<a name="quickstart">
<h2>Quick Start</h2>

<p>Here's a simple program so you can see what we're dealing with.

<pre>
' This is a procedure (a subroutine) named PrintKey.
' It takes one string parameter k$ and shows its value on
' the screen.
SUB PrintKey (k$)
  PRINT "You pressed "; k$
END SUB

DO
  ' Call the builtin function INKEY$ to read whatever key
  ' is pending from the keyboard.
  k$ = INKEY$
  IF k$ <> "" THEN
    ' If key is not empty, call our subroutine to display it.
    PrintKey k$
  END IF
' Loop until a key is pressed.
LOOP WHILE k$ = ""
</pre>

<p>QBasic is a <a class="keyword" href="#types">statically typed</a> procedural
language with block structure and two levels of scope. Global variables exist
the entire time a program is running, and are only visible outside procedures.
Local variables are allocated on a stack each time a procedure is called, and
only exist during that call.

<p>Variables are implicitly defined the first time they are used, but can also
be declared before use. Variable declarations can change default scope behavior.
Globals can be made visible by declaring them <a class="keyword"
href="#shared">SHARED</a> with all
procedures or within specific procedures. Locals declared <a class="keyword"
href="#static">STATIC</a> persist after procedure calls. Globals declared <a
class="keyword" href="#common">COMMON</a> can persist after a program finishes,
by being passed to another program (no, really).

<p>By default, procedure parameters are passed by reference.

<pre>
' Increment adds 1 to its integer parameter.
SUB Increment (i%)
  ' This i% refers to the global j%, so modifying it
  ' will also modify j%
  i% = i% + 1
END SUB

j% = 41
Increment j%
PRINT j%  ' Prints 42.
</pre>

<p>Procedures defined with <a class="keyword" href="#function">FUNCTION</a>
return a value instead of just modifying their parameters.

<pre>
' Increment% returns its integer parameter's value + 1.
FUNCTION Increment% (i%)
  ' Return by assigning to the function name.
  Increment% = i% + 1
END FUNCTION

PRINT Increment(41)  ' Prints 42.
</pre>

<p>QBasic also supports some older procedure constructs <a class="keyword"
href="#deffn">DEF FN</a> and <a class="keyword" href="#gosub">GOSUB</a>.</p>
<p>Older BASICs use line numbers and <a class="keyword" href="#goto">GOTO</a>
statements heavily, but QBasic prefers block structured programming constructs
like <a class="keyword" href="#blockif">IF...END IF</a>, <a class="keyword"
href="#blockdo">DO...LOOP</a>, <a class="keyword"
href="#for">FOR...NEXT</a>.

<pre>
FOR i = 1 to 10
  IF foo THEN
    ' Do this if foo is true ...
  ELSE IF bar THEN
    ' Otherwise, do this if bar is true ...
  ELSE
    ' Otherwise, do this ...
  END IF
NEXT i
</pre>

<a name="types">
<h3>Builtin Types</h3>

<p>All values in QBasic programs have an associated type.

<table>
  <tr>
    <th>Type name</th>
    <th>Sigil</th>
    <th>Range</th>
    <th>Size</th>
  </tr>
  <tr>
    <td><code>INTEGER</code></td>
    <td>%</td>
    <td>
      16-bit signed integer<br>
      -32768 to 32767
    </td>
    <td>2 bytes</td>
  </tr>
  <tr>
    <td><code>LONG</code></td>
    <td>&</td>
    <td>32-bit signed integer<br>
      -2147483648 to 2147483647</td>
    <td>4 bytes</td>
  </tr>
  <tr>
    <td><code>SINGLE</code></td>
    <td>!</td>
    <td>
      Single-precision float<br>
      -3.402823e+38 to 3.402823e+38
    </td>
    <td>4 bytes</td>
  </tr>
  <tr>
    <td><code>DOUBLE</code></td>
    <td>#</td>
    <td>Double-precision float</td>
    <td>8 bytes</td>
  </tr>
  <tr>
    <td><code>STRING</code></td>
    <td>$</td>
    <td>Variable length string<br>up to 32767 bytes</td>
    <td>?</td>
  </tr>
  <tr>
    <td><code>STRING * n%</code></td>
    <td>$</td>
    <td>Fixed length string</td>
    <td>n% bytes</td>
  </tr>
</table>

<a name="sigil">
<p>A value's type can be specified by putting a sigil character after it.

<pre>
PRINT 320& * 200&  ' Impossibly huge 32-bit numbers.
</pre>

<a name="values">
<h3>Literal values</h3>

<p>QBasic operates on integers, floating point numbers (floats), and strings.

<p>A base-10 number with no decimal point and no sigil is read as the smallest
type that fits it: an integer, a long, or a double.  But note -32768 is read as
a long, and -2147483648 as a double.  Integers can be given in hex by prefixing
them with <code>&H</code> and octal by prefixing them with <code>&O</code>.
Numbers are always signed, so <code>&HFFFF = -1</code>.

<p>Numbers with a decimal point like 3.14 or numbers in scientific notation like
6.02E23 are floats.  Decimals are read as singles if they have 7 or fewer
digits, else doubles.  Scientific notation numbers are singles if they use E to
mark the exponent, and doubles if they use D.  If you try to write an E-number
with more than 7 digits, QBasic changes E to D when you press enter.

<pre>
  print 42        ' integer
  print 32768     ' long
  print 3.142857  ' single
  print 6.02e23   ' single
  print 6.02d23   ' double
</pre>

<p>Strings are groups of bytes which may either be binary data or
<a target="_blank" href="https://en.wikipedia.org/wiki/Code_page_437">CP437
ASCII</a> text. Variable-length strings are stored along with a 16-bit
integer length, so they may include NUL characters.

<pre>
  s$ = "I am a string."
  ' To put quotes in a string, use CHR$(34).
  t$ = CHR$(34) + "I say," + CHR$(34) + " he said."
  ' Strings can contain arbitrary bytes.
  u$ = CHR$(0) + CHR$(26)
</pre>

<p>The + operator concatenates two strings into a new string.

<p>See this note for more details about how qbasic.run handles <a class="keyword"
href="#encodings">string encodings</a>.

<a name="arith-ops">
<h3>Arithmetic Operators</h3>

<table>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Result Type</th>
  </tr>
  <tr>
    <td><code>a + b</code></td>
    <td>Addition</td>
    <td>Most precise of a or b</td>
  </tr>
  <tr>
    <td><code>a - b</code></td>
    <td>Subtraction</td>
    <td>Most precise of a or b</td>
  </tr>
  <tr>
    <td><code>a * b</code></td>
    <td>Multiplication</td>
    <td>Most precise of a or b</td>
  </tr>
  <tr>
    <td><code>a / b</code></td>
    <td>Floating point division</td>
    <td>a or b DOUBLE -> DOUBLE<br>
        otherwise SINGLE</td>
  </tr>
  <tr>
    <td><code>a \ b</code></td>
    <td>Integer division</td>
    <td>a and b INTEGER -> INTEGER<br>
        otherwise LONG</td>
  </tr>
  <tr>
    <td><code>a MOD b</code></td>
    <td>Integer remainder</td>
    <td>a and b INTEGER -> INTEGER<br>
        otherwise LONG</td>
  </tr>
  <tr>
    <td><code>a ^ b</code></td>
    <td>Floating point exponent</td>
    <td>a or b DOUBLE -> DOUBLE<br>
        otherwise SINGLE</td>
  </tr>
  <tr>
    <td><code>-a</code></td>
    <td>Negation</td>
    <td>a</td>
  </tr>
</table>

<p>(For "most precise", DOUBLE > SINGLE > LONG > INTEGER.)

<p>Arithmetic precision is determined by operand types, which can be confusing.

<pre>
  print 320 * 200 ' Overflow error!
</pre>

<p>A runtime error occurs if math operations overflow.  In the example above,
320 and 200 are both 16-bit signed integers, but their product 64000 > 32767.
Similarly, there are runtime errors for division by zero and 0 ^ -k.

<p>If operands are not already the correct types, they are converted first.  For
example, this means double arguments to integer division must fit in a long.

<pre>
  print 2147483648# \ 2#  ' Overflow error!
</pre>

There are a few more details about qbasic.run artihmetic <a class="keyword"
href="#precision">precision</a>.

<a name="comparison-ops">
<h3>Comparison Operators</h3>

<table>
  <tr>
    <th>Operator</th>
    <th>Description</th>
  </tr>
  <tr></tr>
    <td><code>a = b</code></td>
    <td>Equals</td>
  </tr>
  <tr>
    <td><code>a &lt; b</code></td>
    <td>Less than</td>
  </tr>
  <tr>
    <td><code>a &lt;= b</code></td>
    <td>Less than or equal</td>
  </tr>
  <tr>
    <td><code>a &lt;&gt; b</code></td>
    <td>Not equals</td>
  </tr>
  <tr>
    <td><code>a &gt;= b</code></td>
    <td>Greater than or equal</td>
  </tr>
  <tr>
    <td><code>a &gt; b</code></td>
    <td>Greater than</td>
  </tr>
</table>

<p>a and b must both be numeric types or both be strings.  String comparison is
is lexicographic: a &lt; b if the first differing character code is lower in a
than b or a is a prefix of b.

<p>The result is an integer 0 for false and -1 for true.

<a name="logic-ops">
<h3>Logical Operators</h3>

<table>
  <tr>
    <th>Operator</th>
    <th>Description</th>
  </tr>
  <tr></tr>
    <td><code>a AND b</code></td>
    <td>a & b</td>
  </tr>
  <tr>
    <td><code>a OR b</code></td>
    <td>a | b</td>
  </tr>
  <tr>
    <td><code>a XOR b</code></td>
    <td>a ^ b</td>
  </tr>
  <tr>
    <td><code>a EQV b</code></td>
    <td>~(a ^ b)</td>
  </tr>
  <tr>
    <td><code>a IMP b</code></td>
    <td>~a | b</td>
  </tr>
  <tr>
    <td><code>NOT a</code></td>
    <td>~a</td>
  </tr>
</table>

<p>These are really just arithmetic operations.  The result is an integer or
long following the same rules as for <a class="keyword"
href="#arith-ops">division</a>.

<a name="conversions">
<h3>Type conversions</h3>

<p>Arithmetic operators automatically <a class="keyword"
href="#arith-ops">convert</a> operands to the necessary precision.

<p>Builtin functions and statements and user-defined procedures expect certain
parameter types.  If a value has the wrong numeric type, QBasic tries to convert
it to the expected type.  A runtime error occurs if the conversion is illegal.

<p>Conversion functions
  <a class="keyword" href="#cint">CINT</a>
  <a class="keyword" href="#clng">CLNG</a>
  <a class="keyword" href="#csng">CSNG</a>
  <a class="keyword" href="#cdbl">CDBL</a>
can be called explicitly.

<h3>User-defined types</h3>

<p>The <code>TYPE</code> statement lets you define your own types as
compositions of <a class="keyword" href="#types">builtin types</a> and other
user-defined types. Types consist of named elements. All elements must be of a
fixed size.</p>

<pre>
' A Pet has a name which can be up to 20 characters long.
TYPE Pet
  Name AS STRING * 20
END TYPE

' A Person has a name up to 40 characters long,
' an age which is presumed to be less than 32768,
' a height as a single precision float in cm,
' and a dog.
TYPE Person
  Name   AS STRING * 40
  Age    AS INTEGER
  Height AS SINGLE
  Dog    AS Pet
END TYPE

' The variable Joe has type Person.
DIM Joe AS Person

' Use variable dot element to refer to type elements.
Joe.Name = "Joe"
Joe.Age  = 22
Joe.Height = 182.88
Joe.Dog.Name = "Milo"
</pre>

<p>A type element can be accessed using the syntax <code>var.element</code>.
Note that element names cannot include periods or sigils, and elements cannot be
arrays.

<a name="variables">
<h3>Variables</h3>

<p>A variable is a name for a <a class="keyword" href="#values">value</a> or an
<a class="keyword" href="#arrays">array</a> of values in memory. Variable names
must start with a letter and may include letters, periods, and numbers.

<p>A variable's <a class="keyword" href="#type">type</a> can be specified by
putting a <a class="keyword" href="#sigil">sigil</a> after its name, so
<code>p&</code> means a 32-bit signed integer <code>p</code>.  <code>p&</code>
and <code>p$</code> are different variables.

<p>Variables can also be declared to have some type using declaration statements
<a class="keyword" href="#dim">DIM</a>
<a class="keyword" href="#common">COMMON</a>
<a class="keyword" href="#static">STATIC</a>
<a class="keyword" href="#shared">SHARED</a> with <code>AS</code> syntax.
For example, <code>DIM x AS INTEGER</code> declares
<code>x</code> without any sigil to be a 16-bit signed integer. Afterwards, the
name <code>x</code> can only have integer type.

<pre>
  DIM x as INTEGER
  PRINT x   ' Ok, prints an integer named x.
  PRINT x%  ' Ditto.
  ' Since the name x has been declared as an integer, can't have
  ' other variables named x with a different type anymore.
  PRINT x$  ' Error: Duplicate definition.
</pre>

<p>If a variable name has no sigil and no AS-declared type, its type is
determined by the current <a class="keyword" href="#deftype">DEFtype</a>.

<a name="arrays">
<h3>Arrays</h3>

<a name="encodings">
<h3>Encodings</h3>

<p>qbasic.run represents strings using Unicode internally so that debuggers and
other tools see intelligible strings, while QBasic code still sees the original
CP437 code points.  For example, CP437 character 1 (☺︎) is stored as U+263A.
Since JavaScript strings use UTF-16, this makes little practical difference.

<p>When you open a program, the shell usually guesses it is CP437 encoded and
translates it to Unicode to deal with funky characters like ☺ or ░▒▓.  But if
the program is already valid UTF-8, the shell first tries to load it without
doing any translation - so you can edit programs with modern tools, save them as
UTF-8, and reload them later.  This heuristic mostly works fine since extended
ASCII isn't likely to be valid UTF-8, and nonprintable characters 1-31 aren't
recognized code points.

<p>DOS used &H0A &H0D for new lines in text files, while Unix uses just &H0A.
qbasic.run will parse either &H0A &H0D or just &H0A as a newline, but writes
&H0A.

<a name="precision">
<h3>Precision</h3>

<p>Semantically JavaScript does all math with doubles, so qbasic.run uses
doubles.  It tries to match single precision results by internally rounding to
the nearest single-precision values using <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround">Math.fround()</a>.
But this is not exact.

<p>When floats must be converted to integers for arithmetic, halfway cases
are rounded to the nearest even number.  This is different than standard
JavaScript rounding which rounds halfway cases up.  qbasic.run rounds correctly.

<pre>
  print 3.5 \ 1  ' 4
  print 2.5 \ 1  ' 2
</pre>

</body>
</html>